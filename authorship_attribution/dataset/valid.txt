fileName = raw_input("File name: ")\n  \n  f = open(fileName,"r")\n  \n  t = int(f.readline()[:-1])\n  \n  tests = []\n  \n  for i in range (t):\n      tests += [f.readline()[:-1]]\n  \n  f.close()\n  \n  \n  def compute(raw):\n      dataN = [] # keeps the max mark for not surprising\n      dataS = [] # keeps the max marks for surprisings\n      \n      items = raw.split() \n      \n      for i in range (int(items[0])):\n          ti = int(items[3+i])\n          if ti < 1:\n              dataS += [0]\n              dataN += [0]\n          elif ti > 28:\n              dataS += [10]\n              dataN += [10]\n          else:\n              dataN += [int((ti+2)/3)] # put the values for all participants\n              dataS += [int((ti+4)/3)]\n          \n          \n  \n      \n      p = int(items[2])\n      s = int(items[1])\n      \n      n_vals = dataN\n      n_vals.sort()\n      \n  \n      i=0\n      minimum = 0 # how many numbers greater than p are there in "not surprising"\n      if n_vals[0] < p:\n          while n_vals[-1-i] >= p:\n              minimum += 1\n              i += 1\n      else:\n          minimum = len(n_vals)\n          \n  \n      s_vals = dataS\n      s_vals.sort()\n      i=0\n      maximum = 0 # how many numbers greater than p are there in "surprising"\n      if s_vals[0] < p:\n          while s_vals[-1-i] >= p:\n              maximum += 1\n              i += 1\n      else:\n          maximum = len(n_vals)\n      \n      return min(maximum, minimum+s) \n      \n  \n  for i in range (t):\n      print "Case #%d: %d" %(i+1,compute(tests[i]))\n  \n  \n      \n <CODESPLIT> 0
filename = raw_input("Name of file: ")\n  infile = open(filename, "r")\n  outfile = open(filename + ".out", "w")\n  \n  \n  T = int(infile.readline()[:-1])\n  \n  def addMinesDiagonally(r, c, m):\n      field = []\n      for i in range (r):\n          row = []\n          for j in range(c):\n              row += ["."]\n          field += [row]\n          \n      for i in range (r + c):\n          ver = min (i, r - 1)\n          hor = max (0, 1 + i - r)\n          while ver >= 0 and hor <= c - 1 and m > 0:\n              if m == 1 and hor == c - 2 and ver == r - 2:\n                  ver -= 1\n                  hor += 1\n              field[ver][hor] = "*"\n              ver -= 1\n              hor += 1\n              m -= 1\n          \n      return field\n  \n  def isPossible(field):\n      if field[-1][-1] != ".":\n          return False\n      up = True\n      left = True\n      diag = True\n      if len(field) > 1 and field[-2][-1] != ".":\n              up = len(field[-1]) <= 1\n      if len(field[-1]) > 1 and field[-1][-2] != ".":\n              left = len(field) <= 1\n      if len(field) > 1 and len(field[-1]) > 1 and field[-2][-2] != ".":\n          diag = False\n      return (up and left and diag) or \\n             ((not up) and (not left) and (not diag))\n      \n  \n  for t in range(1, T + 1):\n      items = infile.readline()[:-1].split(" ")\n      r = int(items[0])\n      c = int(items[1])\n      m = int(items[2])\n      field = addMinesDiagonally(r, c, m)\n      if isPossible(field):\n          field[-1][-1] = "c"\n          s = ""\n          for line in field:\n              for cell in line:\n                  s += cell\n              s += "\n"\n          outfile.write("Case #%d:\n%s\n" %(t, s[:-1]))\n      else:\n          s = "IMPOSSIBLE!!!!\n"\n          for line in field:\n              for cell in line:\n                  s += cell\n              s += "\n"\n          outfile.write("Case #%d:\n%s\n" %(t, s[:-1]))\n      \n          \n      \n  \n  outfile.close()\n  infile.close()\n <CODESPLIT> 0
 \n  t = int(sys.stdin.readline())\n  for i in range(t):\n  	inputline = sys.stdin.readline().strip()\n  	inputparams = inputline.split()\n  \n  	n = int(inputparams[0])\n  	s = int(inputparams[1])\n  	p = int(inputparams[2])\n  	validcount = 0\n  	surprisingcount = 0\n  	for j in range(n):\n  		score = int(inputparams[3 + j])\n  		if (p + (p - 1) * 2) <= score:\n  			validcount += 1\n  		elif ((p + (p - 2) * 2) <= score) and (p <= score):\n  			surprisingcount += 1\n  \n  	print "Case #%d: %d" % (i + 1, validcount + min(surprisingcount, s))\n <CODESPLIT> 1
 \n  def generate_matrix(r, c, char):\n  	mat = [[char for i in range(c)] for j in range(r)]\n  	return mat\n  	\n  def merge(mat1, mat2):\n  	for i in range(len(mat1)):\n  		for j in range(len(mat1[i])):\n  			mat2[i][j] = mat1[i][j]\n  	return mat2\n  \n  def solve(r, c, m):\n  	if 0 == m:\n  		mat = generate_matrix(r, c, '.')\n  		mat[0][0] = 'c'\n  		return mat\n  		\n  	f = r * c - m\n  	\n  	if 0 == f:\n  		return False\n  		\n  	if 1 == f:\n  		mat = generate_matrix(r, c, '*')\n  		mat[0][0] = 'c'\n  		return mat\n  		\n  	if 1 == min(r, c):\n  		mat = generate_matrix(r, c, '*')\n  		for i in range(f):\n  			mat[0 if 1 == r else i][0 if 1 == c else i] = '.'\n  		mat[0][0] = 'c'\n  		return mat\n  \n  	if 2 == min(r, c):\n  		if (0 != f % 2) or (2 == f):\n  			return False\n  		mat = generate_matrix(r, c, '*')\n  		for i in range(f // 2):\n  			mat[0 if 2 == r else i][0 if 2 == c else i] = '.'\n  			mat[1 if 2 == r else i][1 if 2 == c else i] = '.'\n  		mat[0][0] = 'c'\n  		return mat\n  		\n  	if (3 == r) and (3 == c):\n  		if (4 == f) or (6 == f):\n  			mat = generate_matrix(r, c, '*')\n  			for i in range(f // 2):\n  				mat[0][i] = '.'\n  				mat[1][i] = '.'\n  			mat[0][0] = 'c'\n  			return mat\n  		if 8 == f:\n  			mat = generate_matrix(r, c, '.')\n  			mat[2][2] = '*'\n  			mat[0][0] = 'c'\n  			return mat\n  		return False\n  		\n  	rows_to_reduce = min(r - 3, m // c)\n  	if 0 < rows_to_reduce:\n  		res = solve(r - rows_to_reduce, c, m - rows_to_reduce * c)\n  		if False == res:\n  			return False\n  		mat = merge(res, generate_matrix(r, c, '*'))\n  		return mat\n  		\n  	cols_to_reduce = min(c - 3, m // r)\n  	if 0 < cols_to_reduce:\n  		res = solve(r, c - cols_to_reduce, m - cols_to_reduce * r)\n  		if False == res:\n  			return False\n  		mat = merge(res, generate_matrix(r, c, '*'))\n  		return mat\n  	\n  	mat = generate_matrix(r, c, '.')\n  	for i in range(min(m, r - 2)):\n  		mat[r - i - 1][c - 1] = '*'\n  	if m == r - 1:\n  		mat[r - 1][c - 2] = '*'\n  	mat[0][0] = 'c'\n  	return mat\n  			\n  \n  t = int(sys.stdin.readline().strip())\n  \n  for i in range(t):\n  	print "Case #" + str(i + 1) + ":"\n  \n  	r, c, m = [int(i) for i in sys.stdin.readline().strip().split()]\n  	\n  	res = solve(r, c, m)\n  	\n  	if False == res:\n  		print "Impossible"\n  	else:\n  		for i in range(r):\n  			for j in range(c):\n  				sys.stdout.write(res[i][j])\n  			print\n <CODESPLIT> 1
 \n  def decode_data(input):\n      output = ""\n      for letter in input:\n          if letter in library:\n              output += library[letter]\n      return output\n  \n  if __name__ == "__main__":\n      f = sys.stdin\n      if len(sys.argv) >= 2:\n          fn = sys.argv[1]\n          if fn != '-':\n              f = open(fn)\n  \n      t = int(f.readline())    \n      for _t in range(t):\n          s = f.readline()\n          s = s.split()\n          N = int(s[0])\n          S = int(s[1])\n          p = int(s[2])\n          low_scores = (p - 1) * 2\n          ti = s[3:]\n          ti.sort()\n          r = 0\n          ti = [int(x) for x in ti]\n          for i in ti:\n              score = i - low_scores\n              if p <= i:\n                  if score >= p:\n                      r += 1\n                  elif score >= p - 2 and S > 0:\n                      S -= 1\n                      r +=1\n          print ("Case #" + str(_t+1) + ": " + str(r))\n      \n  \n <CODESPLIT> 2
 \n  if __name__ == "__main__":\n      f = sys.stdin\n      if len(sys.argv) >= 2:\n          fn = sys.argv[1]\n          if fn != '-':\n              f = open(fn)\n  \n      t = int(f.readline())\n      for _t in range(t):\n  \n          R, C, M = [int(x) for x in f.readline().split()]\n          free_spots = R * C - M - 1\n  \n          if M == 0:\n              answer = [["." for x in range(C)] for y in range(R)]\n              answer[0][0] = "c"\n          elif R == 1:\n              answer = [["c"] + ["." for x in range(free_spots)] + ["*" for m in range(M)]]\n          elif C == 1:\n              answer = [["c"] + ["." for x in range(free_spots)] + ["*" for m in range(M)]]\n              answer = zip(*answer[::-1])\n          elif free_spots >= 3: # and M % R >= 2:\n              answer = [["*" for x in range(C)] for y in range(R)]\n              answer[0][0] = "c"\n              answer[0][1] = "."\n              answer[1][1] = "."\n              answer[1][0] = "."\n              free_spots -= 3\n              tr, br, c = 0, 1, 2\n              if c >= C:\n                  tr, br, c = 2, 3, 0\n              for _i in range(free_spots):\n                  if answer[tr][c] == "*":\n                      answer[tr][c] = "."\n                  elif answer[br][c] == "*":\n                      answer[br][c] = "."\n                      if c < C-1:\n                          c+=1\n                      else:\n                          tr, br = tr + 2, br + 2\n                          c = 0\n                          if br == R:\n                              br, tr = br-1, tr-1\n                  \n          else:\n              answer = ["Impossible",]\n  \n          \n          \n          print ("Case #" + str(_t+1) + ":")\n          for _i in answer:\n              print "".join(_i)\n      \n  \n <CODESPLIT> 2
 \n  \n  INPUT = "tiny"\n  \n  INPUT = "B-small-attempt0.in.txt"\n  \n  def debug(*args):\n      pass #print str(args)\n  \n  def zdebug(*args):\n      print ''.join(str(s) for s in args)\n  \n  def can_score_p(N, p):\n      low_p = max(p-1, 0)\n      if low_p + low_p + p <= N:\n          return "Y"\n      low_p = max(p-2, 0)\n      if low_p + low_p + p <= N:\n          return "S"\n      return "N"\n  \n  def do_trial(N, S, p, *scores):\n      d = { "Y" : 0, "N" : 0, "S" : 0 }\n      for s in scores:\n          v = can_score_p(s, p)\n          debug("score %s p=%s : %s" % (s, p, v))\n          d[v] = d[v] + 1\n      return d["Y"] + min(d["S"], S)\n  \n  f = file(INPUT)\n  T = int(f.readline()[:-1])\n  for i in range(T):\n      l = [int(x) for x in f.readline()[:-1].split()]\n      v = do_trial(*l)\n      print "Case #%d: %s" % (i+1, v)\n <CODESPLIT> 3
 \n  \n  \n  \n  INPUT = "tiny"\n  INPUT = "C-small-attempt1.in"\n  \n  def debug(*args):\n      sys.stderr.write(str(args) + "\n")\n  \n  class Memoize:\n      def __init__(self,function):\n          self._cache = {}\n          self._callable = function\n              \n      def __call__(self, *args, **kwds):\n          cache = self._cache\n          key = self._getKey(*args,**kwds)\n          try: return cache[key]\n          except KeyError:\n              cachedValue = cache[key] = self._callable(*args,**kwds)\n              return cachedValue\n      \n      def _getKey(self,*args,**kwds):\n          return kwds and (args, ImmutableDict(kwds)) or args    \n  \n  IMPOSSIBLE = set([(2,2,2), (2,2,1), (2,3,1), (2,4,1), (2,5,1)])\n  \n  for i in range(2,51):\n      IMPOSSIBLE.add((2,i,1))\n      IMPOSSIBLE.add((i,2,1))\n  \n  SOLN = {\n      (1,2,1) : ["c*"],\n      (2,1,1) : ["c", "*"],\n      (2,2,3) : ["c*", "**"],\n  }\n  \n  def solve(R, C, M):\n      if M == 0:\n          s = ["c%s" % ('.' * (C-1))]\n          for i in range(R-1):\n              s.append('.' * C)\n          return s\n      t = (R, C, M)\n      if t in IMPOSSIBLE:\n          debug("** %s %s %s" % t)\n          raise ValueError\n      if t in SOLN:\n          return SOLN[t]\n  \n      if C < M and R > 2:\n          try:\n              return solve(R-1, C, M-C) + ["*" * C]\n          except ValueError:\n              pass\n  \n      if C <= R:\n          if M >= C and R > 2:\n              return solve(R-1, C, M-C) + ["*" * C]\n      else:\n          if M >= R and C > 2:\n              return ["%s*" % s for s in solve(R, C-1, M-R)]\n      if R > 2:\n          mines = min(C, M)\n          if mines == C - 1:\n              mines -= 1\n          try:\n              return solve(R-1, C, M-mines) + [("." * (C - mines)) + ("*" * mines)]\n          except ValueError:\n              if C > 2:\n                  mines = min(R, M)\n              if mines == R - 1:\n                  mines -= 1\n              s = ["%s%s" % (s, '*' if k > C-mines else '.') for k, s in enumerate(solve(R, C-1, M-mines))]\n              return s\n      debug(R, C, M)\n      return []\n  \n  def do_trial(R, C, M):\n      try:\n          r = solve(R,C,M)\n          s = "\n" + '\n'.join(r)\n          assert len(r) == R\n          for r1 in r:\n              assert len(r1) == C\n          assert len(''.join(k for k in s if k == '*')) == M\n          return s\n      except ValueError:\n          return "\nImpossible"\n  \n  \n  def all():\n      for R in range(1,50):\n          for C in range(1,50):\n              for M in range(R*C):\n                  print(R, C, M)\n                  print(do_trial(R, C, M))\n      sys.exit(0)\n  \n  \n  f = file(INPUT)\n  T = int(f.readline()[:-1])\n  for i in range(T):\n      R, C, M = [int(x) for x in f.readline().split()]\n      v = do_trial(R, C, M)\n      print "Case #%d: %s" % (i+1, v)\n <CODESPLIT> 3
 \n  \n  \n  \n  \n  def solve(S, p, tlist):\n  	above = 0\n  	consider = 0\n  \n  	for t in tlist:\n  		avg = t / 3\n  		mod = t % 3\n  \n  		if mod == 0:\n  			if avg >= p:\n  				above += 1\n  			elif avg + 1 >= p and t > 0:\n  				consider += 1\n  \n  		elif mod == 1:\n  			if avg + 1 >= p:\n  				above += 1\n  \n  		elif mod == 2:\n  			if avg + 1 >= p:\n  				above += 1\n  			elif avg + 2 >= p:\n  				consider += 1\n  \n  	return above + min(S, consider)\n  \n  \n  def main(IN, OUT):\n  	N = int(IN.readline())\n  	for index in range(N):\n  		data = map(int, IN.readline().strip().split())\n  		(N, S, p), tlist = data[:3], data[3:]\n  		OUT.write('Case #%d: %d\n' % (index + 1, solve(S, p, tlist)))\n  \n  \n  if __name__ == '__main__':\n  	main(sys.stdin, sys.stdout)\n  \n <CODESPLIT> 4
 \n  \n  \n  def check(R, C, M, _board):\n      board = [line[:] for line in _board]\n  \n      pos = [(0, 0)]\n      while pos:\n          row, col = pos.pop()\n          neighbor = []\n          for r in (-1, 0, 1):\n              r += row\n              for c in (-1, 0, 1):\n                  c += col\n                  if r >= 0 and r < R and c >= 0 and c < C:\n                      neighbor.append((r, c))\n          count = len([1 for r, c in neighbor if board[r][c] == '*'])\n          board[row][col] = str(count)\n          if count == 0:\n              for r, c in neighbor:\n                  if board[r][c] == '.':\n                      pos.append((r, c))\n  \n      flat = ''.join(''.join(line) for line in board)\n      result = not flat.count('.')\n      if not result and False: # for DEBUG\n          print '-' * 20\n          print R, C, M\n          print '\n'.join(''.join(line) for line in _board)\n          print '-' * 20\n      assert flat.count('*') == M\n      return result\n  \n  \n  def solve(R, C, M):\n      board = [['.'] * C for row in range(R)]\n      board[0][0] = 'c'\n      row = R\n      col = C\n      mine = M\n  \n      while mine:\n          if 0 < row <= col and mine >= row:\n              for r in range(row):\n                  board[row - r - 1][col - 1] = '*'\n              mine -= row\n              col -= 1\n          elif 0 < col <= row and mine >= col:\n              for c in range(col):\n                  board[row - 1][col - c - 1] = '*'\n              mine -= col\n              row -= 1\n          else:\n              break\n  \n      if mine:\n          while mine and row > 2:\n              for r in range(min(mine, row - 2)):\n                  board[row - r - 1][col - 1] = '*'\n                  mine -= 1\n              col -= 1\n          while mine and col > 2:\n              for c in range(min(mine, col - 2)):\n                  board[row - 1][col - c - 1] = '*'\n                  mine -= 1\n              row -= 1\n  \n      if mine:\n          if mine:\n              board[1][1] = '*'\n              mine -= 1\n          if mine:\n              board[1][0] = '*'\n              mine -= 1\n          if mine:\n              board[0][1] = '*'\n              mine -= 1\n  \n      assert mine == 0\n      return '\n'.join(''.join(line) for line in board) if check(R, C, M, board) else 'Impossible'\n  \n  \n  def main(IN, OUT):\n      T = int(IN.readline())\n      for index in range(T):\n          R, C, M = map(int, IN.readline().split())\n          OUT.write('Case #%d:\n%s\n' % (index + 1, solve(R, C, M)))\n  \n  \n  def makesample(maxSize=5, T=230):\n      print T\n      for index in range(T):\n          R = random.randint(1, maxSize)\n          C = random.randint(1, maxSize)\n          print R, C, random.randint(0, R * C - 1)\n  \n  \n  def makesample():\n      pattern = []\n      for R in range(1, 5+1):\n          for C in range(1, 5+1):\n              for M in range(R * C):\n                  pattern.append((R, C, M))\n      print len(pattern)\n      for R, C, M in pattern:\n          print R, C, M\n  \n  \n  if __name__ == '__main__':\n      if '-makesample' in sys.argv[1:]:\n          makesample()\n      else:\n          main(sys.stdin, sys.stdout)\n  \n <CODESPLIT> 4
 \n  surprising = [[], [], [(0, 0, 2)], [(0, 1, 2)], [(0, 2, 2)], [(1, 1, 3)], [(1, 2, 3)], [(1, 3, 3)], [(2, 2, 4)], [(2, 3, 4)], [(2, 4, 4)], [(3, 3, 5)], [(3, 4, 5)], [(3, 5, 5)], [(4, 4, 6)], [(4, 5, 6)], [(4, 6, 6)], [(5, 5, 7)], [(5, 6, 7)], [(5, 7, 7)], [(6, 6, 8)], [(6, 7, 8)], [(6, 8, 8)], [(7, 7, 9)], [(7, 8, 9)], [(7, 9, 9)], [(8, 8, 10)], [(8, 9, 10)], [(8, 10, 10)], [], []]\n  regular = [[(0, 0, 0)], [(0, 0, 1)], [(0, 1, 1)], [(1, 1, 1)], [(1, 1, 2)], [(1, 2, 2)], [(2, 2, 2)], [(2, 2, 3)], [(2, 3, 3)], [(3, 3, 3)], [(3, 3, 4)], [(3, 4, 4)], [(4, 4, 4)], [(4, 4, 5)], [(4, 5, 5)], [(5, 5, 5)], [(5, 5, 6)], [(5, 6, 6)], [(6, 6, 6)], [(6, 6, 7)], [(6, 7, 7)], [(7, 7, 7)], [(7, 7, 8)], [(7, 8, 8)], [(8, 8, 8)], [(8, 8, 9)], [(8, 9, 9)], [(9, 9, 9)], [(9, 9, 10)], [(9, 10, 10)], [(10, 10, 10)]]\n  \n  f = open(argv[1], 'r')\n  T = int(f.readline().strip('\n'))\n  for i in range(T):\n  	both = 0\n  	surp_only = 0\n  	line = f.readline().strip('\n').split(' ')\n  	N = int(line[0]) # What for?\n  	S = int(line[1])\n  	p = int(line[2])\n  	ts = map(int, line[3:])\n  	for t in ts:\n  		if reduce(max, map(max, regular[t])) >= p:\n  			both += 1\n  		elif surprising[t] != [] and reduce(max, map(max, surprising[t])) >= p:\n  			surp_only += 1\n  \n  	print "Case #%s: %s" % (i + 1, both + min(surp_only, S))\n <CODESPLIT> 5
T = int(raw_input().strip())\n  misses = set()\n  \n  for i in xrange(T):\n  	R, C, M = map(int, raw_input().strip().split(' '))\n  	F = R * C - M\n  	impossible = False\n  	if F == 1:\n  		matrix = ["c" + "*" * (C - 1)]\n  		for _ in xrange(R - 1):\n  			matrix.append("*" * C)\n  	elif R == 1:\n  		matrix = ["c" + "." * (F - 1) + "*" * (C - F)]\n  	elif C == 1:\n  		matrix = ["c"]\n  		for _ in xrange(F - 1):\n  			matrix.append(".")\n  		for _ in xrange(R - F):\n  			matrix.append("*")\n  	elif R == 2:\n  		if F % 2 == 0 and (C > 1 and F != 2 or C == 1 and F <= 2):\n  			matrix = [\n  				"c" + "." * (F / 2 - 1) + "*" * (C - F / 2),	\n  				"." * (F / 2) + "*" * (C - F / 2)\n  			]\n  		else:\n  			matrix = []\n  			impossible = True\n  	else:\n  		stack = []\n  		matrix = []\n  		for j in xrange(C, 1, -1):\n  			if F - 2 * j >= 0 and (R - 2) * j >= F - 2 * j:\n  				stack.append([j, j])\n  \n  		while stack:\n  			elems = stack.pop()\n  			se = sum(elems)\n  			if se == F:\n  				for count in elems:\n  					matrix.append("." * count + "*" * (C - count))\n  				for _ in xrange(R - len(elems)):\n  					matrix.append("*" * C)\n  				matrix[0] = "c" + matrix[0][1:]\n  				break\n  			elif len(elems) < R:\n  				for j in xrange(elems[-1], 1, -1):\n  					if F - se - j >= 0 and (R - len(elems)) * j >= F - se:\n  						stack.append(elems[::] + [j])\n  \n  		if matrix == []:\n  			impossible =True\n  \n  	print "Case #%s:" % (i + 1)\n  	if impossible:\n  		print "Impossible"\n  	else:\n  		for row in matrix:\n  			print row\n <CODESPLIT> 5
 \n  \n  if __name__ == "__main__":\n      T = int(sys.stdin.readline().strip())\n      for i in xrange(T):\n          values = map(int, sys.stdin.readline().strip().split(' '))\n          _N, S, p = values[0:3]\n          t = values[3:]\n          min_normal = p + 2 * max(0, p - 1)\n          min_surprising = p + 2 * max(0, p - 2)\n          cnt_normal = len(filter(lambda x : x >= min_normal, t))\n          cnt_surprising = len(filter(lambda x : x >= min_surprising, t)) - cnt_normal\n          print "Case #%d: %s" % (i + 1, cnt_normal + min(cnt_surprising, S))\n <CODESPLIT> 6
 \n  \n  DX = (-1, -1, -1, 0, 1, 1, 1, 0)\n  DY = (-1, 0, 1, 1, 1, 0, -1, -1)\n  \n  \n  def compute(R, C, M):\n      if M == 0:\n          return empty(R, C)\n      free = R * C - M\n      if free == 1:\n          return single_free(R, C)\n      if R == 1:\n          return single_row(C, M)\n      if C == 1:\n          return single_column(R, M)\n      if R == 2:\n          return two_rows(C, M)\n      if C == 2:\n          return two_columns(R, M)\n      if free in (2,3,5,7):\n          return "\nImpossible"\n      return at_least_three(R, C, M)\n  \n  \n  def make_board(R, C, default='.'):\n      return [[default for j in xrange(C)] for i in xrange(R)]\n  \n  \n  def to_string(board):\n      s = ""\n      for i in xrange(len(board)):\n          s += '\n' + ''.join(board[i])\n      return s\n  \n          \n  def empty(R, C):\n      board = make_board(R, C)\n      board[0][0] = 'c'\n      return to_string(board)\n  \n  \n  def single_free(R, C):\n      board = make_board(R, C, default='*')\n      board[0][0] = 'c'\n      return to_string(board)\n  \n  \n  def single_row(C, M):\n      board = make_board(1, C)\n      board[0][0] = 'c'\n      for i in xrange(M):\n          board[0][C - 1 - i] = '*'\n      return to_string(board)\n  \n  \n  def single_column(R, M):\n      board = make_board(R, 1)\n      board[0][0] = 'c'\n      for i in xrange(M):\n          board[R - 1 - i][0] = '*'\n      return to_string(board)\n  \n  \n  def two_rows(C, M):\n      if M % 2 != 0:\n          return "\nImpossible"\n      if 2 * C - M < 4:\n          return "\nImpossible"\n      board = make_board(2, C)\n      for i in xrange(M / 2):\n          board[0][C - 1 - i] = '*'\n          board[1][C - 1 - i] = '*'\n      board[0][0] = 'c'\n      return to_string(board)\n  \n  \n  def two_columns(R, M):\n      if M % 2 != 0:\n          return "\nImpossible"\n      if 2 * R - M < 4:\n          return "\nImpossible"\n      board = make_board(R, 2)\n      for i in xrange(M / 2):\n          board[R - 1 - i][0] = '*'\n          board[R - 1 - i][1] = '*'\n      board[0][0] = 'c'\n      return to_string(board)\n  \n  \n  def finalize(R, C, M, board):\n      mines = 0\n      for i in xrange(R):\n          for j in xrange(C):\n              if board[i][j] == '0':\n                  continue\n              empty = False\n              for d in xrange(8):\n                  if i + DX[d] < 0 or i + DX[d] >= R or j + DY[d] < 0 or j + DY[d] >= C:\n                      continue\n                  if board[i + DX[d]][j + DY[d]] == '0':\n                      empty = True\n                      break\n              if empty:\n                  board[i][j] = '.'\n              else:\n                  board[i][j] = '*'\n                  mines += 1\n      for i in xrange(R):\n          for j in xrange(C):\n              if board[i][j] == '0':\n                  board[i][j] = '.'\n      board[0][0] = 'c'\n      if mines != M:\n          sys.stderr.write("mines:%s expected:%s\n" % (mines, M))\n      return to_string(board)\n  \n  \n  def at_least_three(R, C, M):\n      board = make_board(R, C)\n      board[0][0] = '0'\n      free = R * C - M\n      count = 4\n      if count == free:\n          return finalize(R, C, M, board)\n      board[0][1] = '0'\n      count += 2\n      if count == free:\n          return finalize(R, C, M, board)\n      board[1][0] = '0'\n      count += 2\n      if count == free:\n          return finalize(R, C, M, board)\n      for j in xrange(2, C - 1):\n          if count + 2 > free:\n              break\n          board[0][j] = '0'\n          count += 2\n      for i in xrange(2, R - 1):\n          if count + 2 > free:\n              break\n          board[i][0] = '0'\n          count += 2\n      for i in xrange(1, R - 1):\n          for j in xrange(1, C - 1):\n              if count == free:\n                  return finalize(R, C, M, board)\n              board[i][j] = '0'\n              count += 1\n      sys.stderr.write("empty board?\n")\n      return finalize(board)\n  \n  \n  def parse():\n      R, C, M = map(int, sys.stdin.readline().strip().split())\n      return R, C, M\n  \n  \n  if __name__ == "__main__":\n      sys.setrecursionlimit(100000)\n      T = int(sys.stdin.readline().strip())\n      for i in xrange(T):\n          sys.stderr.write("case:%s\n" % (i + 1))\n          data = parse()\n          result = compute(*data)\n          print "Case #%d: %s" % (i + 1, result)\n <CODESPLIT> 6
data_dict = {}\n  init = False\n  \n  \n  def partB(infile="C:/Users/Jeffrey/Dropbox/Google Code Jam/2011/Qualifiers/B/input3.txt",\\n                outfile="C:/Users/Jeffrey/Dropbox/Google Code Jam/2011/Qualifiers/B/output.txt"):\n      \n      linesA = []\n      for line in open(infile, 'r'):\n          linesA.append(line.strip())\n  \n      outA = []\n          \n      T = int(linesA[0])\n      for i in range(1, 1 + T):\n          caseA = linesA[i].split()\n          N = int(caseA[0])\n          S = int(caseA[1])\n          P = int(caseA[2])\n          \n          over_norm = 0\n          over_supr = 0\n          \n          for t in [int(conv) for conv in caseA[3:3+N]]:\n              if data_dict[t][0] >= P:\n                  over_norm += 1\n              elif data_dict[t][1] >= P:\n                  over_supr += 1\n          \n          outA.append(over_norm + min(over_supr, S))\n              \n              \n          \n      \n      out = open(outfile, 'w')\n      print "\nOUTPUT"\n      for i in range(1, 1 + T):\n          if i != 1:\n              out.write("\n")\n          print "Case #" + str(i) + ": " +str(outA[i-1])\n          out.write("Case #" + str(i) + ": " +str(outA[i-1]))\n      out.close()\n  \n  def dict_helper(total, depth=0, lowest=10):\n      pass\n  \n  def build_dict():\n      for i in range(31):\n          fullA = []\n          maxN = 0\n          maxS = 0\n          print str(i) + ": "\n          for a1 in range(0,11):\n              for a2 in range(0,11):\n                  for a3 in range(0,11):\n                      if (a1 + a2 + a3 == i) and (max(a1,a2,a3)-min(a1,a2,a3) <3):\n                          fullA.append((a1,a2,a3))\n                          \n                          print "\t", fullA[-1],\n                          if max(a1,a2,a3)-min(a1,a2,a3) == 2:\n                              print "*"\n                              maxS = max(maxN, max(a1,a2,a3))\n                          else:\n                              print\n                              maxN = max(maxN, max(a1,a2,a3))\n          data_dict[i]=[maxN, maxS]\n      init = True\n      \n  if __name__ == "__main__":\n      build_dict()\n      partB()\n <CODESPLIT> 7
__author__ = 'Jeffrey'\n  \n  inFileName = "C:\\Users\\Jeffrey\\IdeaProjects\\Google Code Jam 2014\\C-small-attempt0.in"\n  \n  outFileName = inFileName[: -2] + "out"\n  \n  \n  def parseInput(f):\n      T = int(f.readline())\n      L = []\n  \n      for i in range(T):\n          L.append([int(i) for i in f.readline().split()])\n  \n      return T, L\n  \n  \n  def calculateOneClick(R, C, M):\n      size = R * C\n      if R == 1 or C == 1 and M < size:\n          return generateWinBoardBaseCase(R, C, M)\n      elif size - M == 1:\n          return generateWinBoardBaseCase(R, C, M)\n      elif size - M >= 4:\n          return generateWinBoard(R, C, M)\n      return "Impossible"\n  \n  def generateWinBoard(R,C,M):\n      emptySpace = R * C - M - 4\n      out = "c"\n      if C > 1:\n          out += "."\n          for i in range(2,C):\n              if emptySpace > 0:\n                  out += "."\n                  emptySpace -= 1\n              else:\n                  out += "*"\n      if R > 1:\n          out += '\n'\n          out += "."\n          if C > 1:\n              out += "."\n          for i in range(2,C):\n              if emptySpace > 0:\n                  out += "."\n                  emptySpace -= 1\n              else:\n                  out += "*"\n      for r in range(2,R):\n          out += '\n'\n          for c in range(C):\n              if emptySpace > 0:\n                  out += "."\n                  emptySpace -= 1\n              else:\n                  out += "*"\n      return out\n  \n  def generateWinBoardBaseCase(R,C,M):\n      emptySpace = R * C - M - 1\n      out = "c"\n      if C > 1:\n          for c in range(1,C):\n              if emptySpace > 0:\n                  out += "."\n                  emptySpace -= 1\n              else:\n                  out += "*"\n      for r in range(1,R):\n          out += '\n'\n          for c in range(C):\n              if emptySpace > 0:\n                  out += "."\n                  emptySpace -= 1\n              else:\n                  out += "*"\n      return out\n  \n  \n  def playGame(T, L):\n      for i in range(T):\n          result = calculateOneClick(L[i][0], L[i][1], L[i][2])\n          yield "Case #" + str(i + 1) + ":\n" + str(result)\n  \n  \n  if __name__ == "__main__":\n      iF = open(inFileName, 'r')\n      T, L = parseInput(iF)\n      iF.close()\n  \n      print(T)\n      print(L)\n  \n      oF = open(outFileName, "wb")\n      for out in playGame(T, L):\n          print(out)\n          oF.write(bytes(out + "\n", 'utf-8'))\n      oF.close()\n <CODESPLIT> 7
 \n  \n  \n  def solve(num_surprises, p, ts):\n      s = 0\n      u = 0\n      for t in ts:\n          a = int(t/3)\n          r = t % 3\n          if a+1 >= p and not r == 0:\n              u += 1\n          elif a >= p and r == 0:\n              u += 1\n          elif a > 0 and a+1 >= p and r == 0:\n              s += 1\n          elif a+2 >= p and r == 2:\n              s += 1\n  \n      return min(num_surprises, s) + u\n          \n          \n  \n  def main():\n      N = int(sys.stdin.readline()) # number of testcases\n      for i in range(N):\n          line = [int(x) for x in sys.stdin.readline().split()]\n          num_surprises = line[1]\n          p = line[2]\n          ts = line[3:]\n          result = solve(num_surprises, p, ts)\n          print ("Case #%s: %s" % (i+1, result))\n  \n  \n  if __name__ == '__main__':\n      main()\n <CODESPLIT> 8
 \n  \n  def neighbours(grid, (i, j), n, m):\n      for a in range(max(i-1, 0), min(i+2, n)):\n          for b in range(max(j-1, 0), min(j+2, m)):\n              if (a != i or b != j):\n                  yield (a, b)\n  \n  def isGridCorrect(grid):\n      g = list(grid)\n      n = len(g)\n      m = len(g[0])\n      queue = [(0, 0)]\n  \n      while queue:\n          v = queue.pop(0)\n          g[v[0]][v[1]] = 'r'\n          bomb = False\n          for (i, j) in neighbours(g, v, n, m):\n              if g[i][j] == '*':\n                  bomb = True\n          if not bomb:\n              for (i, j) in neighbours(g, v, n, m):\n                  if g[i][j] != 'r':\n                      queue.append((i, j))\n  \n      for i in range(n):\n          for j in range(m):\n              if g[i][j] != 'r' and g[i][j] != '*':\n                  return 'WRONG'\n  \n      return 'Right'\n  \n  def createGrid(R, C, s):\n      field = []\n      for i in range(R):\n          field.append([s] * C)\n      field[0][0] = 'c'\n      return field\n  \n  def draw(grid):\n      s = ""\n      for row in grid:\n          s += "\n" + ''.join(row)\n      return s\n  \n  def reduceRows(grid, k, l, M):\n      if k <= 2:\n          return (grid, k, l, M)\n      \n  \n      for j in range(l):\n          grid[k-1][j] = '*'\n      k -= 1\n      M -= l\n      return (grid, k, l, M)\n  \n  def reduceCols(grid, k, l, M):\n      if l <= 2:\n          return (grid, k, l, M)\n      \n  \n      for i in range(k):\n          grid[i][l-1] = '*'\n      l -= 1\n      M -= k\n      return (grid, k, l, M)\n  \n  def solve(R, C, M):\n      mp = M\n      if M == 0:\n          f = createGrid(R, C, '.')\n          return draw(f)\n      elif M == R*C - 1:\n          f = createGrid(R, C, '*')\n          return draw(f)\n      elif (R == 2 or C == 2) and (M % 2 == 1 or M == R*C - 2):\n          return "\n" + 'Impossible' #+ '1: ' + str(R) + ' ' + str(C) + ' ' + str(mp)\n      elif R > 2 and C > 2 and (M == R*C - 2 or M == R*C - 3 or M == R*C - 5 or M == R*C - 7):\n          return "\n" + 'Impossible' #+ '2: ' + str(R) + ' ' + str(C) + ' ' + str(mp)\n      else:\n          grid = createGrid(R, C, '.')\n  \n  \n          k = R\n          l = C\n  \n          while (M >= l and k > 2) or (M >= k and l > 2):\n              if l >= k:\n                  (grid, k, l, M) = reduceCols(grid, k, l, M)\n              elif k > l:\n                  (grid, k, l, M) = reduceRows(grid, k, l, M)\n  \n  \n          if M == 0:\n              return draw(grid)\n          if M < l - 1 and k > 2:\n              for j in range(l - M, l):\n                  grid[k-1][j] = '*'\n          elif M < k - 1 and l > 2:\n              for i in range(k - M, k):\n                  grid[i][l-1] = '*'\n          elif l > 3 and k > 3:\n              for i in range(2, k):\n                  grid[i][l-1] = '*'\n              M -= k - 2\n              for j in range(l - M - 1, l - 1):\n                  grid[k-1][j] = '*'\n          else:\n              return "\n" + 'Impossible' #+ '3: ' + str(R) + ' ' + str(C) + ' ' + str(mp)\n  \n          return draw(grid)\n  \n  def main():\n      N = int(sys.stdin.readline()) # number of testcases\n      for i in range(N):\n          [R, C, M] = [int(x) for x in sys.stdin.readline().rstrip().split()]\n  \n          result = solve(R, C, M)\n          print ("Case #%s:%s" % (i+1, result))\n  \n  if __name__ == '__main__':\n      main()\n <CODESPLIT> 8
f = open('cj2.in','r')\n  out = open('out1.txt','w')\n  inp = [[int(n) for n in s.split()] for s in f.readlines()]\n  \n  def score_partition(score):\n      poss = []\n      if score == 0:\n          return [[0,0,0]]\n      if score == 1:\n          return [[0,0,1]]\n      if score % 3 == 0:\n          poss.append([score/3,score/3,score/3])\n          poss.append([score/3-1,score/3,score/3+1])\n      if score % 3 == 1:\n          poss.append([score/3, score/3,score/3+1])\n          poss.append([score/3-1,score/3+1,score/3+1])\n      if score % 3 == 2:\n          poss.append([score/3,score/3+1,score/3+1])\n          poss.append([score/3,score/3,score/3+2])\n  \n      return poss\n  \n  \n  s = 0\n  c = 1\n  for e in inp[1:len(inp)]:\n      count = 0\n      surprises = e[1]\n      s = 0\n      p = e[2]\n      for i in e[3:len(e)]:\n          scores = score_partition(i)\n          for j in scores: \n              if max(j) >= p:\n                  if max(j)-min(j) == 2:\n                      if s < surprises:\n                          s +=1\n                          count +=1\n                          break\n                  else:\n                      count += 1\n                      break\n                  \n      out.write('Case #'+str(c)+': '+str(count)+'\n')\n      c += 1\n  \n  out.close()\n  f.close()\n                  \n          \n      \n      \n  \n      \n <CODESPLIT> 9
def make_string(R, C, M):\n      grid = [['.' for j in xrange(C)] for i in xrange(R)]\n      grid[-1][-1] = 'c'\n      t = M\n      for i in xrange(R):\n          for j in xrange(C):\n              if M:\n                  if forbidden(R, C, t, i, j):\n                      continue\n                  grid[i][j] = '*'\n                  M -= 1\n              else:\n                  break\n      s = ''\n      if M:\n          return 'Impossible'\n      for r in grid:\n          s += ''.join(r)+'\n'\n      return s[:-1]\n  \n  def forbidden(R, C, M, i, j):\n      a = M / C\n      b = M % C\n      if (R*C - M == 1):\n          return False\n  \n      if i >= (R-2) and j >= (C-2):\n          return True\n  \n      if i >= (R-2) and b:\n          if b % 2:\n              return True\n          if j < b/2:\n              return False\n          else:\n              return True\n      return False\n          \n  \n  f = open('Csmall.in', 'r')\n  g = open('outputC.txt', 'w')\n  \n  data = [[int(e) for e in line.strip("\n").split(' ')] for line in f]\n  T = int(data.pop(0)[0])\n  for i, case in enumerate(data):\n      R, C, M = case[0], case[1], case[2]\n      num_cells = R*C\n      if (R-1) == 0 or (C-1) == 0:\n          s = make_string(R, C, M)\n          g.write('Case #%i:\n%s\n' %(i+1,s))\n          continue\n      else:\n          s = make_string(R, C, M)\n          g.write('Case #%i:\n%s\n' %(i+1, s))\n          \n  \n  f.close()\n  g.close()\n <CODESPLIT> 9
T = int(raw_input())\n  for t in xrange(T):\n      line = map(int, raw_input().split())\n      N, S, p = line[0:3]\n      a = line[3:]\n      cnt = 0\n      a.sort(reverse=True)\n      for x in a:\n          if (x + 2) / 3 >= p:\n              cnt += 1\n          elif S > 0 and 2 <= x <= 28 and (x + 4) / 3 >= p:\n              cnt += 1\n              S -= 1\n          else:\n              break\n      print "Case #%d: %d" % (t + 1, cnt)\n <CODESPLIT> 10
 def solve():\n      h, w, m = map(int, raw_input().split())\n      if h == 1:\n          print 'c' + '.' * (h * w - m - 1) + '*' * m\n      elif w == 1:\n          for c in 'c' + '.' * (h * w - m - 1) + '*' * m:\n              print c\n      elif h * w - m == 1:\n          print 'c' + '*' * (w - 1)\n          for _ in xrange(h-1):\n              print '*' * w\n      else:\n          m = h * w - m\n          for i in xrange(h-1):\n              for j in xrange(w-1):\n                  t = (i + 2) * 2 + (j + 2) * 2 - 4\n                  r = (i + 2) * (j + 2)\n                  if t <= m <= r:\n                      a = [['*'] * w for _ in xrange(h)]\n                      for k in xrange(i+2):\n                          a[k][0] = '.'\n                          a[k][1] = '.'\n                      for k in xrange(j+2):\n                          a[0][k] = '.'\n                          a[1][k] = '.'\n                      for y, x in product(range(2, i+2), range(2, j+2)):\n                          if y == 1 and x == 1:\n                              continue\n                          if t >= m:\n                              break\n                          a[y][x] = '.'\n                          t += 1\n                      a[0][0] = 'c'\n                      for s in a:\n                          print ''.join(s)\n                      return\n          print 'Impossible'\n  for t in xrange(int(raw_input())):\n      print "Case #%d:" % (t + 1)\n      solve()\n <CODESPLIT> 10
 \n  T = int(stdin.readline())\n  for i in xrange(1,T+1):\n  	ns = map(int, stdin.readline().split())\n  	N,S,p = ns[0:3]\n  	\n  	h = 0\n  	z = 0\n  \n  	for n in ns[3:]:\n  		if n <= 1:\n  			if n >= p: h += 1	\n  		elif (n+2) // 3 >= p:\n  			h += 1\n  		elif (n+4) // 3 >= p:\n  			z += 1\n  \n  	print "Case #%d: %d" % (i, h + min(S,z))\n  \n  \n <CODESPLIT> 11
 \n  lines = [line.strip() for line in open(sys.argv[1])]\n  count = int(lines[0])\n  \n  for i in xrange(count):\n      R,C,M = map(int, lines[i+1].split())\n      print "Case #%s:" % (i+1)\n  \n      w = max(R,C)\n      h = min(R,C)\n      X = R*C - M\n      assert X > 0\n  \n      if X == 1:\n          rows = ['c' + ('*' * (w-1))] + (h-1) * ['*' * w]\n      elif h == 1:\n          rows = ['c' + '.' * (X-1) + '*' * M]\n      elif X == 4:\n              rows = [\n                  'c.' + '*' * (w-2),\n                  '..' + '*' * (w-2),\n              ] + ['*' * w] * (h-2)\n      elif h == 2:\n          if X%2 == 1 or X == 2:\n              rows = None\n          else:\n              rows = [\n                  'c' + '.' * (X/2-1) + '*' * (M/2),\n                  '.' + '.' * (X/2-1) + '*' * (M/2)\n              ]\n      elif X <= 5 or X == 7:\n          rows = None\n  \n      elif X%2 == 0 and X <= w*2:\n          r = X/2\n          rows = [\n              'c' + '.' * (r - 1) + '*' * (w-r),\n                    '.' * r       + '*' * (w-r),\n          ] + ['*' * w] * (h-2)\n  \n      elif X <= w*3 and (X % 3) != 1:\n          n = (X+1) / 3\n          t = X - 2*n\n          rows = [\n              'c' + '.' * (n-1) + '*' * (w-n),\n                    '.' * n     + '*' * (w-n),\n                    '.' * t     + '*' * (w-t)\n          ] + ['*' * w] * (h-3)\n      else:\n          n = X / w\n          t = X % w\n          if t == 1:\n              rows = (\n                      ['c' + (w-1) * '.']\n                  +   ['.' * w] * (n-2)\n                  +   ['.' * (w-1) + '*']\n                  +   ['..' + '*' * (w-2)]\n                  +   ['*' * w] * (h - n - 1)\n              )\n          else:\n              k = 1 if t == 0 else 0\n              rows = (\n                      ['c' + (w-1) * '.']\n                  +   ['.' * w] * (n-1)\n                  +   ['.' * t + '*' * (w-t)] * (1 - k)\n                  +   ['*' * w] * (h - n - 1 + k)\n              )\n  \n      if rows:\n          if R > C:\n              rows = ["".join(row[i] for row in rows) for i in xrange(R)]\n  \n          for row in rows:\n              print row\n  \n          assert len(rows) == R\n          assert len(rows[0]) == C\n          assert sum(1 for row in rows for col in row if col == '*') == M\n  \n      else:\n          print "Impossible"\n  \n <CODESPLIT> 11
 \n  class Triplet(object):\n  	def __init__(self, i, j, k):\n  		self.i = i\n  		self.j = j\n  		self.k = k\n  		self.max_diff = max((abs(i - j), abs(i - k), abs(j - k)))\n  		self.valid = self.max_diff <= 2\n  		self.surprise = self.max_diff == 2\n  	\n  	def get_tuple(self):\n  		return (self.i, self.j, self.k)\n  	\n  	def get_redundancies(self):\n  		return [(self.i, self.j, self.k),\n  				(self.i, self.k, self.j),\n  				(self.j, self.i, self.k),\n  				(self.j, self.k, self.i),\n  				(self.k, self.i, self.j),\n  				(self.k, self.j, self.i)]\n  \n  class Googler(object):\n  	def __init__(self, total_points):\n  		self.total_points = total_points\n  		self.regular_triplets = []\n  		self.surprise_triplets = []\n  		\n  		for i in xrange(0, 11):\n  			if i > total_points:\n  				break\n  			for j in xrange(i, 11):\n  				if i + j > total_points:\n  					break\n  				k = total_points - i - j\n  				if k > 10:\n  					break\n  				triplet = Triplet(i, j, k)\n  				self.add(triplet)\n  		\n  		self.can_surprise = len(self.surprise_triplets) > 0\n  		self.actual_triplet = None\n  		self.best_result = -1\n  		\n  	def add(self, triplet):\n  		if not triplet.valid:\n  			return\n  		if triplet.surprise:\n  			self.add_uniquely(triplet, is_surprise=True)\n  		else:\n  			self.add_uniquely(triplet, is_surprise=False)\n  			\n  	def add_uniquely(self, triplet, is_surprise):\n  		if is_surprise:\n  			input_list = self.surprise_triplets\n  		else:\n  			input_list = self.regular_triplets\n  		for triplet_redundancy in triplet.get_redundancies():\n  			if triplet_redundancy in input_list:\n  				return\n  		input_list.append(triplet.get_tuple())\n  	\n  	def __str__(self):\n  		return "regular: %s\nsurprise: %s" % (self.regular_triplets,\n  											  self.surprise_triplets)\n  	\n  	def set_googler(self, is_surprise=False):\n  		if not is_surprise:\n  			self.actual_triplet = self.regular_triplets[0]\n  		else:\n  			self.actual_triplet = self.surprise_triplets[0]\n  		self.calc_best_result()\n  	\n  	def calc_best_result(self):\n  		self.best_result = max(self.actual_triplet)\n  \n  		\n  class Contest(object):\n  	def __init__(self, num_of_googlers, results):\n  		self.num = num_of_googlers\n  		self.googlers = []\n  		for i in xrange(self.num):\n  			self.googlers.append(Googler(results[i]))\n  	\n  	def calc(self, num_of_surprises, p):\n  		max_googlers_over_p = 0\n  		for surprise_perm in self.get_permutations(num_of_surprises):\n  			if not self.validate_permutation(surprise_perm):\n  				continue\n  			count = 0\n  			for index, googler in enumerate(self.googlers):\n  				googler.set_googler(index in surprise_perm)\n  				if googler.best_result >= p:\n  					count += 1\n  			if count >= max_googlers_over_p:\n  				max_googlers_over_p = count\n  		return max_googlers_over_p\n  	\n  	def get_permutations(self, num_of_surprises):\n  		results = get_perms(0, self.num, num_of_surprises)\n  		if not results:\n  			return [[]]\n  		return results\n  	\n  	def validate_permutation(self, perm):\n  		for googler_index in perm:\n  			if not self.googlers[googler_index].can_surprise:\n  				return False\n  		return True\n  \n  def get_perms(start_index, finish_index, amount):\n  	if amount == 0:\n  		return []\n  	result_list = []\n  	for i in xrange(start_index, finish_index):\n  		if amount == 1:\n  			result_list.append([i])\n  			continue\n  		for result in get_perms(i + 1, finish_index, amount - 1):\n  			new_result = [i]\n  			new_result.extend(result)\n  			result_list.append(new_result)\n  	return result_list\n  		\n  def main(filepath):\n  	with file('dancing_output.txt', 'wb') as f_out:\n  		with file(filepath, 'rb') as f_in:\n  			for line_index, line in enumerate(f_in):\n  				if line_index == 0: #T\n  					continue\n  				input_list = line.strip().split(' ')\n  				num_of_googlers = int(input_list[0])\n  				num_of_surprises = int(input_list[1])\n  				p = int(input_list[2])\n  				results = []\n  				for res in input_list[3:]:\n  					results.append(int(res))\n  				contest = Contest(num_of_googlers, results)\n  				result = contest.calc(num_of_surprises, p)\n  				\n  				print\n  				print line.strip()\n  				print result\n  				\n  				f_out.write("Case #%d: %d\n" % (line_index, result))\n  				\n  if __name__ == '__main__':\n  	main(sys.argv[1])\n <CODESPLIT> 12
 \n  def iterate_cases_1lpc(filepath):	#1lpc = 1 line per case\n  	with file(filepath, 'rb') as f_in:\n  		for line_index, line in enumerate(f_in):\n  			if line_index == 0: #T\n  				continue\n  			yield line_index, line.strip().split(' ')\n  \n  def iterate_cases_nlpc(filepath, n):	#1lpc = n line per case\n  	with file(filepath, 'rb') as f_in:\n  		case_counter = 1\n  		case = []\n  		for line_index, line in enumerate(f_in):\n  			if line_index == 0: #T\n  				continue\n  			case.append(line.strip().split(' '))\n  			if not line_index % n:\n  				yield case_counter, case\n  				case_counter += 1\n  				case = []\n  \n  def iterate_cases_glpc(filepath):		#glpc - given lines per case\n  	with file(filepath, 'rb') as f_in:\n  		case_counter = 0\n  		new_case = True\n  		for line_index, line in enumerate(f_in):\n  			if line_index == 0: #T\n  				continue\n  			if new_case:\n  				new_case = False\n  				case_counter += 1\n  				case = []\n  				assert len(line.strip().split(' ')) == 1\n  				lines_left = int(line.strip())\n  				if not lines_left:\n  					new_case = True\n  					yield case_counter, case\n  				continue\n  			if lines_left:\n  				lines_left -= 1\n  				case.append(line.strip().split(' '))\n  			if not lines_left:\n  				new_case = True\n  				yield case_counter, case\n  			\n  def part_of_list_to_int(array, flags):\n  	assert len(array) == len(flags)\n  	output = []\n  	for index, elem in enumerate(array):\n  		if flags[index]:\n  			output.append(int(elem))\n  		else:\n  			output.append(elem)\n  	return output\n  \n  def list_to_int(array):\n  	return part_of_list_to_int(array, [True] * len(array))\n  \n  def part_of_list_to_float(array, flags):\n  	assert len(array) == len(flags)\n  	output = []\n  	for index, elem in enumerate(array):\n  		if flags[index]:\n  			output.append(float(elem))\n  		else:\n  			output.append(elem)\n  	return output\n  \n  def list_to_float(array):\n  	return part_of_list_to_float(array, [True] * len(array))\n  \n  def get_max_array_on_index(array, index):\n  	elem_len = len(array[0])\n  	assert index < elem_len\n  	for elem in array:\n  		assert elem_len == len(elem)\n  	max_sub = array[0][index]\n  	max_elem = array[0]\n  	for elem in array:\n  		if elem[index] > max_sub:\n  			max_sub = elem[index]\n  			max_elem = elem\n  	return max_elem\n  \n  def list_index_in_sorted_with_position(a_list, value, pos):\n  	list_len = len(a_list)\n  	if list_len == 1:\n  		if a_list[0] == value:\n  			return pos\n  		return -1\n  	if a_list[list_len/2] > value:\n  		return list_index_in_sorted_with_position(a_list[:(list_len/2)], value, pos)\n  	else:\n  		return list_index_in_sorted_with_position(a_list[(list_len/2):], value, pos + (list_len/2))\n  	\n  def list_index_in_sorted_list(a_list, value):\n  	return list_index_in_sorted_with_position(a_list, value, 0)\n  \n  def copy_list(list):\n  	res = []\n  	for elem in list:\n  		res.append(elem)\n  	return res	\n  \n  \n  def conj_mat(a):\n  	R = len(a)\n  	C = len(a[0])\n  	res = [['.' for _ in xrange(R)] for __ in xrange(C)]\n  	for i in xrange(R):\n  		for j in xrange(C):\n  			res[j][i] = a[i][j]\n  	return res\n  \n  def one_line_builder(R, C, M):\n  	res = []\n  	res.extend(['*'] * M)\n  	res.extend(['.'] * (C - M))\n  	res[-1] = 'c'\n  	return [res]\n  	\n  def two_line_builder(R, C, M):\n  	line = []\n  	line.extend(['*'] * (M / 2))\n  	line.extend(['.'] * (C - M / 2))\n  	res = [line, copy_list(line)]\n  	res[1][-1] = 'c'\n  	if M%2 == 1:\n  		res[0][-1] = '*'\n  	return res\n  	\n  def three_line_builder(R, C, M):\n  	res = [['.' for _ in xrange(C)] for __ in xrange(R)]\n  	res[-1][-1] = 'c'\n  	m = min([M, R * C - 9])\n  	stop_flag = False\n  	for j in xrange(C):\n  		if stop_flag:\n  			break\n  		for i in xrange(R):\n  			if m == 0:\n  				stop_flag = True\n  				break\n  			res[i][j] = '*'\n  			m -= 1\n  	print i,j\n  	if i == 2:\n  		res[1][j-1] = '.'\n  		if j == C - 3:\n  			res[0][j] = '*'\n  		else:\n  			res[0][-1] = '*'\n  	\n  	if M <= R * C - 9:\n  		return res\n  	else:\n  		m = M - (R * C - 9)\n  		assert m not in [2, 4, 6, 7, 9]\n  		assert m > 0\n  		assert m < 10\n  		\n  		res[-3][-3] = '*'\n  		m -= 1\n  		if m == 0: return res\n  		res[-2][-3] = '*'\n  		res[-1][-3] = '*'\n  		m -= 2\n  		if m == 0: return res\n  		res[-3][-2] = '*'\n  		res[-3][-1] = '*'\n  		m -= 2\n  		if m == 0: return res\n  		res[-2][-2] = '*'\n  		res[-2][-1] = '*'\n  		res[-1][-2] = '*'\n  		m -= 3\n  		if m == 0: return res\n  		assert False\n  	\n  	\n  	\n  def over_three_line_builder(R, C, M):\n  	if M <= (R - 3) * C:\n  		res = [['*' for _ in xrange(C)] for __ in xrange(M / C)]\n  		flag = False\n  		if (M % C) != (C - 1):\n  			line = ['*' for _ in xrange(M % C)]\n  			line.extend(['.' for _ in xrange(C - (M % C))])\n  		else:\n  			line = ['*' for _ in xrange((M % C) - 1)]\n  			line.extend(['.' for _ in xrange((C - (M % C)) + 1)])\n  			flag = True\n  		res.append(line)\n  		index = len(res)\n  		res.extend([['.' for _ in xrange(C)] for __ in xrange(R - len(res))])\n  		if flag:\n  			res[index][0] = '*'\n  		res[-1][-1] = 'c'\n  		assert len(res) == R\n  		assert len(res[0]) == C\n  		return res\n  	else:\n  		res = [['*' for _ in xrange(C)] for __ in xrange(R - 3)]\n  		M -= (R - 3) * C\n  		tmp = three_line_builder(3, C, M)\n  		if len(tmp) != 3: # error msg\n  			return tmp\n  		res.extend(tmp)\n  		return res\n  	\n  def solve(R, C, M):\n  	res = None\n  	\n  	if M == R * C:\n  		return 'Impossible'\n  	if R >= 3 and C >= 3:\n  		if R*C - M in [7, 5, 3, 2]:\n  			return 'Impossible'\n  		return over_three_line_builder(R, C, M)\n  		\n  	elif R != 1 and C != 1:  #which means one of them is 2, and the other not 1\n  		if (R*C - M) % 2 == 1:\n  			if M < R*C - 1:\n  				return 'Impossible'\n  		if M + 2 == R * C:\n  			return 'Impossible'\n  		else:\n  			if R == 2:\n  				return two_line_builder(R, C, M)\n  			else:\n  				tmp = two_line_builder(C, R, M)\n  				return conj_mat(tmp)\n  	\n  	else:					#which means one of them is 1\n  		if R == 1:\n  			return one_line_builder(R, C, M)\n  		else:\n  			tmp = one_line_builder(C, R, M)\n  			return conj_mat(tmp)\n  		\n  	return res\n  \n  def mat_to_str(a):\n  	if a in ['Impossible', 'Not Implemented']:\n  		return a\n  	str_out = ''\n  	for row in a:\n  		for elem in row:\n  			str_out += elem\n  		str_out += '\n'\n  	return str_out[:-1]\n  	\n  def calc_result(case):\n  	result = None\n  	\n  	R = int(case[0])\n  	C = int(case[1])\n  	M = int(case[2])\n  	print R, C, M\n  	\n  	result = solve(R, C, M)\n  	\n  	str_out = mat_to_str(result)\n  	m = str_out.count('*')\n  	assert (m==0 or m==M)\n  	print str_out\n  	\n  	return '\n%s' % str_out\n  \n  def main(filepath):\n  	start_time = time.time()\n  	with file('output.txt', 'wb') as f_out:\n  		\n  		for case_index, case in iterate_cases_1lpc(filepath):\n  			\n  			print "case #%d: time:%.02f" % (case_index, time.time() - start_time)\n  			result = calc_result(case)\n  			\n  			f_out.write("Case #%d: %s\n" % (case_index, result))\n  				\n  if __name__ == '__main__':\n  	main(sys.argv[1])\n <CODESPLIT> 12
 \n  T = int(raw_input())\n  for i in xrange(T):\n      values = map(int, raw_input().split())\n      [N,s,p] = values[0:3]\n      t = values[3:]\n      answer = 0\n      for note in t:\n          if note < 2:\n              if note >= p:\n                  answer += 1\n          elif note % 3 == 1 and (note-1) / 3 + 1 >= p:\n              answer += 1\n          elif note % 3 == 0:\n              n = note / 3\n              if n >= p:\n                  answer += 1\n              elif s > 0 and n + 1 >= p:\n                  answer += 1\n                  s -= 1\n          elif note % 3 == 2:\n              n = (note - 2) / 3\n              if n + 1 >= p:\n                  answer += 1\n              elif s > 0 and n + 2 >= p:\n                  answer += 1\n                  s -= 1\n      print 'Case #{0}: {1}'.format(i+1, answer)\n <CODESPLIT> 13
CACHE = {(1, 1, 0): ['c'],\n   (1, 2, 0): ['c.'],\n   (1, 2, 1): ['*c'],\n   (1, 3, 0): ['c..'],\n   (1, 3, 1): ['*.c'],\n   (1, 3, 2): ['**c'],\n   (1, 4, 0): ['c...'],\n   (1, 4, 1): ['*.c.'],\n   (1, 4, 2): ['**.c'],\n   (1, 4, 3): ['***c'],\n   (1, 5, 0): ['c....'],\n   (1, 5, 1): ['*.c..'],\n   (1, 5, 2): ['**.c.'],\n   (1, 5, 3): ['***.c'],\n   (1, 5, 4): ['****c'],\n   (2, 1, 0): ['c', '.'],\n   (2, 1, 1): ['*', 'c'],\n   (2, 2, 0): ['c.', '..'],\n   (2, 2, 1): None,\n   (2, 2, 2): None,\n   (2, 2, 3): ['**', '*c'],\n   (2, 3, 0): ['c..', '...'],\n   (2, 3, 1): None,\n   (2, 3, 2): ['*.c', '*..'],\n   (2, 3, 3): None,\n   (2, 3, 4): None,\n   (2, 3, 5): ['***', '**c'],\n   (2, 4, 0): ['c...', '....'],\n   (2, 4, 1): None,\n   (2, 4, 2): ['*.c.', '*...'],\n   (2, 4, 3): None,\n   (2, 4, 4): ['**.c', '**..'],\n   (2, 4, 5): None,\n   (2, 4, 6): None,\n   (2, 4, 7): ['****', '***c'],\n   (2, 5, 0): ['c....', '.....'],\n   (2, 5, 1): None,\n   (2, 5, 2): ['*.c..', '*....'],\n   (2, 5, 3): None,\n   (2, 5, 4): ['**.c.', '**...'],\n   (2, 5, 5): None,\n   (2, 5, 6): ['***.c', '***..'],\n   (2, 5, 7): None,\n   (2, 5, 8): None,\n   (2, 5, 9): ['*****', '****c'],\n   (3, 1, 0): ['c', '.', '.'],\n   (3, 1, 1): ['*', '.', 'c'],\n   (3, 1, 2): ['*', '*', 'c'],\n   (3, 2, 0): ['c.', '..', '..'],\n   (3, 2, 1): None,\n   (3, 2, 2): ['**', '..', 'c.'],\n   (3, 2, 3): None,\n   (3, 2, 4): None,\n   (3, 2, 5): ['**', '**', '*c'],\n   (3, 3, 0): ['c..', '...', '...'],\n   (3, 3, 1): ['*.c', '...', '...'],\n   (3, 3, 2): None,\n   (3, 3, 3): ['***', '...', 'c..'],\n   (3, 3, 4): None,\n   (3, 3, 5): ['***', '*..', '*.c'],\n   (3, 3, 6): None,\n   (3, 3, 7): None,\n   (3, 3, 8): ['***', '***', '**c'],\n   (3, 4, 0): ['c...', '....', '....'],\n   (3, 4, 1): ['*.c.', '....', '....'],\n   (3, 4, 2): ['**.c', '....', '....'],\n   (3, 4, 3): ['*.c.', '*...', '*...'],\n   (3, 4, 4): ['****', '....', 'c...'],\n   (3, 4, 5): None,\n   (3, 4, 6): ['****', '*...', '*.c.'],\n   (3, 4, 7): None,\n   (3, 4, 8): ['****', '**..', '**.c'],\n   (3, 4, 9): None,\n   (3, 4, 10): None,\n   (3, 4, 11): ['****', '****', '***c'],\n   (3, 5, 0): ['c....', '.....', '.....'],\n   (3, 5, 1): ['*.c..', '.....', '.....'],\n   (3, 5, 2): ['**.c.', '.....', '.....'],\n   (3, 5, 3): ['***.c', '.....', '.....'],\n   (3, 5, 4): ['**.c.', '*....', '*....'],\n   (3, 5, 5): ['*****', '.....', 'c....'],\n   (3, 5, 6): ['**.c.', '**...', '**...'],\n   (3, 5, 7): ['*****', '*....', '*.c..'],\n   (3, 5, 8): None,\n   (3, 5, 9): ['*****', '**...', '**.c.'],\n   (3, 5, 10): None,\n   (3, 5, 11): ['*****', '***..', '***.c'],\n   (3, 5, 12): None,\n   (3, 5, 13): None,\n   (3, 5, 14): ['*****', '*****', '****c'],\n   (4, 1, 0): ['c', '.', '.', '.'],\n   (4, 1, 1): ['*', '.', 'c', '.'],\n   (4, 1, 2): ['*', '*', '.', 'c'],\n   (4, 1, 3): ['*', '*', '*', 'c'],\n   (4, 2, 0): ['c.', '..', '..', '..'],\n   (4, 2, 1): None,\n   (4, 2, 2): ['**', '..', 'c.', '..'],\n   (4, 2, 3): None,\n   (4, 2, 4): ['**', '**', '..', 'c.'],\n   (4, 2, 5): None,\n   (4, 2, 6): None,\n   (4, 2, 7): ['**', '**', '**', '*c'],\n   (4, 3, 0): ['c..', '...', '...', '...'],\n   (4, 3, 1): ['*.c', '...', '...', '...'],\n   (4, 3, 2): ['*.c', '*..', '...', '...'],\n   (4, 3, 3): ['***', '...', 'c..', '...'],\n   (4, 3, 4): ['***', '*..', '..c', '...'],\n   (4, 3, 5): None,\n   (4, 3, 6): ['***', '***', '...', 'c..'],\n   (4, 3, 7): None,\n   (4, 3, 8): ['***', '***', '*..', '*.c'],\n   (4, 3, 9): None,\n   (4, 3, 10): None,\n   (4, 3, 11): ['***', '***', '***', '**c'],\n   (4, 4, 0): ['c...', '....', '....', '....'],\n   (4, 4, 1): ['*.c.', '....', '....', '....'],\n   (4, 4, 2): ['**.c', '....', '....', '....'],\n   (4, 4, 3): ['**.c', '*...', '....', '....'],\n   (4, 4, 4): ['****', '....', 'c...', '....'],\n   (4, 4, 5): ['****', '*...', '..c.', '....'],\n   (4, 4, 6): ['****', '**..', '...c', '....'],\n   (4, 4, 7): ['****', '*...', '*.c.', '*...'],\n   (4, 4, 8): ['****', '****', '....', 'c...'],\n   (4, 4, 9): None,\n   (4, 4, 10): ['****', '****', '*...', '*.c.'],\n   (4, 4, 11): None,\n   (4, 4, 12): ['****', '****', '**..', '**.c'],\n   (4, 4, 13): None,\n   (4, 4, 14): None,\n   (4, 4, 15): ['****', '****', '****', '***c'],\n   (4, 5, 0): ['c....', '.....', '.....', '.....'],\n   (4, 5, 1): ['*.c..', '.....', '.....', '.....'],\n   (4, 5, 2): ['**.c.', '.....', '.....', '.....'],\n   (4, 5, 3): ['***.c', '.....', '.....', '.....'],\n   (4, 5, 4): ['***.c', '*....', '.....', '.....'],\n   (4, 5, 5): ['*****', '.....', 'c....', '.....'],\n   (4, 5, 6): ['*****', '*....', '..c..', '.....'],\n   (4, 5, 7): ['*****', '**...', '...c.', '.....'],\n   (4, 5, 8): ['*****', '***..', '....c', '.....'],\n   (4, 5, 9): ['*****', '**...', '*..c.', '*....'],\n   (4, 5, 10): ['*****', '*****', '.....', 'c....'],\n   (4, 5, 11): ['*****', '**...', '**.c.', '**...'],\n   (4, 5, 12): ['*****', '*****', '*....', '*.c..'],\n   (4, 5, 13): None,\n   (4, 5, 14): ['*****', '*****', '**...', '**.c.'],\n   (4, 5, 15): None,\n   (4, 5, 16): ['*****', '*****', '***..', '***.c'],\n   (4, 5, 17): None,\n   (4, 5, 18): None,\n   (4, 5, 19): ['*****', '*****', '*****', '****c'],\n   (5, 1, 0): ['c', '.', '.', '.', '.'],\n   (5, 1, 1): ['*', '.', 'c', '.', '.'],\n   (5, 1, 2): ['*', '*', '.', 'c', '.'],\n   (5, 1, 3): ['*', '*', '*', '.', 'c'],\n   (5, 1, 4): ['*', '*', '*', '*', 'c'],\n   (5, 2, 0): ['c.', '..', '..', '..', '..'],\n   (5, 2, 1): None,\n   (5, 2, 2): ['**', '..', 'c.', '..', '..'],\n   (5, 2, 3): None,\n   (5, 2, 4): ['**', '**', '..', 'c.', '..'],\n   (5, 2, 5): None,\n   (5, 2, 6): ['**', '**', '**', '..', 'c.'],\n   (5, 2, 7): None,\n   (5, 2, 8): None,\n   (5, 2, 9): ['**', '**', '**', '**', '*c'],\n   (5, 3, 0): ['c..', '...', '...', '...', '...'],\n   (5, 3, 1): ['*.c', '...', '...', '...', '...'],\n   (5, 3, 2): ['*.c', '*..', '...', '...', '...'],\n   (5, 3, 3): ['***', '...', 'c..', '...', '...'],\n   (5, 3, 4): ['***', '*..', '..c', '...', '...'],\n   (5, 3, 5): ['***', '*..', '*.c', '...', '...'],\n   (5, 3, 6): ['***', '***', '...', 'c..', '...'],\n   (5, 3, 7): ['***', '***', '*..', '..c', '...'],\n   (5, 3, 8): None,\n   (5, 3, 9): ['***', '***', '***', '...', 'c..'],\n   (5, 3, 10): None,\n   (5, 3, 11): ['***', '***', '***', '*..', '*.c'],\n   (5, 3, 12): None,\n   (5, 3, 13): None,\n   (5, 3, 14): ['***', '***', '***', '***', '**c'],\n   (5, 4, 0): ['c...', '....', '....', '....', '....'],\n   (5, 4, 1): ['*.c.', '....', '....', '....', '....'],\n   (5, 4, 2): ['**.c', '....', '....', '....', '....'],\n   (5, 4, 3): ['**.c', '*...', '....', '....', '....'],\n   (5, 4, 4): ['****', '....', 'c...', '....', '....'],\n   (5, 4, 5): ['****', '*...', '..c.', '....', '....'],\n   (5, 4, 6): ['****', '**..', '...c', '....', '....'],\n   (5, 4, 7): ['****', '**..', '*..c', '....', '....'],\n   (5, 4, 8): ['****', '****', '....', 'c...', '....'],\n   (5, 4, 9): ['****', '****', '*...', '..c.', '....'],\n   (5, 4, 10): ['****', '****', '**..', '...c', '....'],\n   (5, 4, 11): ['****', '****', '*...', '*.c.', '*...'],\n   (5, 4, 12): ['****', '****', '****', '....', 'c...'],\n   (5, 4, 13): None,\n   (5, 4, 14): ['****', '****', '****', '*...', '*.c.'],\n   (5, 4, 15): None,\n   (5, 4, 16): ['****', '****', '****', '**..', '**.c'],\n   (5, 4, 17): None,\n   (5, 4, 18): None,\n   (5, 4, 19): ['****', '****', '****', '****', '***c'],\n   (5, 5, 0): ['c....', '.....', '.....', '.....', '.....'],\n   (5, 5, 1): ['*.c..', '.....', '.....', '.....', '.....'],\n   (5, 5, 2): ['**.c.', '.....', '.....', '.....', '.....'],\n   (5, 5, 3): ['***.c', '.....', '.....', '.....', '.....'],\n   (5, 5, 4): ['***.c', '*....', '.....', '.....', '.....'],\n   (5, 5, 5): ['*****', '.....', 'c....', '.....', '.....'],\n   (5, 5, 6): ['*****', '*....', '..c..', '.....', '.....'],\n   (5, 5, 7): ['*****', '**...', '...c.', '.....', '.....'],\n   (5, 5, 8): ['*****', '***..', '....c', '.....', '.....'],\n   (5, 5, 9): ['*****', '***..', '*...c', '.....', '.....'],\n   (5, 5, 10): ['*****', '*****', '.....', 'c....', '.....'],\n   (5, 5, 11): ['*****', '*****', '*....', '..c..', '.....'],\n   (5, 5, 12): ['*****', '*****', '**...', '...c.', '.....'],\n   (5, 5, 13): ['*****', '*****', '***..', '....c', '.....'],\n   (5, 5, 14): ['*****', '*****', '**...', '*..c.', '*....'],\n   (5, 5, 15): ['*****', '*****', '*****', '.....', 'c....'],\n   (5, 5, 16): ['*****', '*****', '**...', '**.c.', '**...'],\n   (5, 5, 17): ['*****', '*****', '*****', '*....', '*.c..'],\n   (5, 5, 18): None,\n   (5, 5, 19): ['*****', '*****', '*****', '**...', '**.c.'],\n   (5, 5, 20): None,\n   (5, 5, 21): ['*****', '*****', '*****', '***..', '***.c'],\n   (5, 5, 22): None,\n   (5, 5, 23): None,\n   (5, 5, 24): ['*****', '*****', '*****', '*****', '****c']}\n  \n  \n  T = int(input())\n  for i in range(T):\n  	R, C, M = map(int, input().split())\n  	print('Case #{}:'.format(i + 1))\n  	try:\n  		print('\n'.join(CACHE[(R, C, M)]))\n  	except:\n  		print('Impossible')\n <CODESPLIT> 13
 \n  def solve(n, s, p, scores):\n      count = 0\n      for t in scores:\n          if ceil(t/3) >= p:\n              count += 1\n          elif 2 <= t <= 28 and ceil((t+2)/3) >= p and s > 0:\n              count += 1\n              s -= 1\n      return count\n  \n  if __name__ == '__main__':\n      with open(sys.argv[1], 'rU') as fin, open(sys.argv[2], 'w') as fout:\n          T = int(fin.readline())\n          for case in range(1, T+1):\n              line = map(int, fin.readline().split())\n              n, s, p, *scores = line\n              result = solve(n, s, p, scores)\n              print("Case #{0}: {1}".format(case, result), file=fout)\n <CODESPLIT> 14
 \n  \n  IMPOSSIBLE = []\n  \n  def transpose(grid):\n      return map(list, zip(*grid))\n  \n  def find_grid(R, C, M):\n      """Return a grid of a solution, if one exists, otherwise []\n  \n      Observations:\n      * WLOG, C <= R (otherwise, take the transpose of a solution)\n      * Trivial cases are:\n        - M = 0 or  M = RC - 1\n        - C = 1\n        - (R, C) = (2, 2)\n        - (R, C, M) = (3, 3, 2)\n        - (C, M) = (2, 1)\n      * If M >= C >= 2 and R >= 3, we can add a row of C mines to the bottom and consider M'=M-C, R'=R-1\n      * The remaining cases are M <= R-2, and M + 1 == R == C >= 4, which are both solvable\n      """\n      if M == 0:\n          grid = [['.' for c in xrange(C)] for r in xrange(R)]\n          grid[0][0] = 'c'\n          return grid\n      elif M == R * C - 1:\n          grid = [['*' for c in xrange(C)] for r in xrange(R)]\n          grid[0][0] = 'c'\n          return grid\n      elif C > R:\n          return transpose(find_grid(C, R, M))\n      elif C == 1:\n          return [['c']] + [['.'] for i in xrange(R-M-1)] + [['*'] for i in xrange(M)]\n      elif (R, C) == (2, 2) or (R, C, M) == (3, 3, 2) or (C, M) == (2, 1):\n          return IMPOSSIBLE\n  \n      assert 2 <= C <= R >= 3, "R={} C={} M={}".format(R, C, M)\n  \n      if M >= C:\n          s = find_grid(R-1, C, M-C)\n          return s and s + [['*' for c in xrange(C)]]\n      elif M <= R-2 and C >= 3:\n          grid = [['.' for c in xrange(C)] for r in xrange(R)]\n          grid[0][0] = 'c'\n          for i in xrange(M):\n              grid[R-i-1][C-1] = '*'\n          return grid\n      elif M + 1 == R == C >= 4:\n          grid = [['.' for c in xrange(C)] for r in xrange(R)]\n          grid[0][0] = 'c'\n          grid[R-1][C-2] = '*'\n          for i in xrange(M-1):\n              grid[R-i-1][C-1] = '*'\n          return grid\n  \n      assert False, "R={} C={} M={}".format(R, C, M)\n  \n  def check_soln(grid, R, C, M):\n      """checking, because debugging..."""\n      error = "R={} C={} M={}".format(R, C, M)\n      assert sum(row.count('*') for row in grid) == M, error\n      assert sum(row.count('c') for row in grid) == 1, error\n      assert len(grid) == R, error\n      assert all(len(row) == C for row in grid), error\n      _ = [i for i, row in enumerate(grid) if 'c' in row][0]\n      click = (_, [i for i, c in enumerate(grid[_]) if c == 'c'][0])\n  \n      def neighbours(r, c):\n          ns = [(i, j) for i in range(max(r-1,0),min(r+2,R)) for j in range(max(c-1,0),min(c+2,C))]\n          ns.remove((r, c))\n          return ns\n  \n      cpy = map(list, grid)\n      def fill(cpy, pos):\n          cpy[pos[0]][pos[1]] = str(sum(1 for i, j in neighbours(*pos) if grid[i][j] == '*'))\n          if cpy[pos[0]][pos[1]] == '0':\n              for i, j in neighbours(*pos):\n                  if cpy[i][j] == '.':\n                      fill(cpy, (i, j))\n      fill(cpy, click)\n      assert sum(row.count('.') for row in cpy) == 0, error\n  \n  def solve(R, C, M):\n      soln = find_grid(R, C, M)\n      if soln == IMPOSSIBLE:\n          return "Impossible"\n      else:\n          check_soln(soln, R, C, M)\n          return '\n'.join(''.join(row) for row in soln)\n  \n  if __name__ == '__main__':\n      fin = open(sys.argv[1], 'rU') if sys.argv[1:] else sys.stdin\n      fout = open(sys.argv[2], 'w') if sys.argv[2:] else sys.stdout\n      with fin, fout:\n          T = int(fin.readline())\n          for case in xrange(1, T+1):\n              r, c, m = map(int, fin.readline().split())\n              soln = solve(r, c, m)\n              print >> fout, "Case #{0}:\n{1}".format(case, soln)\n  \n <CODESPLIT> 14
def max_of_triplets(n):\n      a = n//3\n      if (n % 3) == 0:\n          if a == 0 : return (0,0)\n          return (a, a+1)\n      if (n % 3) == 1:\n          return (a+1, a+1)\n      if a == 9: return (10, 10)\n      return (a+1, a+2)\n  \n  def solve(scores, S, p):\n      t = 0\n      for s in scores:\n          a,b = max_of_triplets(s)\n          if a >= p:\n              t += 1\n          elif b >= p and S > 0:\n              t += 1\n              S -= 1\n      return t\n  \n  if __name__ == "__main__":\n      T = int(raw_input())\n      for i in range(1, T+1):\n          nums = map(int, raw_input().strip().split())\n          N = nums[0]\n          S = nums[1]\n          p = nums[2]\n          scores = nums[3:]\n          if len(scores) != N:\n              print "WTF", i\n          print "Case #%d: %d" % (i, solve(scores, S, p))\n      \n <CODESPLIT> 15
 \n  def all_grids(R,C,M, lp=0,placed=0):\n      rem = R*C-lp\n      if M-placed >= rem:\n          if M-placed > rem:\n              return None\n          \n          res = set()\n          for i in range(lp, R*C):\n              res.add(i)\n          return [res]\n          \n      if placed == M:\n          return [set()]\n  \n      res = []\n      for i in range(lp, R*C):\n          sub_sol = all_grids(R,C,M,i+1, placed+1)\n          if sub_sol is None:\n              continue\n              \n          for s in sub_sol:\n              s.add(i)\n              res.append(s)\n      return res\n  \n  def adj(R,C,i):\n      \n      res = []\n      left_edge = i % C == 0\n      top_edge = i // C == 0\n      right_edge = (i+1) % C == 0\n      bottom_edge = i // C == R-1\n      \n      if not left_edge:\n          res.append(i-1)\n          if not top_edge:\n              res.append(i-1-C)\n          if not bottom_edge:\n              res.append(i+C-1)\n              \n      if not right_edge:\n          res.append(i+1)\n          if not top_edge:\n              res.append(i+1-C)\n          if not bottom_edge:\n              res.append(i+1+C)\n              \n      if not bottom_edge:\n          res.append(i+C)\n      if not top_edge:\n          res.append(i-C)\n      return res\n          \n      \n      \n      \n  def solution(R,C,g):\n      M = R*C\n      res = []\n      num_zeroes = 0\n      for i in range(M):\n          if i in g:\n              res.append('x')\n              continue\n          x = 0\n          for a in adj(R,C,i):\n              if a in g:\n                  x += 1\n          if x == 0:\n              num_zeroes += 1\n          res.append(x)\n          \n      for i in range(M):\n          if i in g:\n              continue\n          r = res[i]\n          if r == 0 and num_zeroes == 1:\n              continue\n          connected = False\n          for a in adj(R,C,i):\n              if res[a] == 0:\n                  connected = True\n                  break\n          if not connected:\n              return None\n      \n      return res.index(0)\n  \n  def transcribe(R,C, g, sol):\n      res = []\n      for i in range(R):\n          r = []\n          for j in range(C):\n              x = i*C+j\n              if x in g:\n                  r.append('*')\n              elif x == sol:\n                  r.append('c')\n              else:\n                  r.append('.')\n          res.append(r)\n      return res\n  \n  def printed_sol(transcript):\n      if transcript is None:\n          return "Impossible"\n      else:\n          return "\n".join("".join(row) for row in transcript)\n  \n  def solve(R,C,M):\n      if M == R*C-1:\n          g = []\n          for i in range(R*C-1):\n              g.append(i)\n          return transcribe(R,C, g, R*C-1)\n      \n      for g in all_grids(R,C,M):\n          sol = solution(R,C,g)\n          if sol is None:\n              continue\n          return transcribe(R,C, g, sol)\n      return None\n              \n      \n  def output_grid(R,C,g):\n      for i in range(R):\n          for j in range(C):\n              if i*C+j not in g:\n                  sys.stdout.write(".")\n              else:\n                  sys.stdout.write("*")\n          sys.stdout.write("\n")\n  \n  if __name__ == "__main__":\n      T = int(raw_input())\n      for i in range(1,T+1):\n          R,C,M = map(int, raw_input().split())\n          print "Case #%d:" % i\n          print printed_sol(solve(R,C,M))\n <CODESPLIT> 15
 \n  FILE_NAME_BASE = 'B-small-attempt0'\n  NUM_PROCESSES = 0\n  \n  def parse(inp):\n  	data = tuple(int(x) for x in inp.readline().split())\n  	dancers, surprises, points = data[ : 3]\n  	totals = data[3 : ]\n  	assert len(totals) == dancers\n  	return totals, surprises, points\n  \n  def totalAtDist():\n  	'''\n  	If a dancer's best result is b, the total can be:\n  	  distance 0: 3b\n  	  distance 1: [3b-2..3b-1]\n  	  distance 2: [3b-4..3b-2]\n  	Note: distance d is only possible if d <= b.\n  \n  	total 15:\n  	b = 0..4:  impossible\n  	b = 5:     dist = 0\n  	b = 6:     dist = 2\n  	b = 7..10: impossible\n  \n  	For every total we have a number of explanations, which are\n  	(b, d) pairs where b is the best result and d is the distance.\n  \n  	The output of this function shows:\n  \n  	Except for 0, 1, 29 and 30, every total t has exactly 2 explanations:\n  	  ((t+2) div 3, 0|1)  and  ((t+4) div 3, 2)\n  	In other words, always one surprise option and one normal option.\n  	The surprise option can have a result one higher than the normal one or\n  	equal to it.\n  	'''\n  \n  	print '  ',\n  	for b in xrange(0, 11):\n  		print 'b=%d' % b,\n  	print\n  	for total in xrange(0, 31):\n  		print '%2d' % total,\n  		for b in xrange(0, 11):\n  			s = '0' if total == b * 3 else '.'\n  			s += '1' if b >= 1 and b * 3 - 2 <= total <= b * 3 - 1 else '.'\n  			s += '2' if b >= 2 and b * 3 - 4 <= total <= b * 3 - 2 else '.'\n  			print s,\n  		print\n  \n  \n  def solve(totals, surprises, points):\n  	countCertain = 0\n  	countSurprise = 0\n  	for total in totals:\n  		if (total + 2) / 3 >= points:\n  			countCertain += 1\n  		elif 2 <= total <= 28 and (total + 4) / 3 >= points:\n  			countSurprise += 1\n  		else:\n  			pass\n  \n  \n  	return countCertain + min(countSurprise, surprises)\n  \n  if __name__ == '__main__':\n  	inp = open(FILE_NAME_BASE + '.in.txt', 'r')\n  	numCases = int(inp.readline())\n  	if NUM_PROCESSES == 0:\n  		results = [\n  			solve(*parse(inp))\n  			for _ in range(numCases)\n  			]\n  	else:\n  		pool = Pool(NUM_PROCESSES)\n  		results = [\n  			pool.apply_async(solve, parse(inp))\n  			for _ in range(numCases)\n  			]\n  	inp.close()\n  	out = open(FILE_NAME_BASE + '.out.txt', 'w')\n  	for case, result in enumerate(results):\n  		value = result if NUM_PROCESSES == 0 else result.get()\n  		out.write('Case #%d: %s\n' % (case + 1, value))\n  		out.flush()\n  	out.close()\n <CODESPLIT> 16
 \n  FILE_NAME_BASE = 'C-small-attempt0'\n  NUM_PROCESSES = 0\n  MEM_LIMIT_GB = 1.5 # per worker process\n  RECURSION_LIMIT = 1000\n  \n  def parse(inp):\n  	rows, cols, mines = (int(x) for x in inp.readline().split())\n  	return rows, cols, mines\n  \n  def search(rows, cols, mines):\n  \n  	assert 0 <= mines < rows * cols\n  	if mines == 0:\n  		return ['c' + '.' * (cols - 1)] + ['.' * cols] * (rows - 1)\n  	if mines == rows * cols - 1:\n  		return ['c' + '*' * (cols - 1)] + ['*' * cols] * (rows - 1)\n  \n  	if rows == 1:\n  		return ['c' + '.' * (cols - 1 - mines) + '*' * mines]\n  	if cols == 1:\n  		return ['c'] + ['.'] * (rows - 1 - mines) + ['*'] * mines\n  \n  	if mines > rows * cols - 4:\n  		return None\n  \n  \n  	return None\n  \n  class SearchBoard(object):\n  \n  	def __init__(self, rows, cols):\n  		self.counts = [[0] * (cols + 2) for _ in xrange(rows + 2)]\n  		self.mineCount = 0\n  \n  	def addMine(self, row, col):\n  		counts = self.counts\n  		assert counts[row + 1][col + 1] < 10\n  		top = counts[row + 0]\n  		top[col + 0] += 1\n  		top[col + 1] += 1\n  		top[col + 2] += 1\n  		mid = counts[row + 1]\n  		mid[col + 0] += 1\n  		mid[col + 1] += 10\n  		mid[col + 2] += 1\n  		bot = counts[row + 2]\n  		bot[col + 0] += 1\n  		bot[col + 1] += 1\n  		bot[col + 2] += 1\n  		self.mineCount += 1\n  \n  	def removeMine(self, row, col):\n  		counts = self.counts\n  		assert counts[row + 1][col + 1] >= 10\n  		top = counts[row + 0]\n  		top[col + 0] -= 1\n  		top[col + 1] -= 1\n  		top[col + 2] -= 1\n  		mid = counts[row + 1]\n  		mid[col + 0] -= 1\n  		mid[col + 1] -= 10\n  		mid[col + 2] -= 1\n  		bot = counts[row + 2]\n  		bot[col + 0] -= 1\n  		bot[col + 1] -= 1\n  		bot[col + 2] -= 1\n  		self.mineCount -= 1\n  \n  	def checkConnected(self):\n  		counts = self.counts\n  		cols = len(counts[0]) - 2\n  		rows = len(counts) - 2\n  \n  		for rowIdx, row in enumerate(counts):\n  			if rowIdx == 0 or rowIdx > rows:\n  				continue\n  			try:\n  				colIdx = row.index(0, 1, -1)\n  			except ValueError:\n  				pass\n  			else:\n  				click = (rowIdx, colIdx)\n  				break\n  		else:\n  			return None\n  \n  		revealed = set()\n  		def reveal(row, col):\n  			if 1 <= row <= rows and 1 <= col <= cols:\n  				pos = (row, col)\n  				if pos not in revealed:\n  					revealed.add(pos)\n  					count = counts[row][col]\n  					if count == 0:\n  						for dr in (-1, 0, 1):\n  							for dc in (-1, 0, 1):\n  								if dr != 0 or dc != 0:\n  									reveal(row + dr, col + dc)\n  					else:\n  						assert count < 10\n  		reveal(*click)\n  		numNonMines = rows * cols - self.mineCount\n  		if len(revealed) != numNonMines:\n  			assert len(revealed) < numNonMines\n  			return None\n  \n  		board = [\n  				['.' if cell < 10 else '*' for cell in row[1 : -1]]\n  				for row in counts[1 : -1]\n  				]\n  		board[click[0] - 1][click[1] - 1] = 'c'\n  		return [''.join(row) for row in board]\n  \n  def searchBruteForce(rows, cols, mines):\n  	if mines == rows * cols - 1:\n  		return ['c' + '*' * (cols - 1)] + ['*' * cols] * (rows - 1)\n  \n  	searchBoard = SearchBoard(rows, cols)\n  \n  	def searchRec(idx, remaining):\n  		if remaining == 0:\n  			return searchBoard.checkConnected()\n  		elif idx < remaining:\n  			return None\n  		else:\n  			pos = divmod(idx, cols)\n  			searchBoard.addMine(*pos)\n  			found = searchRec(idx - 1, remaining - 1)\n  			searchBoard.removeMine(*pos)\n  			if found is not None:\n  				return found\n  			return searchRec(idx - 1, remaining)\n  \n  	return searchRec(rows * cols - 1, mines)\n  \n  def solve(rows, cols, mines):\n  	board = search(rows, cols, mines)\n  \n  	if board is None:\n  		board = searchBruteForce(rows, cols, mines)\n  		if board is None:\n  			return '\n' + 'Impossible'\n  		print 'ERROR: fast search missed solution for %dx%d board, %d mines:' \\n  				% (rows, cols, mines)\n  		for row in board:\n  			print row\n  		print\n  \n  	assert len(board) == rows\n  	assert all(len(row) == cols for row in board)\n  	counts = { 'c': 0, '.': 0, '*': 0 }\n  	for row in board:\n  		for cell in row:\n  			counts[cell] += 1\n  	assert counts['c'] == 1\n  	assert counts['*'] == mines\n  \n  	flowBoard = [\n  			['.' if cell == 'c' else cell for cell in row]\n  			for row in board\n  			]\n  	def countMinesOn(row, col):\n  		if 0 <= row < rows and 0 <= col < cols:\n  			return 1 if flowBoard[row][col] == '*' else 0\n  		else:\n  			return 0\n  	def countMinesNear(row, col):\n  		return sum(\n  			countMinesOn(row + dr, col + dc)\n  			for dr in (-1, 0, 1)\n  			for dc in (-1, 0, 1)\n  			)\n  	def reveal(row, col):\n  		if 0 <= row < rows and 0 <= col < cols:\n  			assert flowBoard[row][col] != '*'\n  			if flowBoard[row][col] == '.':\n  				count = countMinesNear(row, col)\n  				flowBoard[row][col] = str(count)\n  				if count == 0:\n  					for dr in (-1, 0, 1):\n  						for dc in (-1, 0, 1):\n  							reveal(row + dr, col + dc)\n  	clickRow, = [i for i, row in enumerate(board) if 'c' in row]\n  	clickCol = board[clickRow].index('c')\n  	reveal(clickRow, clickCol)\n  	assert all('.' not in row for row in flowBoard), flowBoard\n  \n  	assert all(type(row) == str for row in board)\n  	return '\n' + ''.join('\n' + ''.join(row) for row in board)\n  \n  def main():\n  	sys.setrecursionlimit(RECURSION_LIMIT)\n  \n  	soft, hard = resource.getrlimit(resource.RLIMIT_AS)\n  	resource.setrlimit(resource.RLIMIT_AS, (MEM_LIMIT_GB * 1024 ** 3, hard))\n  \n  	inp = open(FILE_NAME_BASE + '.in', 'r')\n  	numCases = int(inp.readline())\n  	if NUM_PROCESSES == 0:\n  		results = [\n  			solve(*parse(inp))\n  			for _ in range(numCases)\n  			]\n  	else:\n  		pool = Pool(NUM_PROCESSES)\n  		results = [\n  			pool.apply_async(solve, parse(inp))\n  			for _ in range(numCases)\n  			]\n  	inp.close()\n  	out = open(FILE_NAME_BASE + '.out', 'w')\n  	for case, result in enumerate(results):\n  		value = result if NUM_PROCESSES == 0 else result.get()\n  		out.write('Case #%d: %s\n' % (case + 1, value))\n  		out.flush()\n  	out.close()\n  \n  if __name__ == '__main__':\n  	main()\n <CODESPLIT> 16
 \n  \n  def best(total):\n      """Return the best possible score for the given `total`.  Assume\n      the total is computed by summing exactly three scores (each in the\n      interval of 0 to 10 inclusive) and no score can be 2 points apart\n      \n      Arguments:\n      - `total`:\n      """\n      m = total % 3\n      if m == 2:\n          b = total // 3 + 2\n      else:\n          b = total // 3 + 1\n      if b > 10:\n          b = 10\n      return b\n  \n  def best_non_surprising(total):\n      """Return the best possible score for the given `total`, but\n      assume that there should be no more than 1 point difference\n      between the scores.\n  \n      Arguments:\n      - `total`:\n      """\n      if total % 3 == 0:\n          return total // 3\n      else:\n          return total // 3 + 1\n  \n  def max_num_gte_p(totals, S, p):\n      """Return the maximum number of Googlers that could have had a\n      best result of at least p.\n      \n      Arguments:\n      - `totals`:\n      - `S`: number of surprising triplets of scores\n      - `p`:\n      """\n      res = 0\n      for total in totals:\n          if total == 0:\n              if p == 0:\n                  res += 1\n              continue\n  \n          if best_non_surprising(total) >= p:\n              res += 1\n          elif S > 0 and best(total) >= p:\n              res += 1\n              S -= 1\n  \n      return res\n  \n  def main():\n      with open(sys.argv[1], 'r') as f:\n          f.readline()            # skip T\n  \n          n = 0\n          for line in f:\n              n += 1\n  \n              line = [int(s) for s in line.split()]\n              N = line[0]\n              S = line[1]\n              p = line[2]\n              totals = line[3:]\n  \n              print 'Case #%d: %d' % (n, max_num_gte_p(totals, S, p))\n  \n  if __name__ == '__main__':\n      main()\n <CODESPLIT> 17
 \n  \n  FREE = '.'\n  BOMB = '*'\n  CLICK = 'c'\n  \n  \n  class Board:\n  \n  	def __init__(self, R, C, M):\n  		self.initial_M = M\n  		self.R = R\n  		self.C = C\n  		self.M = M\n  		self.matrix = [[FREE for c in range(C)] for r in range(R)]\n  		self.endx = len(self.matrix[0])\n  		self.endy = len(self.matrix)  # 0 < R * C\n  		self.startx = 0\n  		self.starty = 0\n  \n  	def fill_row(self, row):\n  		for c in self.range_active_cols:\n  			self.matrix[row][c] = BOMB\n  		self.starty += 1\n  		self.M -= self.active_cols\n  \n  	def fill_col(self, col):\n  		for r in self.range_active_rows:\n  			self.matrix[r][col] = BOMB\n  		self.startx += 1\n  		self.M -= self.active_rows\n  \n  	def pprint(self):\n  		for row in self.matrix:\n  			for cell in row:\n  				print(cell, end='')\n  			print()\n  \n  	@property\n  	def active_rows(self):\n  		return self.endy - self.starty\n  \n  	@property\n  	def active_cols(self):\n  		return self.endx - self.startx\n  \n  	def optimize(self):\n  		while 1:\n  			if (self.active_cols <= self.active_rows\n  					and self.active_cols <= self.M):\n  				self.fill_row(self.starty)\n  			elif (self.active_rows < self.active_cols\n  					and self.active_rows <= self.M):\n  				self.fill_col(self.startx)\n  			else:\n  				break\n  \n  	@property\n  	def range_active_cols(self):\n  		return range(self.startx, self.endx)\n  \n  	@property\n  	def range_active_rows(self):\n  		return range(self.starty, self.endy)\n  \n  	def is_free(self, row, col):\n  		return self.matrix[row][col] == FREE\n  \n  	def place_bomb(self):\n  		for row in self.range_active_rows:\n  			for col in self.range_active_cols:\n  				if (self.is_free(row, col) \n  						and row + 2 < self.R\n  						and col + 2 < self.C):\n  					self.matrix[row][col] = BOMB\n  					self.M -= 1 \n  					return True\n  		for col in self.range_active_cols:\n  			for row in self.range_active_rows:\n  				if (self.is_free(row, col)\n  						and row + 2 < self.R\n  						and col + 2 < self.C):\n  					self.matrix[row][col] = BOMB\n  					self.M -= 1\n  					return True\n  		return False\n  \n  	def mark_click(self):\n  		self.matrix[-1][-1] = 'c'\n  \n  	def win_condition(self):\n  		click_row = len(self.matrix) - 1\n  		click_col = len(self.matrix[0]) - 1\n  		if (click_col - 1 >= 0\n  				and not self.is_free(click_row, click_col - 1)):\n  			return False\n  \n  		if (click_row - 1 >= 0\n  				and not self.is_free(click_row - 1, click_col)):\n  			return False\n  \n  		if (click_row -1 >= 0\n  				and click_col -1 >= 0\n  				and not self.is_free(click_row - 1, click_col - 1)):\n  			return False\n  		\n  		return True\n  \n  	def win_cond2(self):\n  		if self.initial_M + 1 == self.C * self.R:\n  			return True\n  		return False\n  \n  	def solve(self):\n  		self.optimize()\n  		while self.M > 0 and self.place_bomb():\n  			pass\n  		if self.M == 0 and (self.win_condition() or self.win_cond2()):\n  			self.mark_click()\n  			self.pprint()\n  		else:\n  			print('Impossible')\n  \n  \n  def read_case(f):\n  	return map(int, f.readline().split())\n  \n  \n  def main():\n  	fn = sys.argv[1]\n  	with open(fn, encoding='utf-8') as f:\n  		ncases = int(f.readline())\n  		for case in range(1, ncases + 1):\n  			R, C, M = read_case(f)\n  			print('Case #{}:'.format(case))\n  			b = Board(R, C, M)\n  			b.solve()\n  \n  \n  def main1():\n  	b = Board(2, 1, 1)\n  	b.solve()\n  \n  \n  if __name__ == '__main__':\n  	main()\n <CODESPLIT> 17
 \n  def threshold(p, maxdiff):\n      minval = max(p - maxdiff, 0)\n      return p + minval + minval\n  \n  def process_case(numdata):\n      N,S,p = numdata[0:3]\n      scores = numdata[3:]\n      thre_normal = threshold(p, 1)\n      thre_surprise = threshold(p, 2)\n      result = 0\n      for tot in scores:\n          if tot >= thre_normal:\n              result += 1\n          elif S > 0 and tot >= thre_surprise:\n              result += 1\n              S -= 1\n      return result\n  \n  def result_gen(lines):\n      ncases = int(next(lines))\n      for ci in range(1,ncases+1):\n          result = process_case(line_of_numbers(next(lines)))\n          yield 'Case #{0}: {1}\n'.format(ci, result)\n      \n  def line_of_numbers(s):\n      return [int(sub) for sub in s.split()]\n  \n  def input_gen(f_in):\n      for line in f_in:\n          if line.endswith('\n'):\n              line = line[:-1]\n          yield line\n  \n  def start(basename):\n      infile = basename + '.in'\n      outfile = basename + '.out'\n      f_in = open(infile, 'r')\n      f_out = open(outfile, 'w')\n      f_out.writelines(result_gen(input_gen(f_in)))\n      f_in.close()\n      f_out.close()\n  \n  start('B-small-attempt0')\n <CODESPLIT> 18
 \n  def mines_refill(board, xr, xc, nfree):\n      to_refill = xr*xc - nfree\n      for r in reversed(range(2, xr)):\n          for c in reversed(range(2, xc)):\n              if not to_refill:\n                  return\n              assert(board[r][c] == '.')\n              board[r][c] = '*'\n              to_refill -= 1\n      for r in reversed(range(xr)):\n          for c in reversed(range(xc)):\n              if not to_refill:\n                  return\n              if board[r][c] == '.':\n                  board[r][c] = '*'\n                  to_refill -= 1\n      assert(to_refill == 0)\n      \n  def generate_board(nrows, ncols, nmines):\n      nfree = nrows*ncols - nmines\n      xr=1; xc=1;\n      while True:\n          if xr*xc >= nfree:\n              break\n          if xr < nrows:\n              xr += 1\n          if xr*xc >= nfree:\n              break\n          if xc < ncols:\n              xc += 1\n      board = [['*' for c in range(ncols)] for r in range(nrows)]\n      for r in range(xr):\n          for c in range(xc):\n              board[r][c] = '.'\n      mines_refill(board, xr, xc, nfree)\n      board[0][0] = 'c'\n      return board\n          \n  def find_click_point(board):\n      nrows = len(board)\n      ncols = len(board[0])\n      for r in range(nrows):\n          for c in range(ncols):\n              if board[r][c] == 'c':\n                  return (r,c)\n      raise ValueError('Start point not present')\n  \n  def enum_neighbour_coords(r0, c0, nrows, ncols):\n      for r in range(r0-1, r0+2):\n          if r<0 or r>=nrows:\n              continue\n          for c in range(c0-1, c0+2):\n              if c<0 or c>=ncols:\n                  continue\n              yield (r,c)\n  \n  def click_board(board, click_coords):\n      nrows = len(board)\n      ncols = len(board[0])\n      points = [click_coords]\n      while points:\n          r0,c0 = points.pop()\n          mines_cnt = 0\n          for r,c in enum_neighbour_coords(r0, c0, nrows, ncols):\n              if board[r][c] == '*':\n                  mines_cnt += 1\n          board[r0][c0] = str(mines_cnt)\n          if not mines_cnt:\n              for r,c in enum_neighbour_coords(r0, c0, nrows, ncols):\n                  if board[r][c] == '.':\n                      points.append((r,c))\n  \n  def all_fields_checked(board):\n      nrows = len(board)\n      ncols = len(board[0])\n      for r in range(nrows):\n          for c in range(ncols):\n              if board[r][c] == '.':\n                  return False\n      return True\n  \n  def is_board_oneclick(original_board):\n      board = [row[:] for row in original_board] # deep copy\n      assert(board[0][0] == 'c')\n      r,c = find_click_point(board)\n      click_board(board, (r,c))\n      is_oneclick = all_fields_checked(board)\n      return is_oneclick\n  \n  def board2result(board):\n      return [''.join(row) for row in board]\n  \n  def process_case(nrows, ncols, nmines):\n      board = generate_board(nrows, ncols, nmines)\n      if is_board_oneclick(board):\n          result = board2result(board)\n      else:\n          result = ['Impossible']\n      return result\n  \n  def result_gen(lines):\n      ncases = int(next(lines))\n      for ci in range(1,ncases+1):\n          R, C, M = line_of_numbers(next(lines))\n          result = process_case(R, C, M)\n          yield 'Case #{0}:\n'.format(ci, result)\n          for res_line in result:\n              yield res_line + '\n'\n      \n  def line_of_numbers(s):\n      return [int(sub) for sub in s.split()]\n  \n  def input_gen(f_in):\n      for line in f_in:\n          if line.endswith('\n'):\n              line = line[:-1]\n          yield line\n  \n  def start(basename):\n      infile = basename + '.in'\n      outfile = basename + '.out'\n      f_in = open(infile, 'r')\n      f_out = open(outfile, 'w')\n      f_out.writelines(result_gen(input_gen(f_in)))\n      f_in.close()\n      f_out.close()\n  \n  start('C-small-attempt0')\n <CODESPLIT> 18
 \n  T=0 #no. of Test cases\n  for line in fileinput.input():\n      if fileinput.isfirstline():\n          T=int(line)\n          print "no. of test cases:", T\n          continue\n      \n      nums=[int(x) for x in line.split()]\n      N=nums[0] #no. of googlers\n      S=nums[1] #no. of surprising triplets\n      p=nums[2] #max value\n      \n      del nums[:3]\n      count=0\n      for num in nums:\n          quo=num//3\n          rem=num%3\n          if quo >= p:\n              count += 1\n              continue\n          elif quo+1 == p and rem > 0:\n              count += 1\n              continue\n          elif quo+1 ==p and rem == 0 and quo > 0 and S > 0:\n              count += 1\n              S -= 1\n              continue\n          elif quo+2 >= p and rem == 2 and S > 0:\n              count += 1\n              S -= 1\n      \n      print "Case #%(k)i: %(count)i" % {"k":fileinput.lineno()-1,"count":count}\n <CODESPLIT> 19
 \n  T = int(input())\n  \n  for n in range(1, T+1):\n      print("Case #%d:" % n)\n      (R, C, M) = (int(x) for x in input().split())\n      dots = R*C - M\n      if M == 0:\n          print("\n".join(["c"+(C-1)*"."] + (R-1)*[C*"."]))\n      elif dots == 0:\n          print("Impossible")\n      elif R == 1:\n          assert C - M > 0\n          print("c"+(C-M-1)*"."+M*"*")\n      elif C == 1:\n          assert R - M > 0\n          print("c\n"+(R-M-1)*".\n"+M*"*\n", end='')\n      elif dots == 1:\n          print("\n".join(["c"+ (C-1)*"*"] + (R-1)*[C*"*"]))\n      elif dots > 3:\n          if (dots == 5) or (dots == 7):\n              print("Impossible")\n              continue\n          if (R == 2) or (C == 2):\n              if dots%2 != 0 :\n                  print("Impossible")\n                  continue\n              elif R == 2:\n                  l = int(dots/2)\n                  print("c"+(l-1)*"."+(C-l)*"*")\n                  print(l*"."+(C-l)*"*")\n                  continue\n              elif C == 2:\n                  l = int(dots/2)\n                  print("c.")\n                  print((l-1)*"..\n", end='')\n                  print(int(M/2)*"**\n", end='')\n                  continue\n          (lines, extra) = divmod(dots, C)\n          temp = []\n          if (lines >= 2) and (extra != 1):\n              temp.append("c"+(C-1)*".")\n              temp.extend((lines-1)*[C*"."])\n              temp.append(extra*"."+(C-extra)*"*")\n              temp.extend((R-lines-1)*[C*"*"])\n              print("\n".join(temp))\n              continue\n          elif (lines > 2) and (extra == 1):\n              temp.append("c"+(C-1)*".")\n              temp.extend((lines-2)*[C*"."])\n              temp.append((C-1)*"."+"*")\n              temp.append(".."+ (C-2)*"*")\n              temp.extend((R-lines-1)*[C*"*"])\n              print("\n".join(temp))\n              continue\n          elif (lines == 2) and (extra == 1):\n              temp.append("c"+(C-2)*"."+"*")\n              temp.append((C-1)*"."+"*")\n              temp.append(3*"."+(C-3)*"*")\n              temp.extend((R-3)*[C*"*"])\n              print("\n".join(temp))\n              continue\n          elif lines < 2:\n              (l, rem) = divmod(dots, 2)\n              if rem == 1:\n                  l -= 1\n                  rem += 2\n              temp.append("c"+(l-1)*"."+(C-l)*"*")\n              temp.append(l*"."+(C-l)*"*")\n              temp.append(rem*"."+(C-rem)*"*")\n              temp.extend( (R-3)*[ C*"*" ])\n              print("\n".join(temp))\n              continue\n      else:\n          print("Impossible")\n  \n <CODESPLIT> 19
 \n  \n  case = 1\n  problem = "B"\n  practice = False\n  \n  if practice:\n      practice = "-practice"\n  else:\n      practice = "-attempt0"\n  if case == 0:\n      infile = open("%s-%s%s.in" % (problem, "sample", practice), 'r')\n      outfile = open("%s-%s%s.out" % (problem, "sample", practice), 'w')        \n  elif case == 1:\n      infile = open("%s-%s%s.in" % (problem, "small", practice), 'r')\n      outfile = open("%s-%s%s.out" % (problem, "small", practice), 'w')    \n  elif case == 2:\n      infile = open("%s-%s%s.in" % (problem, "large", practice), 'r')\n      outfile = open("%s-%s%s.out" % (problem, "large", practice), 'w')   \n  else:\n      raise ValueError, 'Invalid case'\n      \n  lookup = {}\n  \n  def check_total(total, p):\n      assert type(total) == int\n      resid = total % 3\n  \n      min_nosurprise = (total / 3)    \n      max_nosurprise = (total / 3) + min(1, resid)\n      \n      \n      if resid == 1 or max_nosurprise == 10 or (resid == 0 and min_nosurprise == 0):\n          if max_nosurprise >= p:\n              return 1\n          else:\n              return -1\n  \n      if max_nosurprise >= p:\n          return 1\n      elif max_nosurprise == p-1:\n          return 0\n      else:\n          return -1\n      \n  cases = int(infile.readline().strip('\n'))\n  for i in range(cases):\n      print 'case %i of %i' % (i+1, cases)\n      line = infile.readline().split()\n      N = int(line[0])\n      S = int(line[1])\n      p = int(line[2])\n      points = []\n      for item in line[3:]:\n          points.append(int(item))\n      assert N == len(points)\n      assert p <= 10\n      assert p >= 0\n      assert S >= 0\n      assert S <= N\n      \n      always = 0\n      possible = 0\n      \n      for total in points:\n          if (total, p) in lookup:\n              depends = lookup[total, p]\n          else:\n              depends = check_total(total, p)\n          \n          if depends == 1:\n              always += 1\n          elif depends == 0:\n              possible += 1\n      \n      output = '%i' % (always + min(possible, S))\n      \n      outfile.write('Case #%i: %s\n' % (i+1, output))\n      \n  infile.close()\n  outfile.close()\n <CODESPLIT> 20
 \n  \n  \n  \n  \n  \n  \n  class memoize(object):\n     """Decorator. Caches a function's return value each time it is called.\n     If called later with the same arguments, the cached value is returned\n     (not reevaluated).\n     """\n     def __init__(self, func):\n        self.func = func\n        self.cache = {}\n     def __call__(self, *args):\n        if not isinstance(args, collections.Hashable):\n           return self.func(*args)\n        if args in self.cache:\n           return self.cache[args]\n        else:\n           value = self.func(*args)\n           self.cache[args] = value\n           return value\n     def __repr__(self):\n        '''Return the function's docstring.'''\n        return self.func.__doc__\n     def __get__(self, obj, objtype):\n        '''Support instance methods.'''\n        return functools.partial(self.__call__, obj)\n  \n  \n  def precalculate():\n      """Perform any calculations that need to be performed before the main path\n      (e.g., preparing lookup tables, etc.)\n      \n      N.B. Make sure you make any important variables global so that other\n      functions can access them.\n      """\n      pass\n  \n  def read_input(infile):\n      """This function should take an open input file, load in all of the\n      relevant information for a single case of the problem, and output it\n      as a single object.    \n      """\n      def read_int():\n          return int(infile.readline().strip())\n      def read_ints():\n          return np.array(infile.readline().split(), dtype=int)\n      def read_bigints(): #For ints that won't fit directly in an int32 array\n          line = infile.readline().split()\n          return np.array(map(lambda x: int(x), line))\n      def read_float():\n          return float(infile.readline().strip())\n      def read_floats():\n          return np.array(infile.readline().split(), dtype=float)\n      def read_string():\n          return infile.readline().strip()\n      def read_strings():\n          return np.array(infile.readline().split(), dtype=object) #N.B. general dtype\n      \n      R, C, M = read_ints()\n      \n      return R, C, M\n  \n  def solve_case(case):\n      """Take the input data (structured in case) and perform any necessary\n      calculations to obtain the desired output, formatted as the appropriate\n      string.    \n      """\n      R, C, M = case\n      \n      free = R * C - M\n      assert free >= 1\n      \n      board = np.zeros((R, C), dtype=int) - 1\n      \n      def write_board(board):\n          d = {0:'.', 1:'c', 2:'*'}\n          s = "\n"\n          for row in board:\n              for num in row:\n                  try:\n                      s += d[num]\n                  except KeyError:\n                      raise ValueError("Board not filled in!")\n              s += "\n"\n          return s\n      \n      board[0,0] = 1\n      \n      if M == 0:\n          board[board == -1] = 0\n          return write_board(board)\n      \n      if free == 1:\n          board[board == -1] = 2\n          return write_board(board)\n          \n      \n      while min(R, C) <= M:\n          if R < C:\n              board[:,C-1] = 2\n              C -= 1\n              M -= R\n          elif C <= R:\n              board[R-1,:] = 2\n              R -= 1\n              M -= C\n      \n      def cascades(board, r, c):\n          rows = [i for i in (r-1, r, r+1) if (i >= 0 and i < board.shape[0])]\n          cols = [i for i in (c-1, c, c+1) if (i >= 0 and i < board.shape[1])]\n          for r in rows:\n              for c in cols:\n                  if board[r,c] == 2: #Mine next to given position\n                      return False\n          return True\n      \n      if M == 0:\n          board[board == -1] = 0\n          if cascades(board, 0, 0):\n              return write_board(board)\n          else:\n              return "\nImpossible"\n      \n      \n      if M > (R + C - 5):\n          return "\nImpossible"\n          \n      if M > 0 and (R <= 2 or C <= 2):\n          return "\nImpossible"\n          \n      print M, R + C - 5\n      fill_num = min(M, R - 2)\n      print M, fill_num\n      board[(R - fill_num):,C-1] = 2\n      M -= fill_num\n      \n      fill_num = min(M, C - 3)\n      print M, fill_num\n      board[R-1,(C - fill_num - 1):] = 2\n      M -= fill_num\n      \n      board[board == -1] = 0\n      return write_board(board)\n  \n  \n  if __name__ == "__main__":\n      precalculate()\n      \n      assert len(sys.argv) == 2 #only one argument\n      assert sys.argv[1][-3:] == ".in" #input must end with .in\n      infile = open("%s" % sys.argv[1], 'r')\n      outfile = open("%s.out" % sys.argv[1][:-3], 'w')\n      \n      cases = int(infile.readline().strip('\n'))\n      for i in range(cases):\n          \n          case = read_input(infile)\n          \n          output = solve_case(case)\n          \n          outfile.write('Case #%i: %s\n' % (i+1, output))\n          print 'Case #%i: %s\n' % (i+1, output)\n      \n      infile.close()\n      outfile.close()\n <CODESPLIT> 20
def passes(p, t): #normal, surprising\n      q, r = divmod(t, 3)\n      if r == 0:\n          return q >= p, q + 1 >= p and q\n      elif r == 1:\n          return q + 1 >= p, q + 1 >= p and q\n      elif r == 2:\n          return q + 1 >= p, q + 2 >= p\n  \n  for case in range(int(input())):\n      st = input().strip().split()\n      n, s, p, t = int(st[0]), int(st[1]), int(st[2]), list(map(int, st[3:]))\n      result = 0\n      for i in t:\n          normal, surprising = passes(p, i)\n          if normal:\n              result += 1\n          elif surprising and s != 0:\n              result += 1\n              s -= 1\n      print("Case #{}: {}".format(case + 1, result))\n <CODESPLIT> 21
 \n  \n  '''\n  ...\n  ...\n  ...\n  ...\n  ...\n  '''\n  \n  for i in range(int(input())):\n  \n      r, c, m = tuple(map(int, str.split(input())))\n      count = r * c - m\n      field = dict(map(lambda c: (c, "*"), itertools.product(range(c), range(r))))\n      answer = "Impossible"\n  \n      if m == 0:\n  \n          answer = field\n  \n      elif 1 in (r, c):\n  \n          for p in itertools.islice(itertools.product(range(c), range(r)), count):\n  \n              field[p] = "."\n  \n          answer = field\n  \n      elif count in (0, 2, 3, 5, 7):\n  \n          pass\n  \n      elif count == 1:\n  \n          answer = field\n  \n      elif count // 2 < c or count == c * 2 + 1:\n  \n          if count % 2 != 0:\n  \n              tail = 3\n              ncount = count - 3\n  \n          else:\n  \n              tail = 0\n              ncount = count\n  \n          for x in range(ncount // 2):\n  \n              field[(x, 0)] = field[(x, 1)] = "."\n  \n          for x in range(tail):\n  \n              field[(x, 2)] = "."\n  \n          answer = field\n  \n      elif not (c == 2 and count % c == 1):\n  \n          for x in range(c):\n  \n              field[(x, 0)] = field[(x, 1)] = "."\n  \n          count -= 2 * c\n          tail = 0\n          if count % c == 1:\n  \n              tail = 2\n              count -= 1\n  \n          y = 2\n          while count > 0:\n  \n              rx = min(count, c)\n              for x in range(rx):\n  \n                  field[(x, y)] = "."\n  \n              count -= rx\n              y += 1\n  \n          for x in range(tail):\n  \n              field[(x, y)] = "."\n  \n          answer = field\n  \n      field[(0, 0)] = "c"\n      print(str.format("Case #{}:", i + 1))\n      if isinstance(answer, dict):\n  \n          for y in range(r):\n  \n              print(str.join("", map(lambda x: field[(x, y)], range(c))))\n  \n      else:\n  \n          print(answer)\n <CODESPLIT> 21
 \n  \n  f = open(sys.argv[1],'r')\n  \n  num = int(f.readline())\n  \n  for i in range(num):\n      res = [int(x) for x in f.readline().split()]\n      nrg, nrsup, score = res[0:3]\n      del res[0:3]\n      nrpass = 0\n      nrsuppass = 0\n      for x in res:\n          if score > 1:\n              if x >= 3*score-2:\n                  nrpass += 1\n              elif x >= 3*score-4:\n                  nrsuppass += 1\n          elif score == 1:\n              if x > 0:\n                  nrpass += 1\n          else:\n              nrpass +=1\n      print 'Case #{}:'.format(i+1), nrpass + min(nrsup, nrsuppass)\n <CODESPLIT> 22
 \n  \n  f = open(sys.argv[1],'r')\n  \n  num = int(f.readline())\n  \n  def count(z, r, c):\n      return len(z_and_nei(z,r,c))\n  \n  def nei(z, r, c):\n      s = z_and_nei(z, r, c)\n      s -= set(z)\n      return s\n  \n  def z_and_nei(z, r, c):\n      s = set()\n      for x in z:\n          s.add(x)\n          s.add((x[0]-1,x[1]-1))\n          s.add((x[0]-1,x[1]))\n          s.add((x[0]-1,x[1]+1))\n          s.add((x[0],x[1]-1))\n          s.add((x[0],x[1]+1))\n          s.add((x[0]+1,x[1]-1))\n          s.add((x[0]+1,x[1]))\n          s.add((x[0]+1,x[1]+1))\n      o = set()\n      for x in s:\n          if x[0] < 0 or x[0] > r-1 or x[1] < 0 or x[1] > c-1:\n              o.add(x)\n      s-=o\n      return s\n  \n  def find_config(z, r, c, t):\n      if count(z,r,c) == t:\n          return z\n      if count(z,r,c) > t:\n          return []\n      n = nei(z,r,c)\n      for x in n:\n          z.append(x)\n          if find_config(z,r,c,t) != []:\n              return z\n          z.pop()\n      return []\n  \n  for i in range(num):\n      print 'Case #{}:'.format(i+1)\n      r, c, m = [int(x) for x in f.readline().split()]\n      if r*c-m == 1:\n          print 'c' + '*'*(c-1)\n          for i in range(r-1):\n              print '*'*c\n      else:\n          z = find_config([(0,0)], c, r, c*r-m)\n          if z == []:\n              print "Impossible"\n          else:\n              s = z_and_nei(z, c, r)\n              for j in range(r):\n                  for k in range(c):\n                      if j == 0 and k == 0:\n                          print 'c',\n                      elif (k,j) in s:\n                          print '.',\n                      else:\n                          print '*',\n                  print\n  \n  \n <CODESPLIT> 22
"""Usage:\n      X.py < X.in > X.out\n  """\n  \n  \n  \n  class Solver(object):\n      cache = {}\n  \n      def __init__(self, infile, testcase):\n          self.testcase = testcase\n          self.P = P = map(int, infile.next().split())\n  \n      def init_cache(self):\n          if 'main' in self.cache:\n              return\n  \n      def solve(self):\n  \n          N, S, p = self.P[:3]\n          G = sorted(self.P[3:], reverse=True)\n  \n          r = 0\n          s = 0\n          for g in G:\n              if g >= 3 * p - 2 and g >= p:\n                  r += 1\n              elif g >= 3 * p - 4 and g >= p:\n                  if s == S:\n                      break\n                  r += 1\n                  s += 1\n  \n          return r\n  \n  \n  def main():\n      T = int(sys.stdin.next())\n      for t in xrange(T):\n          sys.stdout.write('Case #%s: %s\n' % (t + 1, Solver(sys.stdin, t).solve()))\n  \n  \n  if __name__ == '__main__':\n      main()\n <CODESPLIT> 23
"""Usage:\n      pypy X.py < X-size.in > X-size.out\n  or sometimes\n      python X.py < X-size.in > X-size.out\n  """\n  \n  def setup(infile):\n      return locals()\n  \n  def reader(testcase, infile, C=None, **ignore):\n      P = map(int, infile.next().split())\n      return locals()\n  \n  def solver(testcase, N=None, P=None, I=None, T=None, S=None, C=None, **ignore):\n  \n      R, C, M = P\n      MM = M\n  \n      F = np.array([['.'] * C] * R)\n      while M > 0:\n          if R >= C and M >= C and R > 2:\n              M -= C\n              R -= 1\n              F[R] = '*'\n          elif C > R  and M >= R and C > 2:\n              M -= R\n              C -= 1\n              F[:, C] = '*'\n          elif R > 2 and C > 2 and (R > 3 or C > 3 or M == 1):\n              if M < C - 1:\n                  R -= 1\n                  F[R, C - M:C] = '*'\n              elif M < R - 1:\n                  C -= 1\n                  F[R - M:R, C] = '*'\n              elif M == C - 1:\n                  R -= 1\n                  F[R, C - M + 1:C] = '*'\n                  F[R - 1, C - 1] = '*'\n              else:\n                  C -= 1\n                  F[R - M + 1:R, C] = '*'\n                  F[R - 1, C - 1] = '*'\n              M = 0\n          elif M == R * C - 1:\n              F[:, :] = '*'\n              M = 0\n          else:\n              return 'Case #%s:\n%s\n' % (testcase, 'Impossible')\n  \n      F[0, 0] = 'c'\n      assert (F == '*').sum() == MM\n      return 'Case #%s:\n%s\n' % (testcase, '\n'.join(''.join(f.tolist()) for f in F))\n  \n  if __name__ == '__main__':\n      T = int(sys.stdin.next())\n      common = setup(sys.stdin)\n      for t in xrange(1, T+1):\n          sys.stdout.write(solver(**reader(t, **common)))\n <CODESPLIT> 23
t = int(raw_input().strip())\n  t_count = 1\n  while t_count <= t:\n  	line = raw_input().strip().split()\n  	n = int(line[0])\n  	s = int(line[1])\n  	p = int(line[2])\n  	ti_list = line[3:]\n  	p_min = max(p * 3 - 2, p)\n  	p_min_surprise = max(p * 3 - 4, p)\n  	result = 0\n  	for ti in ti_list:\n  		ti = int(ti)\n  		if ti >= p_min:\n  			result += 1\n  		elif p_min > p_min_surprise and ti >= p_min_surprise and s > 0:\n  			result += 1\n  			s -= 1\n  	print 'Case #%d: %d' % (t_count, result,)\n  	t_count += 1\n <CODESPLIT> 24
class Sweeper(object):\n      def __init__(self, r, c, m):\n          self.matrix = [['.' for j in range(0, c)] for i in range(0, r)]\n          self.matrix[0][0] = 'c'\n  \n          self.r = r\n          self.c = c\n          self.m = m\n          self.current_r = r\n          self.current_c = c\n          self.current_m = m\n  \n      def fill_row(self):\n          if self.current_r >= 3 and self.current_m >= self.current_c:\n              for i in range(0, self.current_c):\n                  self.matrix[self.current_r - 1][i] = '*'\n              self.current_r -= 1\n              self.current_m -= self.current_c\n              return True\n          return False\n  \n      def fill_col(self):\n          if self.current_c >= 3 and self.current_m >= self.current_r:\n              for i in range(0, self.current_r):\n                  self.matrix[i][self.current_c - 1] = '*'\n              self.current_c -= 1\n              self.current_m -= self.current_r\n              return True\n          return False\n  \n      def fill_partial(self):\n          if self.current_r >= 3:\n              fill_num = min(self.current_m, self.current_c - 2)\n              for i in range(0, fill_num):\n                  self.matrix[self.current_r - 1][self.current_c - 1 - i] = '*'\n              self.current_m -= fill_num\n              if fill_num > 0:\n                  self.current_r -= 1\n          if self.current_c >= 3:\n              fill_num = min(self.current_m, self.current_r - 2)\n              for i in range(0, fill_num):\n                  self.matrix[self.current_r - 1 - i][self.current_c - 1] = '*'\n              self.current_m -= fill_num\n              if fill_num > 0:\n                  self.current_c -= 1\n          if self.current_m > 0:\n              return False\n          else:\n              return True\n  \n      def fill_special_one(self):\n          if self.current_r * self.current_c == self.current_m + 1:\n              for i in range(0, self.current_r):\n                  for j in range(0, self.current_c):\n                      self.matrix[i][j] = '*'\n              self.matrix[0][0] = 'c'\n              self.current_r = 0\n              self.current_c = 0\n              self.current_m = 0\n              return True\n          return False\n  \n      def fill_special_col(self):\n          if self.current_c == 1 and self.current_r > self.current_m:\n              for i in range(0, self.current_m):\n                  self.matrix[self.current_r - 1 - i][0] = '*'\n              self.matrix[0][0] = 'c'\n              self.current_m = 0\n              self.current_r = 0\n              self.current_c = 0\n              return True\n          return False\n  \n      def fill_special_row(self):\n          if self.current_r == 1 and self.current_c > self.current_m:\n              for i in range(0, self.current_m):\n                  self.matrix[0][self.current_c - 1 - i] = '*'\n              self.matrix[0][0] = 'c'\n              self.current_m = 0\n              self.current_r = 0\n              self.current_c = 0\n              return True\n          return False\n  \n  def print_matrix(matrix):\n      for row in matrix:\n          s = ''\n          for col in row:\n              s += col\n          print s\n  \n      \n  def solve_case(t):\n      r, c, m = [int(num) for num in raw_input().strip().split()]\n      sweeper = Sweeper(r, c, m)\n      print 'Case #%d:' % (t,)\n      if sweeper.fill_special_one() or sweeper.fill_special_col() or sweeper.fill_special_row():\n          print_matrix(sweeper.matrix)\n          return\n      f_result = True\n      while sweeper.current_m > 0 and f_result:\n          f_result = False\n          f_result |= sweeper.fill_row()\n          f_result |= sweeper.fill_col()\n      if sweeper.current_m > 0:\n          sweeper.fill_partial()\n      if sweeper.current_m > 0:\n          print 'Impossible'\n      else:\n          print_matrix(sweeper.matrix)\n  \n  def main():\n      t = int(raw_input().strip())\n      for i in range(1, t + 1):\n          solve_case(i)\n  \n  if __name__ == '__main__':\n      main()\n <CODESPLIT> 24
 \n  __file__ = sys.argv[0]\n  __path__ = os.path.dirname(__file__)\n  __prob__ = os.path.basename(__path__)\n  \n  def pout(s, back=0):\n      f = sys._getframe(back+1)\n      d = 0\n      if 'depth' in f.f_locals:\n          d = f.f_locals['depth']\n      print(' '*d + s + ' = ' + repr(eval(s, f.f_globals, f.f_locals)))\n  \n  def perr(s, back=0):\n      f = sys._getframe(back+1)\n      d = 0\n      if 'depth' in f.f_locals:\n          d = f.f_locals['depth']\n      ERR_FILE.write(' '*d + '%s = %s\n'%(s, repr(eval(s, f.f_globals, f.f_locals))))\n  \n  def argmin(f, s=None):\n      a = f\n      if s is None:\n          s = range(len(a))\n          f = lambda i: a[i]\n      res = None\n      for x in s:\n          y = f(x)\n          if res is None or best > y:\n              best = y\n              res = x\n      return res\n  \n  def argmax(f, s=None):\n      a = f\n      if s is None:\n          s = range(len(a))\n          f = lambda i: a[i]\n      res = None\n      for x in s:\n          y = f(x)\n          if res is None or best < y:\n              best = y\n              res = x\n      return res\n  \n  def read_word(f):\n      return next(f).strip()\n  \n  def read_int(f, b=10):\n      return int(read_word(f), b)\n  \n  def read_words(f, d=' '):\n      return read_word(f).split(d)\n  \n  def read_ints(f, b=10, d=' '):\n      return [int(x, b) for x in read_words(f, d)]\n  \n  def read_word_arr(f, R):\n      res = []\n      for i in range(R):\n          res.append(read_word(f))\n      return res\n  \n  def read_ints_arr(f, R, dtype=int, *args, **kwargs):\n      res = []\n      for i in range(R):\n          res.append(read_ints(f, *args, **kwargs))\n      return numpy.array(res, dtype)\n  \n  def solve(solver, fn, start_case=0, end_case=None, out_fn=None):\n      global ERR_FILE\n      in_fn = fn + '.in'\n      if out_fn is None:\n          out_fn = fn + '.out'\n      err_fn = fn + '.err'\n      if start_case == 0:\n          append = True\n          if os.path.exists(out_fn):\n              with open(out_fn, 'r') as f:\n                  for l in f:\n                      if l[:6] == 'Case #':\n                          start_case = int(l[6:l.index(':')])+1\n      else:\n          append = False\n      with open(in_fn, 'r') as fi:\n          with open(out_fn, 'a' if append else 'w') as fo:\n              with open(err_fn, 'w') as ERR_FILE:\n                  T = read_int(fi)\n                  for i in range(T):\n                      case = read_case(fi)\n                      if i+1 < start_case:\n                          continue\n                      print('Case #%d of %d'%(i+1, T))\n                      ERR_FILE.write('Case #%d of %d\n'%(i+1, T))\n                      perr('case')\n                      res = solver(case)\n                      perr('res')\n                      write_case(fo, i, res)\n                      fo.flush()\n                      if end_case is not None and i+1 == end_case:\n                          break\n  \n  def test(start_case=1, end_case=None):\n      fn = os.path.join(__path__, 'test')\n      solve(solve_small, fn, start_case, end_case)\n  \n  def small(start_case=1, end_case=None):\n      fn = os.path.join(__path__, '%s-small-attempt0'%__prob__)\n      solve(solve_small, fn, start_case, end_case)\n  \n  def small2(start_case=1, end_case=None):\n      fn = os.path.join(__path__, '%s-small-attempt0'%__prob__)\n      solve(solve_large, fn, start_case, end_case, fn + '2.out')\n  \n  def large(start_case=0, end_case=None):\n      fn = os.path.join(__path__, '%s-large-attempt0'%__prob__)\n      solve(solve_large, fn, start_case, end_case)\n  \n  \n  def read_case(f):\n      Z = read_ints(f)\n      (N, S, p) = Z[:3]\n      t = Z[3:]\n      return (N, S, p, t)\n  \n  def write_case(f, i, res):\n      f.write('Case #%d: '%(i+1))\n      f.write('%s'%res)\n      f.write('\n')\n  \n  FAIL = 'NO SOLUTION'\n  \n  def solve_small(case):\n      (N, S, p, t) = case\n      res = 0\n      for i in range(N):\n          if p >= 2:\n              if t[i] >= 3*p-2:\n                  res += 1\n              elif S > 0 and t[i] >= 3*p-4:\n                  res += 1\n                  S -= 1\n          elif p == 1:\n              if t[i] >= 3*p-2:\n                  res += 1\n          elif p == 0:\n              res += 1\n      return res\n  \n  solve_large = solve_small\n  \n  pout = perr\n <CODESPLIT> 25
 \n  def read_word(f):\n      return next(f).strip()\n  \n  def read_int(f, b=10):\n      return int(read_word(f), b)\n  \n  def read_letters(f):\n      return list(read_word(f))\n  \n  def read_digits(f, b=10):\n      return [int(x, b) for x in read_letters(f)]\n  \n  def read_words(f, d=' '):\n      return read_word(f).split(d)\n  \n  def read_ints(f, b=10, d=' '):\n      return [int(x, b) for x in read_words(f, d)]\n  \n  def read_floats(f, d=' '):\n      return [float(x) for x in read_words(f, d)]\n  \n  def read_arr(f, R, reader=read_ints, *args, **kwargs):\n      return [reader(f, *args, **kwargs) for i in range(R)]\n  \n  def solve(solver, fn, out_fn=None):\n      in_fn = fn + '.in'\n      if out_fn is None:\n          out_fn = fn + '.out'\n      with open(in_fn, 'r') as fi:\n          with open(out_fn, 'w') as fo:\n              T = read_int(fi)\n              for i in range(T):\n                  case = read_case(fi)\n                  res = solver(case)\n                  write_case(fo, i, res)\n  \n  \n  def read_case(f):\n      return read_ints(f)\n  \n  def write_case(f, i, res):\n      f.write('Case #%d: '%i)\n      if isinstance(res, list):\n          res[0][0] = 'c'\n          res = '\n'.join(''.join(c for c in r) for r in res)\n      f.write('\n%s'%res)\n      f.write('\n')\n  \n  \n  def solve_small(case):\n      (R, C, M) = case\n      if R == 1:\n          return 'c' + '.'*(C-M-1) + '*'*M\n      if C == 1:\n          return '\n'.join(['c'] + ['.']*(R-M-1) + ['*']*M)\n      m = R*C - M\n      res = [['*']*C for r in range(R)]\n      if m == 1:\n          return res\n      for r in range(2, R+1):\n          c = m // r\n          z = m % r\n          if c < 2 or c + (z>0) > C:\n              continue\n          if z == 1 and (r < 3 or c < 3):\n              continue\n          for x in range(r):\n              for y in range(c):\n                  res[x][y] = '.'\n          for y in range(z):\n              res[y][c] = '.'\n          if z == 1:\n              res[z][c] = '.'\n              res[r-1][c-1] = '*'\n          return res\n      return 'Impossible'\n  \n  def solve_large(case):\n      return solve_small(case)\n  \n  DEBUG = 'f'\n  \n <CODESPLIT> 25
 \n  def solve(N,S,p,t):\n      if p == 0:\n          return N\n      outright_wins = 0\n      potential_surprises = 0\n      win_cutoff = (p * 3) - 3\n      surprise_cutoff = win_cutoff - 2\n      for score in t:\n          if score == 0:\n              continue\n          elif score > win_cutoff:\n              outright_wins += 1\n          elif score > surprise_cutoff:\n              potential_surprises += 1\n      if potential_surprises < S:\n          return outright_wins + potential_surprises\n      else:\n          return outright_wins + S\n  \n  def parse_case(data_line):\n      bits = data_line.split()\n      N = int(bits[0])\n      S = int(bits[1])\n      p = int(bits[2])\n      t = [int(x) for x in bits[3:]]\n      return N,S,p,t\n  \n  def main():\n      parser = OptionParser()\n      parser.add_option("-f", "--file", dest="filename",\n                        help="read input from FILE", metavar="FILE")\n  \n      (options, args) = parser.parse_args()\n      if not options.filename:\n          parser.error("Must provide a filename.")\n      input_file = open(options.filename, "r")\n      total_cases = int(input_file.readline())\n      case_number = 0\n      while case_number < total_cases:\n      	case_number += 1\n      	data_args = parse_case(input_file.readline())\n      	print "Case #%d: %d" % (case_number, solve(*data_args))\n  \n  if __name__ == "__main__":\n  	main()\n <CODESPLIT> 26
 \n  \n  TEST_CASES = [\n      ("""5\n  5 5 23\n  3 1 1\n  2 2 1\n  4 7 3\n  10 10 82\n  ""","""Case #1:\n  Impossible\n  Case #2:\n  c\n  .\n  *\n  Case #3:\n  Impossible\n  Case #4:\n  c......\n  .......\n  .......\n  ....***\n  Case #5:\n  c........*\n  .........*\n  **********\n  **********\n  **********\n  **********\n  **********\n  **********\n  **********\n  **********\n  """),\n      ("""3\n  5 4 3\n  5 3 8\n  5 5 14\n  ""","""Case #1:\n  c...\n  ....\n  ....\n  ...*\n  ..**\n  Case #2:\n  Impossible\n  Case #3:\n  c...*\n  ....*\n  ...**\n  *****\n  *****\n  """)\n  ]\n  \n  IMPOSSIBLE = "Impossible"\n  \n  """\n  S is number of safe squares = (R*C) - M\n  If S == 1 then always possible:\n      Assume click in top left, all else mines\n  Special cases (R or C is small):\n  If R == 1 or C == 1 then always possible:\n      Assume click in top left and all safe squares in a line\n  Else if R == 2 or C == 2 then possible iff S % 2 == 0:\n      Assume click in top left and all safe squares are in a 2 * X line\n  Else if R == 3 or C == 3 then possible if S % 3 == 0 (Assume click in top left and all safe squares are in a 3 * X line)\n     OR if S % 2 == 0 \n  """\n  \n  def parse_input(input_reader):\n      case_count = int(input_reader.readline())\n      case_idx = 0\n      while case_count > case_idx:\n          case_idx += 1\n          input_line = [int(x) for x in input_reader.readline().split()]\n          input_values = {"case": case_idx,\n                          "R": input_line[0],\n                          "C": input_line[1],\n                          "M": input_line[2]}\n          yield input_values\n  \n  \n  def solve_problem(output_writer=sys.stdout, **kwargs):\n      case = kwargs['case']\n      rows = kwargs['R']\n      cols = kwargs['C']\n      mines = kwargs['M']\n      safe_squares = ((rows * cols) - mines)\n      print >> output_writer, "Case #%d:" % case\n      row_string = "{:*<%ds}" % cols\n      impossible = False\n      if safe_squares == 1:\n          print >> output_writer, row_string.format("c")\n          for row in range(1, rows):\n              print >> output_writer, row_string.format("")\n      elif rows == 1:\n          safe_string = "c" + ("." * (safe_squares - 1))\n          print >> output_writer, row_string.format(safe_string)\n      elif cols == 1:\n          for row in range(rows):\n              cell = ""\n              if row == 0:\n                  cell = "c"\n              elif row < safe_squares:\n                  cell = "."\n              print >> output_writer, row_string.format(cell)\n      elif safe_squares == 2:\n          impossible = True\n      elif rows == 2:\n          safe_cols, remainder = divmod(safe_squares, 2)\n          if remainder == 1:\n              impossible = True\n          else:\n              safe_string = "." * (safe_cols - 1)\n              print >> output_writer, row_string.format("c%s" % safe_string)\n              print >> output_writer, row_string.format(".%s" % safe_string)\n      elif cols == 2:\n          safe_rows, remainder = divmod(safe_squares, 2)\n          if remainder == 1:\n              impossible = True\n          else:\n              for row in range(rows):\n                  cells = ""\n                  if row == 0:\n                      cells = "c."\n                  elif row < safe_rows:\n                      cells = ".."\n                  print >> output_writer, row_string.format(cells)\n      else:\n          safe_rows, remainder = divmod(safe_squares, cols)\n          if remainder == 1 and cols == 3 and safe_rows == 2:\n              impossible = True\n          elif safe_rows > 1:\n              if remainder == 1 and safe_rows == 2:\n                  mid_safe = "." * (cols-2)\n                  for row in range(rows):\n                      cell_one = "."\n                      mid_cells = mid_safe\n                      last_cell = "."\n                      if row == 0:\n                          cell_one = "c"\n                      elif safe_rows == 0:\n                          cell_one = "."\n                          mid_cells = "." * (remainder + 1)\n                      elif safe_rows < 0:\n                          cell_one = ""\n                          mid_cells = ""\n                      if safe_rows < 3:\n                          last_cell = ""\n                      print >> output_writer, row_string.format("%s%s%s" % (cell_one, mid_cells, last_cell))\n                      safe_rows -= 1\n              elif remainder == 1:\n                  mid_safe = "." * (cols-2)\n                  for row in range(rows):\n                      cell_one = "."\n                      mid_cells = mid_safe\n                      last_cell = "."\n                      if row == 0:\n                          cell_one = "c"\n                      elif safe_rows == 0:\n                          cell_one = "."\n                          mid_cells = "." * remainder\n                      elif safe_rows < 0:\n                          cell_one = ""\n                          mid_cells = ""\n                      if safe_rows < 2:\n                          last_cell = ""\n                      print >> output_writer, row_string.format("%s%s%s" % (cell_one, mid_cells, last_cell))\n                      safe_rows -= 1\n              else:\n                  full_safe = "." * cols\n                  for row in range(rows):\n                      cells = full_safe\n                      if row == 0:\n                          cells = "c" + ("." * (cols - 1))\n                      elif row == safe_rows:\n                          cells = "." * remainder\n                      elif row > safe_rows:\n                          cells = ""\n                      print >> output_writer, row_string.format(cells)\n          else:\n              safe_cols, remainder = divmod(safe_squares, 2)\n              if remainder == 1 and safe_cols < 4:\n                  impossible = True\n              elif remainder == 0:\n                  print >> output_writer, row_string.format("c%s" % ("." * (safe_cols - 1)))\n                  print >> output_writer, row_string.format("." * safe_cols)\n                  for row in range(2, rows):\n                      print >> output_writer, row_string.format("")\n              else:\n                  safe_cols -= 1\n                  print >> output_writer, row_string.format("c%s" % ("." * (safe_cols - 1)))\n                  print >> output_writer, row_string.format("." * safe_cols)\n                  print >> output_writer, row_string.format("...")\n                  for row in range(3, rows):\n                      print >> output_writer, row_string.format("")\n      if impossible:\n          print >> output_writer, IMPOSSIBLE\n  \n  def solve_inputs(input_reader, output_writer):\n      """\n      Loop through each problem input in input reader and solve it.\n  \n      Outputs responses to output_writer.\n      """\n      for input_values in parse_input(input_reader):\n          solve_problem(output_writer=output_writer, **input_values)\n  \n  def run_tests():\n      idx = 0\n      all_pass = True\n      for problem_input, expected_output in TEST_CASES:\n          idx += 1\n          input_reader = StringIO(problem_input)\n          output_writer = StringIO()\n          solve_inputs(input_reader, output_writer)\n          problem_output = output_writer.getvalue()\n          if problem_output == expected_output:\n              print "Test %d: Success" % idx\n          else:\n              all_pass = False\n              print "Test %d: Failure" % idx\n              print problem_output\n          input_reader.close()\n          output_writer.close()\n      if all_pass:\n          print "All tests were successful!"\n      else:\n          print "Something didn't match - try again."\n  \n  def main():\n      parser = OptionParser()\n      parser.add_option("-f", "--file",\n                        dest="filename_stem",\n                        help="read input from FILE.in and write to FILE.out",\n                        metavar="FILE")\n  \n      (options, args) = parser.parse_args()\n      if options.filename_stem:\n          print "Running in file mode."\n          input_reader = open("%s.in" % options.filename_stem, "r")\n          output_writer = open("%s.out" % options.filename_stem, "w")\n          solve_inputs(input_reader, output_writer)\n      else:\n          print "Running in test mode."\n          run_tests()\n  \n  if __name__ == "__main__":\n      main()\n <CODESPLIT> 26
 \n  tCase = int(sys.stdin.readline())\n  \n  def alien(frases,case):\n  	\n  	case = case.replace('(','[')\n  	case = case.replace(')',']')\n  	\n  	ER1 = re.compile(case, re.I)\n  	count = 0\n  	for frase in frases:\n  		if ER1.search(frase):\n  			count += 1\n  	return count\n  \n  \n  for i in xrange(tCase):	\n  	linha = sys.stdin.readline().split()\n  	P = int(linha[1])\n  	T = int(linha[2])\n  	list = []\n  	for j in range (3,len(linha)):\n  		list.append(int(linha[j]))\n  	list.sort(reverse=True)\n  	realT = T*3 - 2\n  	supT = realT - 2\n  	\n  	count = 0\n  	for item in list:\n  		if item >= realT:\n  			count += 1\n  		elif P > 0 and item >= supT and T >= 2:\n  			count += 1\n  			P -= 1\n  		elif P > 0 and item >= realT and T == 1:\n  			count += 1\n  			P -= 1\n  		elif T == 0:\n  			count += 1\n  		else:\n  			break\n  		\n  	print "Case #%d: %d" % (i+1, count)\n  	\n  	\n  \n <CODESPLIT> 27
 \n  \n  tCase = int(sys.stdin.readline())\n  \n  \n  def map(R, C, Bombs):\n  	m = [["." for x in xrange(C)] for x in xrange(R)]\n  	print Bombs\n  	m[R-1][C-1] = 'c'\n  	lastSkip = False\n  	for i in xrange(R):\n  		for j in xrange(C):\n  			if Bombs == 0:\n  				break\n  			\n  			if lastSkip:\n  				m[i][j] = 'f'\n  				continue\n  			\n  			if R - i == 2 or C - j == 2:\n  				if Bombs == 1:\n  					m[i][j] = 'f'\n  					lastSkip = True\n  					continue\n  			\n  				\n  			m[i][j] = '*'\n  			Bombs -= 1\n  			lastSkip = False\n  		lastSkip = False\n  				\n  	\n  	\n  	for line in m:\n  		for c in line:\n  			print c,\n  		print\n  		\n  		\n  def imprimir(m):\n  	for line in m:\n  		for c in line:\n  			print c,\n  		print\n  		\n  def map2(R, C, Bombs):\n  	m = [["." for x in xrange(C)] for x in xrange(R)]\n  	m[R-1][C-1] = 'c'\n  	lastSkip = False\n  	\n  	ii = 0\n  	jj = 0\n  	while Bombs > 0:\n  		for j in xrange(jj, C):\n  			if Bombs >= (C - j) or Bombs <= (C - j - 2) and Bombs > 0:\n  				m[ii][j] = '*'\n  				Bombs -= 1\n  			else:\n  				continue\n  		\n  		\n  		for i in xrange(ii+1, R):\n  			if Bombs >= (R - i) or Bombs <= (R - i - 2) and Bombs > 0:\n  				m[i][jj] = '*'\n  				Bombs -= 1\n  			else:\n  				if Bombs > 0:\n  					print "Impossible"\n  					return\n  				continue\n  		jj += 1\n  		ii += 1\n  	imprimir(m)\n  	\n  				\n  	\n  	\n  \n  		\n  def main(R, C, M):\n  	vazios = R * C - M\n  \n  	if R == 1 or C == 1 or vazios == 1 or vazios >= 4:\n  		map2(R, C, M)\n  	else:\n  		print "Impossible"\n  \n  	return ""\n  		\n   \n  if __name__ == '__main__':\n  	for i in xrange(tCase):	\n  		\n  		R, C, M = [int(x) for x in sys.stdin.readline().split(' ')]\n  		print "Case #%d:" % (i + 1)\n  		main(R, C, M)\n <CODESPLIT> 27
 \n  def solve(icase, case_input):\n      case_output = 'Case #%i: '%icase\n      \n      result = 0\n      raw = [int(x) for x in case_input[0].split()]\n      ts = raw[3:]\n      ct = raw[1]\n      n = raw[2]\n      cc = 0\n      for i in ts:\n          if i > 3*n-3:\n              result += 1\n          elif i > max(3*n-5, 0):\n              cc += 1\n      result += min(cc, ct)\n  \n      case_output += '%d'%result\n      \n      return case_output\n  \n  \n  def main():\n      global use_test_data\n      global test_data\n      global input_file\n      global output_file\n      \n      if use_test_data:\n          data = [x.strip() for x in test_data.split('\n')]\n      else:\n          data = [x.strip() for x in input_file.readlines()]\n      \n      T = int(data[0])\n      iLine = 1\n      caseLineNum = 1\n      for icase in range(1, T + 1):\n          input = []\n          for i in range(caseLineNum):\n              input.append(data[iLine])\n              iLine += 1\n          rslt = solve(icase, input)\n          print rslt\n          if not use_test_data:\n              print >> output_file, rslt\n      \n      if not use_test_data:\n          input_file.close()\n          output_file.close()\n      \n      \n  if __name__ == '__main__':\n      test_data = """4\n  3 1 5 15 13 11\n  3 0 8 23 22 21\n  2 1 1 8 0\n  6 2 8 29 20 8 18 18 21\n  """\n      use_test_data = False\n      \n      test_file = 'B-small-attempt0.in'\n      if not use_test_data and '' != test_file:\n          input_file = open(test_file)\n          output_file = open(test_file + '.out', 'w')\n      \n      main()\n <CODESPLIT> 28
 \n  class Solver(object):\n      def __init__(self):\n          pass\n      \n      def solve(self, inputs):\n          R, C, M = [int(x) for x in inputs[0].split()]\n          mp = []\n          for r in range(R):\n              mp.append(['.']*C)\n          mp[0][0] = 'c'\n          outputs = []\n          if M == 0:\n              for row in mp:\n                  outputs.append(''.join(row))\n              return outputs\n          rr, cc, rm = R, C, M\n          while rm >= min(rr, cc):\n              if rr <= cc:\n                  for r in range(rr):\n                      mp[r][cc-1] = '*'\n                  cc -= 1\n                  rm -= rr\n              else:\n                  for c in range(cc):\n                      mp[rr-1][c] = '*'\n                  rr -= 1\n                  rm -= cc\n          \n          if rm == 0:\n              if (min(rr, cc), max(rr, cc)) == (1, 2) and min(R, C) != 1:\n                  return ['Impossible']\n          else:\n              if min(rr, cc) - rm >= 2:\n                  if rr <= cc:\n                      for r in range(rr-rm, rr):\n                          mp[r][cc-1] = '*'\n                  else:\n                      for c in range(cc-rm, cc):\n                          mp[rr-1][c] = '*'\n              else:\n                  if min(rr, cc) >= 4:\n                      if rr <= cc:\n                          for r in range(2, rr):\n                              mp[r][cc-1] = '*'\n                          mp[rr-1][cc-2] = '*'\n                      else:\n                          for c in range(2, cc):\n                              mp[rr-1][c] = '*'\n                          mp[rr-2][cc-1]='*'\n                  elif min(rr,cc) == 3:\n                      if max(rr, cc) == 3:\n                          return ['Impossible']\n                      else:\n                          if rr <= cc:\n                              mp[2][cc-1] = '*'\n                              mp[2][cc-2] = '*'\n                          else:\n                              mp[rr-1][2] = '*'\n                              mp[rr-2][2] = '*'\n                  else:\n                      return ['Impossible']\n                      \n          for row in mp:\n              outputs.append(''.join(row))\n          return outputs\n          pass\n      \n      def feed(self, inputs):\n          lines = [x.strip() for x in inputs]\n          outputs = []\n          test_case_n = int(lines[0])\n          cur = 1\n          for i in range(test_case_n):\n              i = i\n              case_line_cnt = 1\n              case_inputs = lines[cur:cur+case_line_cnt]\n              cur += case_line_cnt\n              R, C, M = [int(x) for x in case_inputs[0].split()]\n              rslt = self.solve(case_inputs)\n              if self.verify(rslt, R, C, M):\n                  outputs.append(rslt)\n              else:\n                  raise 'Failed'\n          return outputs\n      \n      def verify(self, outputs, RR, CC, MCNT):\n          if 'Impossible' == outputs[0]:\n              return True\n          rr = len(outputs)\n          cc = len(outputs[0])\n          if RR != rr or CC != cc:\n              return False\n          bd = []\n          mask = []\n          for i in range(rr):\n              mask.append([1]*cc)\n              bd.append([0]*cc)\n              for j in range(cc):\n                  if outputs[i][j] == '*':\n                      bd[i][j] = 9\n                  elif outputs[i][j] == 'c':\n                      start = (i, j)\n          for r in range(rr):\n              for c in range(cc):\n                  if bd[r][c] == 9:\n                      for i in [r-1,r,r+1]:\n                          for j in [c-1,c,c+1]:\n                              if 0 <= i < rr and 0 <= j < cc:\n                                  if bd[i][j] != 9:\n                                      bd[i][j] += 1\n  \n          nlist = [start]\n          while len(nlist):\n              i, j = nlist.pop(0)\n              if mask[i][j] != 0:\n                  mask[i][j] = 0\n                  if bd[i][j] == 9:\n                      raise '!!! BOMB'\n                  elif bd[i][j] == 0:\n                      for ii in [i-1,i,i+1]:\n                          for jj in [j-1,j,j+1]:\n                              if 0<=ii<rr and 0<=jj<cc:\n                                  if ii != i or jj != j:\n                                      nlist.append((ii,jj))\n          mcnt = 0\n          for r in range(rr):\n              for c in range(cc):\n                  if mask[r][c] == 1:\n                      mcnt += 1\n                  if mask[r][c] == 1 and bd[r][c] != 9:\n                      return False\n                  if mask[r][c] != 1 and bd[r][c] == 9:\n                      return False\n          return (mcnt == MCNT)\n                  \n  \n  if __name__ == '__main__':\n      iname = 'C-small-attempt0.in'\n      sample_in = '''\n  7\n  5 5 23\n  3 1 1\n  2 2 1\n  4 7 3\n  10 10 82\n  3 4 0\n  2 2 3\n      '''\n      sample_out = '''\n  Case #1: 1.0000000\n  Case #2: 39.1666667\n  Case #3: 63.9680013\n  Case #4: 526.1904762\n      '''\n      if os.path.exists(iname):\n          with open(iname) as f:\n              inputs = f.readlines()\n      else:\n          inputs = [x.strip() for x in sample_in.split('\n') if x.strip()]\n      solver = Solver()\n      outputs = solver.feed(inputs)\n      fail_flag = False\n      if os.path.exists(iname):\n          with open(iname+'.out', 'w') as f:\n              for i, v in enumerate(outputs):\n                  print >> f, 'Case #%d:'%(i+1)\n                  print >> f, '\n'.join(v)\n      print '===================================================='\n      for i, v in enumerate(outputs):\n          print 'Case #%d:'%(i+1)\n          print '\n'.join(v)\n      print '===================================================='\n      print 'done' if not fail_flag else 'fail'\n      pass\n <CODESPLIT> 28
 \n  def readint():\n      return int(sys.stdin.readline())\n  \n  def readintarray():\n      return map(int, sys.stdin.readline().strip().split())\n  \n  def readpairs(start=0):\n      elems = readintarray()[start:]\n      return [elems[i:i+2] for i in xrange(0, len(elems), 2)]\n  \n  def readstring():\n      return sys.stdin.readline()[:-1]\n  \n <CODESPLIT> 29
 \n  \n  \n  directions = list(itertools.product([1, 0, -1], [1, 0, -1]))\n  def count_neighbors(table, r, c):\n      cols = len(table[0])\n      rows = len(table)\n      return sum(table[r + x][c + y] == "*" for x, y in directions \n                  if r + x >= 0 and c + y >= 0 and cols > c + y and rows > r + x)\n  \n  def is_valid(table):\n      cols = len(table[0])\n      rows = len(table)\n      for r in xrange(rows):\n          for c in xrange(cols):\n              has_zero = any(table[r + x][c + y] == 0 for x, y in directions \n                              if r + x >= 0 and c + y >= 0 and cols > c + y and rows > r + x)\n              if table[r][c] != "*" and not has_zero:\n                  return False\n  \n      return True\n  \n  \n  def draw_table(table, hide=False):\n      cols = len(table[0])\n      rows = len(table)\n      ascii_table = ""\n      for r in xrange(rows):\n          for c in xrange(cols):\n              if table[r][c] != "*":\n                  ch = "c" if r == 0 and c == 0 else "."\n                  table[r][c] = count_neighbors(table, r, c) if not hide else ch\n  \n              ascii_table += str(table[r][c])\n  \n          ascii_table += "\n"\n  \n      return ascii_table[:-1]\n  \n  def solve(R, C, M):\n      r = c = 0\n      current_mines = R * C\n      table = [["*"] * C for k in xrange(R)]\n      while M < current_mines:\n          if table[r][c] == '*':\n              table[r][c] = "."\n              current_mines -= 1\n  \n          if current_mines > M and r + 1 < R and table[r+1][c] == "*":\n              table[r+1][c] = "."\n              current_mines -= 1\n  \n          draw_table(table)\n          c += 1\n          if c >= C:\n              c = 0\n              r += 1\n  \n      return table\n  \n  for i in xrange(readint()):\n      R, C, M = readintarray()\n  \n      print "Case #%d:" % (i + 1)\n      if M < (R * C) - 1:\n          table = solve(R, C, M)\n          if is_valid(table):\n              print draw_table(table, hide=True)\n          else:\n              table = solve(C, R, M)\n              rotated = [["*"] * C for k in xrange(R)]\n              for r in xrange(R - 1, -1, -1):\n                  for c in xrange(C):\n                      rotated[R - r - 1][c] = table[c][r]\n  \n              print draw_table(rotated, hide=True) if is_valid(rotated) else "Impossible"\n  \n      elif M == R * C:\n          print "Impossible"\n  \n      else:\n          table = [["*"] * C for k in xrange(R)]\n          table[0][0] = '.'\n          print draw_table(table, hide=True)\n <CODESPLIT> 29
 \n  def testcases():\n      with open(sys.argv[1], "r") as f:\n          f.readline()  # skip number of testcases\n          for X, T in enumerate(f, 1):\n              yield X, [int(t) for t in T.split()]\n  \n  def main():\n      for X, T in testcases():\n          N = T[0]   # the number of Googlers\n          S = T[1]   # the number of surprising triplets of scores\n          p = T[2]   # best result of at least\n  \n          y = 0\n  \n          for t in T[3:]:\n              d, m = divmod(t, 3)\n              if m == 0:\n                  if p <= d:\n                      y += 1\n                  elif 0 <= d - 1 <= p <= d + 1 <= 10 and S:\n                      y += 1\n                      S -= 1\n              elif m == 1:\n                  if p <= d + 1:\n                      y += 1\n              else:\n                  if p <= d + 1:\n                      y += 1\n                  elif p <= d + 2 and S:\n                      y += 1\n                      S -= 1\n  \n          print("Case #{:d}: {:d}".format(X, y))\n  \n  if __name__=="__main__":\n      main()\n <CODESPLIT> 30
 \n  def debug(v):\n      pass#print(v)\n  \n  def read(f):\n      t = tuple(int(v) for v in f.readline().split())\n      debug(t)\n      return t\n  \n  def readf(f):\n      t = tuple(float(v) for v in f.readline().split())\n      debug(t)\n      return t\n  \n  def answer(f, X, ans):\n      out = "Case #{}:\n{}".format(X, ans)\n      f.write(out)\n      f.write("\n")\n      print(out)\n  \n  def answer_cells(f, X, cells):\n      out = "Case #{}:".format(X)\n      f.write(out)\n      f.write("\n")\n      print(out)\n      for row in cells:\n          out = "".join(row)\n          f.write(out)\n          f.write("\n")\n          print(out)\n  \n  def main(inf, outf):\n      T, = read(inf)\n      for casenmbr in range(1, T + 1):\n          R, C, M = read(inf)\n  \n          if M == 0:\n              cells = [['.'] * C for i in range(R)]\n              cells[0][0] = 'c'\n              answer_cells(outf, casenmbr, cells)\n              continue\n  \n          empty = R * C - M\n  \n          if empty == 1:\n              cells = [['*'] * C for i in range(R)]\n              cells[0][0] = 'c'\n              answer_cells(outf, casenmbr, cells)\n              continue\n  \n          if R == 1 or C == 1:\n              cells = [['.'] * C for i in range(R)]\n              m = 0\n              for r in range(R):\n                  for c in range(C):\n                      cells[r][c] = '*'\n                      m += 1\n                      if m == M:\n                          break\n                  else:\n                      continue\n                  break\n              cells[-1][-1] = 'c'\n              answer_cells(outf, casenmbr, cells)\n              continue\n  \n          if empty in (2, 3, 5, 7):\n              answer(outf, casenmbr, "Impossible")\n              continue\n  \n          if (R == 2 or C == 2) and empty % 2:\n              answer(outf, casenmbr, "Impossible")\n              continue\n  \n          cells = [['*'] * C for i in range(R)]\n  \n  \n          cells[0][0] = 'c'\n          empty -= 1\n          cc = 1\n          rr = 1\n          while empty > 0:\n              if cc < C:\n                  for r in range(rr):\n                      if empty == 2 and r == rr - 1:\n                          break\n                      cells[r][cc] = '.'\n                      empty -= 1\n                      if empty == 0:\n                          break\n                  cc += 1\n              if rr < R and empty > 0:\n                  for c in range(cc):\n                      if empty == 2 and c == cc - 1:\n                          break\n                      cells[rr][c] = '.'\n                      empty -= 1\n                      if empty == 0:\n                          break\n                  rr += 1            \n  \n          answer_cells(outf, casenmbr, cells)\n  \n  \n  if __name__=="__main__":\n      infname = sys.argv[1]\n      outfname = os.path.splitext(infname)[0] + ".out"\n      with open(infname, "r") as inf:\n          with open(outfname, "w") as outf:\n              main(inf, outf)\n <CODESPLIT> 30
inputFile = open("B-small-attempt0 (3).in", 'r')\n  outputFile = open("dancingOutSmall.txt", 'w')\n  numTests = int(inputFile.readline())\n  \n  def countDancers(n,s,p,totals):\n      guaranteed = 0\n      needSurprise = 0\n      if p == 1:\n          for total in totals:\n              if total != 0:\n                  guaranteed += 1\n          return guaranteed\n      for total in totals:\n          if total >= p*3 - 2:\n              guaranteed += 1\n          elif total >= p*3 - 4:\n              needSurprise += 1\n      if needSurprise > s:\n          return guaranteed + s\n      else:\n          return guaranteed + needSurprise\n  \n  for i in range(numTests):\n      line = inputFile.readline().split()\n      n = int(line[0])\n      s = int(line[1])\n      p = int(line[2])\n      totals = []\n      for j in range(n):\n          totals += [int(line[3+j])]\n      outputFile.write('Case #' + str(i+1) + ': ' + str(countDancers(n,s,p,totals)) + '\n')\n  \n  outputFile.close()\n <CODESPLIT> 31
inputFile = open('C-small-attempt8.in', 'r')\n  lines = inputFile.readlines()\n  inputFile.close()\n  \n  outputFile = open('C-small-attempt8.out', 'w')\n  \n  numTests = int(lines[0])\n  \n  for i in range(1, numTests+1):\n      [r, c, m] = map(lambda x: int(x), lines[i].split())\n  \n      openCells = r*c - m\n  \n      works = False\n      matrix = [['*']*c for j in range(r)]\n      if r >= 3 and c >= 3:\n          order = [(0,0), (0,1), (1,0), (1,1), (0,2), (1,2),\n                   (2,0), (2,1)]\n          if openCells == 1 or openCells == 4 or openCells == 6:\n              works = True\n              for (x,y) in order[:openCells]:\n                  matrix[x][y] = '.'\n              matrix[0][0] = 'c'\n              \n          elif openCells >= 8:\n              works = True\n              filledRows = openCells / c\n              if filledRows >= 2:\n                  if filledRows == r:\n                      matrix = [['.']*c for j in range(r)]\n                      matrix[0][0] = 'c'\n                  else:\n                      remainder = openCells%c\n                      if not remainder == 1:\n                          for j in range(filledRows):\n                              matrix[j] = ['.']*c\n                          matrix[filledRows] = ['.']*remainder + ['*'] * (c-remainder)\n                      elif filledRows > 2:\n                          for j in range(filledRows-1):\n                              matrix[j] = ['.']*c\n                          matrix[filledRows-1] = ['.']*(c-1) + ['*']\n                          matrix[filledRows] = ['.', '.'] + ['*']*(c-2)\n                      else:\n                          matrix[0] = ['.']*(c-1) + ['*']                        \n                          matrix[1] = ['.']*(c-1) + ['*']\n                          matrix[2] = ['.', '.', '.'] + ['*']*(c-3)\n                      matrix[0][0] = 'c'\n                  \n              else:\n                  for (x,y) in order:\n                      matrix[x][y] = '.'\n                  remainingOpen = openCells - 8\n                  if remainingOpen % 2 == 0:\n                      for j in range(remainingOpen/2):\n                          matrix[0][j+3] = '.'\n                          matrix[1][j+3] = '.'\n                  else:\n                      matrix[2][2] = '.'\n                      remainingOpen -= 1\n                      for j in range(remainingOpen/2):\n                          matrix[0][j+3] = '.'\n                          matrix[1][j+3] = '.'\n                  matrix[0][0] = 'c'\n  \n      elif r == 1:\n          works = True\n          matrix[0] = ['.']*(c-m) + ['*']*m\n          matrix[0][0] = 'c'\n      elif c == 1:\n          works = True\n          for j in range(r-m):\n              matrix[j][0] = '.'\n          matrix[0][0] = 'c'\n  \n      elif r == 2 and c == 2:\n          if m == 3:\n              works = True\n              matrix[0][0] = 'c'\n          elif m == 0:\n              works = True\n              matrix = [['c', '.'], ['.', '.']]\n      elif r == 2:\n          if m % 2 == 0 and r*c-m > 2:\n              works = True\n              matrix[0] = ['.']*(c-m/2) + ['*']*(m/2)\n              matrix[1] = ['.']*(c-m/2) + ['*']*(m/2)\n              matrix[0][0] = 'c'\n          elif r*c-m == 1:\n              works = True\n              matrix[0][0] = 'c'\n      elif c == 2:\n          if m % 2 == 0 and r*c-m > 2:\n              works = True\n              for j in range((r*c-m)/2):\n                  matrix[j] = ['.', '.']\n              matrix[0][0] = 'c'\n          elif r*c-m == 1:\n              works = True\n              matrix[0][0] = 'c'\n      \n  \n      outputFile.write('Case #'+str(i)+':\n')\n      '''if len(matrix) != r:\n          print i, matrix\n      count = 0\n      for j in range(len(matrix)):\n          for k in range(len(matrix[j])):\n              if matrix[j][k] == '*':\n                  count += 1\n      if count != m:\n          print i, matrix'''\n      if not works:\n          outputFile.write('Impossible\n')\n      else:\n          for x in range(len(matrix)):\n              for y in range(len(matrix[0])):\n                  outputFile.write(matrix[x][y])\n              outputFile.write('\n')\n  outputFile.close()\n              \n <CODESPLIT> 31
 \n  \n  if __name__ == "__main__":\n  \n      f = open( "B-small-attempt1.in.txt" )\n      g = open( "output_small.txt", "w" )\n  \n      f.readline()\n      line = f.readline()\n      caseI = 1\n      while line != "":\n          line = [ int(x) for x in line.split() ]\n          N = line[0]\n          surprise = line[1]\n          p = line[2]\n          points = line[3:]\n          points.sort()\n          points.reverse()\n  \n          maxp = 0\n          either = 0\n          make_surprise = 0\n          for x in points:\n              this_p = (x+2)/3\n              if x in [0,1,29,30]:\n                  if this_p >= p:\n                      maxp += 1\n              elif this_p >= p:\n                  either += 1\n                  maxp += 1\n              elif this_p == p-1 and (x+2)%3 > 0:\n                  make_surprise += 1\n              else:\n                  either += 1\n  \n          if make_surprise >= surprise:\n              make_surprise -= surprise\n              maxp += surprise\n              make_surprise = 0\n          else:\n              maxp += make_surprise\n  \n          g.write( "Case #%s: %s\n"%(caseI,maxp) )\n  \n          line = f.readline()\n          caseI += 1\n  \n      f.close()\n      g.close()\n      \n <CODESPLIT> 32
 \n  def makeBoardR(b):\n  	numR, numC, numMines, filledR, filledC = b\n  	q = numMines / numR\n  	r = numMines % numR\n  \n  	if q <= numC-2 and r == 0:\n  		board = ["*"*(filledC + numC) for x in range (filledR)]\n  		board.append( "*"*(filledC+q)+"."*(numC-q) )\n  		board.append( "*"*(filledC+q)+"."*(numC-q-1)+"c" )\n  		output = "\n".join(board)\n  	elif numMines == numR * numC - 1:\n  		board = ["*"*(filledC + numC) for x in range (filledR+1)]\n  		board.append( "*"*(filledC+numC-1)+"c" )\n  		output = "\n".join(board)\n  	else:\n  		output = "Impossible"\n  \n  	return output\n  \n  def makeBoardC(b):\n  	numR, numC, numMines, filledR, filledC = b\n  	q = numMines / numC\n  	r = numMines % numC\n  \n  	if q <= numR-2 and r == 0:\n  		board = ["*"*(filledC+numC) for x in range(filledR+q)]\n  		for x in range( numR-1-q ):\n  			board.append( "*"*filledC + ".." )\n  		board.append( "*"*filledC + ".c" )\n  		output = "\n".join(board)\n  	elif numMines == numR * numC - 1:\n  		board = ["*"*(filledC+numC) for x in range(filledR+numR-1)]\n  		board.append( "*"*(filledC+numC-1) + "c" )\n  		output = "\n".join(board)\n  	else:\n  		output = "Impossible"\n  	return output\n  \n  def makeBoard(b):\n  	numR, numC, numMines, filledR, filledC = b\n  	q = numMines / (numC-2)\n  	r = numMines % (numC-2)\n  \n  	board = ["*"*(numC+filledC) for x in range(filledR)]\n  	for x in range(q):\n  		board.append( "*"*(numC-2+filledC)+".." )\n  	board.append( "*"*(r+filledC)+"."*(numC-r) )\n  	for x in range(numR-q-2):\n  		board.append( "*"*filledC+"."*numC )\n  	board.append( "*"*filledC + "."*(numC-1) + "c" )\n  	return "\n".join(board)\n  \n  def makeBoard0(b):\n  	numR,numC,numMines,filledR,filledC = b\n  	board = ["*"*(numC+filledC) for x in range(filledR)]\n  	for x in range(numR-1):\n  		board.append( "*"*(filledC)+"."*numC )\n  	board.append( "*"*(filledC) + "."*(numC-1) + "c" )\n  	return "\n".join(board)\n  \n  f = open( sys.argv[1] )\n  f.readline()\n  \n  numCase = 1\n  l = f.readline()\n  while l != "":\n  	numR, numC, numMines = [int(x) for x in l.split()]\n  \n  	boards = deque()\n  	if numR == 1:\n  		if numC == 1 and numMines == 0:\n  			output = "c"\n  		elif numC == 1 and numMines > 0:\n  			output = "Impossible"\n  		else:\n  			output = "*"*numMines + "."*(numC-numMines-1) + "c"\n  	elif numC == 1:\n  		output = "\n".join("*"*numMines + "."*(numR-numMines-1) + "c")\n  	else:\n  		boards.append( (numR,numC,numMines,0,0) )\n  		output = "Impossible"\n  \n  	while output == "Impossible" and len(boards) > 0:\n  		b = boards.popleft()\n  		numR,numC,numMines,filledR,filledC = b\n  		if numMines == 0:\n  			output = makeBoard0(b)\n  			break\n  \n  		if numMines >= numC and numR > 2:\n  			boards.append( (numR-1,numC,numMines-numC,filledR+1,filledC) )\n  		if numMines >= numR and numC > 2:\n  			boards.append( (numR,numC-1,numMines-numR,filledR,filledC+1) )\n  \n  		if numMines <= (numR-2)*(numC-2):\n  			output = makeBoard(b)\n  \n  		if numR == 2:\n  			output = makeBoardR(b)\n  \n  		if numC == 2:\n  			output = makeBoardC(b)\n  		\n  	print "Case #"+str(numCase)+":\n"+output\n  	l = f.readline()\n  	numCase += 1\n <CODESPLIT> 32
 \n  T = int(sys.stdin.readline())\n  for i in range(T):\n      line = sys.stdin.readline().strip()\n      values = map(int, line.split(' '))\n      N = values[0]\n      S = values[1]\n      p = values[2]\n      totals = values[3:]\n      ans = 0\n      for total in totals:\n          base = total / 3\n          remainder = total - (base * 3)\n          scores = [base, base, base]\n          j = 0\n          while remainder > 0:\n              scores[j] += 1\n              remainder -= 1\n              j = (j + 1) % 3\n          if max(scores) >= p:\n              ans += 1\n          else:\n              if S > 0:\n                  remainder = total - (base * 3)\n                  if remainder == 0 and base > 0:\n                      if base + 2 >= p:\n                          ans += 1\n                          S -= 1\n                  elif base + min(remainder, 2) >= p:\n                      ans += 1\n                      S -= 1\n      print 'Case #%s: %s' % (i+1, ans)\n <CODESPLIT> 33
 \n  def solve(W, H, M):\n    board = [['*' for x in xrange(H)] for x in xrange(W)]\n    board[0][0] = 'c'\n    \n    S = [((H*W)-1, board, 0, 0, set())]\n    H -= 1\n    W -= 1\n    while len(S) > 0:\n      state = S.pop()\n      mines = state[0]\n      board = deepcopy(state[1])\n      x = state[2]\n      y = state[3]\n      visited = deepcopy(state[4])\n      visited.add((x, y))\n      \n      if mines == M:\n        s = ''\n        for row in board:\n          s += ''.join(row)\n          s += '\n'\n        return s\n      \n      elif mines > M:\n        if x > 0 and board[x-1][y] == '*':\n          board[x-1][y] = '.'\n          mines -= 1\n        \n        if x < W and board[x+1][y] == '*':\n          board[x+1][y] = '.'\n          mines -= 1\n        \n        if y > 0 and board[x][y-1] == '*':\n          board[x][y-1] = '.'\n          mines -= 1\n        \n        if y < H and board[x][y+1] == '*':\n          board[x][y+1] = '.'\n          mines -= 1\n        \n        if x > 0 and y > 0 and board[x-1][y-1] == '*':\n          board[x-1][y-1] = '.'\n          mines -= 1\n        \n        if x > 0 and y < H and board[x-1][y+1] == '*':\n          board[x-1][y+1] = '.'\n          mines -= 1\n        \n        if x < W and y > 0 and board[x+1][y-1] == '*':\n          board[x+1][y-1] = '.'\n          mines -= 1\n        \n        if x < W and y < H and board[x+1][y+1] == '*':\n          board[x+1][y+1] = '.'\n          mines -= 1\n        \n        if x > 0 and not (x-1, y) in visited:\n          S.append((mines, board, x-1, y, visited))\n        \n        if x < W and not (x+1, y) in visited:\n          S.append((mines, board, x+1, y, visited))\n        \n        if y > 0 and not (x, y-1) in visited:\n          S.append((mines, board, x, y-1, visited))\n        \n        if y < H and not (x, y+1) in visited:\n          S.append((mines, board, x, y+1, visited))\n        \n        if x > 0 and y > 0 and not (x-1, y-1) in visited:\n          S.append((mines, board, x-1, y-1, visited))\n        \n        if x > 0 and y < H and not (x-1, y+1) in visited:\n          S.append((mines, board, x-1, y+1, visited))\n        \n        if x < W and y > 0 and not (x+1, y-1) in visited:\n          S.append((mines, board, x+1, y-1, visited))\n        \n        if x < W and y < H and not (x+1, y+1) in visited:\n          S.append((mines, board, x+1, y+1, visited))\n    return 'Impossible'\n  \n  T = int(raw_input())\n  for t in range(T):\n    W, H, M = map(int, raw_input().split())\n    print 'Case #%i:\n%s' % (t+1, solve(W, H, M).strip())\n <CODESPLIT> 33
 \n  \n  poss = dict([(i, {}) for i in xrange(0, 30 + 1)])\n  for a, b, c in itertools.product(range(10 + 1), repeat=3):\n      if a <= b <= c and c - a <= 2:\n          n = a + b + c\n          if c - a == 2:\n              poss[n]['s'] = tuple(sorted((a, b, c)))\n          else:\n              poss[n]['n'] = tuple(sorted((a, b, c)))\n  \n  \n  T = int(raw_input())\n  for case in xrange(1, T + 1):\n      div = map(int, raw_input().split())\n      N, S, p = div[:3]\n      t = div[3:]\n  \n      ans = 0\n      t.sort(reverse=True)\n      for i in xrange(len(t)):\n          na, nb, nc = poss[t[i]]['n']\n          sa, sb, sc = poss[t[i]].get('s', (-1, -1, -1))\n          if p <= nc:\n              ans += 1\n          elif 0 < S and p <= sc:\n              ans += 1\n              S -= 1\n  \n      print 'Case #%d: %d' % (case, ans)\n  \n <CODESPLIT> 34
 \n  T = int(raw_input())\n  for test_case in xrange(1, T + 1):\n      R, C, M = map(int, raw_input().split())\n      N = R * C\n      B = N - M\n  \n      W, H = (C, R) if R <= C else (R, C)\n  \n      if H == 1:\n          answer = [['c'] + ['.'] * (B - 1) + ['*'] * M]\n      elif M == N - 1:\n          answer = [['*'] * W for r in xrange(H)]\n          answer[0][0] = 'c'\n      elif B < 4 or B in (5, 7):\n          answer = None\n      elif H == 2:\n          if M % 2 == 0:\n              bw = B / 2\n              answer = [\n                  ['c'] + ['.'] * (bw - 1) + ['*'] * (W - bw),\n                  ['.'] * bw + ['*'] * (W - bw),\n              ]\n          else:\n              answer = None\n      else:\n          answer = [['*'] * W for y in xrange(H)]\n          answer[0][0] = 'c'\n          answer[0][1] = answer[1][0] = answer[1][1] = '.'\n          left = B - 4\n          if 2 <= left:\n              answer[0][2] = answer[1][2] = '.'\n              left -= 2\n          if 2 <= left:\n              answer[2][0] = answer[2][1] = '.'\n              left -= 2\n  \n          x = y = 3\n          while (x < W or y < H) and 2 <= left:\n              if x < W and 2 <= left:\n                  answer[0][x] = answer[1][x] = '.'\n                  left -= 2\n                  x += 1\n              if y < H and 2 <= left:\n                  answer[y][0] = answer[y][1] = '.'\n                  left -= 2\n                  y += 1\n  \n          y = 2\n          while 0 < left and y < H:\n              x = 2\n              while 0 < left and x < W:\n                  answer[y][x] = '.'\n                  left -= 1\n                  x += 1\n              y += 1\n  \n      if answer is None:\n          answer = 'Impossible'\n      else:\n          if W == R:\n              answer = map(list, zip(*answer))\n          assert len(answer) == R\n          assert len(answer[0]) == C\n          assert sum(row.count('*') for row in answer) == M\n          answer = '\n'.join([''.join(row) for row in answer])\n      print 'Case #{}:\n{}'.format(test_case, answer)\n <CODESPLIT> 34
n_cases = input()\n  \n  for case in xrange(1, n_cases + 1):\n      ins = map(int, raw_input().strip().split())\n      n = ins[0]\n      s = ins[1]\n      p = ins[2]\n      t = ins[3:]\n  \n      out = 0\n      for x in t:\n          if (x + 2) / 3 >= p:\n              out += 1\n          elif s and x > p and p - ((x - p) / 2) <= 2:\n              out += 1\n              s -= 1\n              \n      print "Case #%d: %s" % (case, out)\n <CODESPLIT> 35
 if len(sys.argv) == 1:\n      sys.stdin = open("C.in")\n  else:\n      sys.stdin = open(sys.argv[1])\n  \n  def to_ints(s):\n      return map(int, s.split())\n  \n  def get_ints():\n      return to_ints(raw_input())\n  \n  sys.setrecursionlimit(4000)\n  \n  def fill(rows, cols, mines):\n      seen = set()\n      visited = set()\n  \n      def search(numbered, zeros, min_numbered):\n          left = (rows * cols - mines) - len(numbered)\n          if left == 0:\n              raise StopIteration((numbered, zeros))\n          if left < 0:\n              return\n          for n in xrange(min_numbered, len(numbered)):\n              number = numbered[n]\n              if number in zeros:\n                  continue\n              row, col = number\n              neigh = []\n              if row > 0:\n                  if col > 0: neigh.append((row - 1, col - 1))\n                  neigh.append((row - 1, col))\n                  if col < cols - 1: neigh.append((row - 1, col + 1))\n              if col > 0: neigh.append((row, col - 1))\n              if col < cols - 1: neigh.append((row, col + 1))\n              if row < rows - 1:\n                  if col > 0: neigh.append((row + 1, col - 1))\n                  neigh.append((row + 1, col))\n                  if col < cols - 1: neigh.append((row + 1, col + 1))\n              neigh = list(set(neigh) - set(numbered))\n              zeros.add(number)\n              search(numbered + neigh, zeros, n + 1)\n              zeros.remove(number)\n  \n      try:\n          for row in xrange(rows):\n              for col in xrange(cols):\n                  search([(row, col)], set(), 0)\n      except StopIteration, e:\n          numbered, zeros = e.message\n          board = {}\n          for row, col in numbered + list(zeros):\n              board[row, col] = '.'\n          if zeros:\n              board[zeros.pop()] = 'c'\n          else: # case where first click is on a number\n              board[0, 0] = 'c'\n          out = ''\n          for row in xrange(rows):\n              for col in xrange(cols):\n                  out += board.get((row, col), '*')\n              out += '\n'\n          return out.strip()\n      return 'Impossible'\n  \n  n_cases = input()\n  for case in xrange(1, n_cases + 1):\n      rows, cols, mines = get_ints()\n  \n      result = fill(rows, cols, mines)\n  \n      print "Case #%d:" % case\n      print result\n <CODESPLIT> 35
def read_line():\n      return raw_input().strip()\n  \n  def read_words():\n      return read_line().split()\n  \n  def read_integer():\n      return int( read_line() )\n  \n  def read_integers():\n      return [ int( x ) for x in read_words() ]\n  \n  T = read_integer()\n  for t in range( T ):\n      print 'Case #%i:' % ( t + 1 ),\n      line = iter( read_integers() )\n      N = line.next()\n      S = line.next()\n      p = line.next()\n      t = sorted( line )\n      count = 0\n      while t and ( t[ -1 ] + 2 )/3 >= p:\n          t.pop()\n          count += 1\n      if p > 1:\n          while S and t and ( t[ -1 ] + 4 )/3 >= p:\n              t.pop()\n              S -= 1\n              count += 1\n      print count\n <CODESPLIT> 36
 \n  def read_line():\n      return sys.stdin.readline().rstrip( '\n' )\n  \n  def read_integer():\n      return int( read_line() )\n  \n  def read_integers():\n      return [ int( x ) for x in read_line().split() ]\n  \n  def flip( grid ):\n      return [ bytearray( ''.join( chr( grid[ row ][ column ] ) for row in range( len( grid ) ) ) ) for column in range( len( grid[ 0 ] ) ) ]\n  \n  def grow( R, C, M ):\n      grid = [ bytearray( C*[ '*' ] ) for row in range( R ) ]\n      b = R*C - M\n      if C > R:\n          R, C, grid = C, R, flip( grid )\n          flipped = True\n      else:\n          flipped = False\n      if b < 2*C:\n          if b == 1:\n              grid[ 0 ][ 0 ] = 'c'\n          elif b == 3 and C >= 3:\n              grid[ 0 ][ : 3 ] = bytearray( '.c.' )\n          elif b % 2:\n              return\n          else:\n              grid[ 0 ][ : b//2 ] = bytearray( b//2*'.' )\n              grid[ 1 ][ : b//2 ] = bytearray( b//2*'.' )\n              grid[ 0 ][ 0 ] = 'c'\n      else:\n          r = 0\n          while b >= C:\n              grid[ r ] = bytearray( C*[ '.' ] )\n              b -= C\n              r += 1\n          if b:\n              if b >= 2:\n                  grid[ r ][ : b ] = b*'.'\n              elif C > 2 and r > 2:\n                  grid[ r - 1 ][ -1 ] = '*'\n                  grid[ r ][ : 2 ] = '..'\n              else:\n                  return\n          grid[ 0 ][ 0 ] = 'c'\n      return flip( grid ) if flipped else grid\n      \n  T = read_integer()\n  for t in range( T ):\n      print 'Case #%i:' % ( t + 1 )\n      R, C, M = read_integers()\n      grid = grow( R, C, M )\n      print '\n'.join( str( row ) for row in grid ) if grid else 'Impossible'\n <CODESPLIT> 36
"""\n  Google Code Jam 2012 Problem B\n  Usage:\n      python problem_b.py < input.txt > output.txt\n  """\n  \n  \n  def calc_possible(n):\n      combinations = itertools.combinations_with_replacement(range(n), 3)  # 3 scores\n      return itertools.ifilter(lambda (x, y, z): x + y + z == n, combinations)\n  \n  \n  def calc_surprising(n):\n      results = list(itertools.ifilter(lambda scores: max(scores) - min(scores) == 2, calc_possible(n)))\n      return results[0] if results else None\n  \n  \n  def calc_normal(n):\n      results = list(itertools.ifilter(lambda scores: max(scores) - min(scores) <= 1, calc_possible(n)))\n      return results[0] if results else None\n  \n  \n  def solve_problem():\n      number_of_cases = int(sys.stdin.readline())\n  \n      for i in xrange(1, number_of_cases + 1):\n  \n          case = sys.stdin.readline().strip()\n          result = 0\n          num_of_googlers, num_of_surprising, desired_score, scores = case.split(' ', 3)\n          num_of_googlers = int(num_of_googlers)\n          num_of_surprising = int(num_of_surprising)\n          desired_score = int(desired_score)\n          scores = map(int, scores.split())\n  \n          possible_scores = []\n  \n          for k in xrange(num_of_googlers):\n  \n              normal = calc_normal(scores[k])\n              surprising = calc_surprising(scores[k])\n  \n              possible_scores.append(((normal if normal else (0, 0, 0), 0), (surprising if surprising else (0, 0, 0), 1)))\n  \n          possible = list(itertools.ifilter(lambda scores: sum(map(lambda x: x[1], scores)) == num_of_surprising, itertools.product(*possible_scores)))\n          result = max(map(lambda scores: sum(map(lambda x: int(max(x[0]) >= desired_score), scores)) if scores else 0, possible))\n  \n          sys.stdout.write('Case #{0}: {1}\n'.format(i, result))\n  \n  \n  if __name__ == '__main__':\n      solve_problem()\n <CODESPLIT> 37
"""\n  Google Code Jam 2014 Qualification Problem C\n  Usage:\n      python c.py < input.txt > output.txt\n  """\n  \n  \n  def iter_neighbors(x, y, cells):\n      columns = len(cells[0])\n      rows = len(cells)\n  \n      if y > 0:\n          if x > 0:\n              yield x - 1, y - 1\n          yield x, y - 1\n  \n          if x + 1 < columns:\n              yield x + 1, y - 1\n  \n      if x > 0:\n          yield x - 1, y\n  \n      if x + 1 < columns:\n          yield x + 1, y\n  \n      if y + 1 < rows:\n          if x > 0:\n              yield x - 1, y + 1\n  \n          yield x, y + 1\n  \n          if x + 1 < columns:\n              yield x + 1, y + 1\n  \n  \n  def try_to_click(x, y, cells, remaining):\n      if remaining == 0:\n          return cells\n  \n      recent = []\n  \n      opened = 0\n  \n      for n_x, n_y in iter_neighbors(x, y, cells):\n          if cells[n_y][n_x] == "?":\n              cells[n_y][n_x] = "."\n              opened += 1\n              recent.append((n_x, n_y))\n  \n      if opened == remaining:\n          return cells\n  \n      if opened > remaining:\n          return []\n  \n      for n_x, n_y in recent:\n          solution = try_to_click(n_x, n_y, copy.deepcopy(cells), remaining - opened)\n          if solution:\n              return solution\n  \n      return []\n  \n  \n  def solve_problem(rows, columns, mines):\n  \n      for x in xrange(columns):\n          for y in xrange(rows):\n              cells = [["?" for i in xrange(columns)] for j in xrange(rows)]\n              cells[y][x] = "c"\n              solution = try_to_click(x, y, cells, rows * columns - mines - 1)\n  \n              if solution:\n                  return "\n".join(["".join(row) for row in solution]).replace("?", "*")\n  \n      return "Impossible"\n  \n  \n  if __name__ == "__main__":\n      num_of_cases = int(sys.stdin.readline().strip())\n      for i in xrange(1, num_of_cases + 1):\n  \n          rows, columns, mines = map(int, sys.stdin.readline().strip().split())\n  \n          print "Case #{0}:\n{1}".format(i, solve_problem(rows, columns, mines))\n <CODESPLIT> 37
 \n  f = open(sys.argv[1])\n  T = int(f.readline())\n  for t in range(T):\n      temp = map(int, f.readline().split())\n      N = temp[0]\n      S = temp[1]\n      p = temp[2]\n      scores = temp[3:]\n      non_surprising_scores = len(filter(lambda x: x >= (3*p-2), scores))\n      if (p<=1):\n          surprising_scores = 0\n      else:\n          surprising_scores = len(filter(lambda x: (x >= (3*p-4) and x < (3*p-2)), scores))\n      num_scores = non_surprising_scores + min(surprising_scores, S)   \n      print "Case #%d:" % (t + 1), num_scores\n <CODESPLIT> 38
 \n  f = open(sys.argv[1])\n  T = int(f.readline())\n  for test in range(T):\n      R, C, M = map(int, f.readline().strip().split())\n      Rorig = R\n      Corig = C\n      impossible = False\n      grid = [['.' for i in range(C)] for j in range(R)]\n  \n      curr_coord = [0,0]\n      while M > 0 and not impossible:\n          if (C > R): # more columns - fill one in\n              num_mines_in_column = R\n              if M < R:\n                  num_mines_in_column = min(R - 2, M)\n              if num_mines_in_column <= 0:\n                  impossible = True\n                  break\n              for ii in range(num_mines_in_column):\n                  grid[curr_coord[0] + ii][curr_coord[1]] = '*'\n              C -= 1\n              curr_coord[1] += 1\n              M -= num_mines_in_column\n          else:\n              num_mines_in_row = C\n              if M < C:\n                  num_mines_in_row = min(C - 2, M)\n              if num_mines_in_row <= 0:\n                  impossible = True\n                  break\n              for ii in range(num_mines_in_row):\n                  grid[curr_coord[0]][curr_coord[1] + ii] = '*'\n              R -= 1\n              curr_coord[0] += 1\n              M -= num_mines_in_row\n  \n      print "Case #%d:" % (test + 1)\n      if impossible:\n          print "Impossible"\n      else:\n          for ii in range(Rorig):\n              for jj in range(Corig):\n                  if grid[ii][jj] == '.':\n                      if ii - 1 >= 0 and grid[ii-1][jj] == '*':\n                          grid[ii][jj] = 'dirty'\n                      elif jj - 1 >= 0 and grid[ii][jj-1] == '*':\n                          grid[ii][jj] = 'dirty'\n                      elif jj - 1 >= 0 and ii - 1 >= 0 and grid[ii-1][jj-1] == '*':\n                          grid[ii][jj] = 'dirty'\n  \n          for ii in range(Rorig):\n              for jj in range(Corig):\n                  if grid[ii][jj] == 'dirty':\n                      if ii + 1 < Rorig and grid[ii+1][jj] == '.':\n                          grid[ii][jj] = '.'\n                      elif jj + 1 < Corig and grid[ii][jj+1] == '.':\n                          grid[ii][jj] = '.'\n                      elif jj + 1 < Corig and ii + 1 < Rorig and grid[ii+1][jj+1] == '.':\n                          grid[ii][jj] = '.'\n                      else:\n                          if ii != Rorig - 1 or jj != Corig - 1:\n                              impossible = True\n  \n          if impossible:\n              print "Impossible"\n          else:\n              grid[Rorig-1][Corig-1] = 'c'\n  \n              for ii in range(Rorig):\n                  print " ".join([val for val in grid[ii]])\n  \n  \n <CODESPLIT> 38
 """\n  GCJ framework (gcj.fw.framework)\n   - Command Line and Package interface\n   - output redirection\n   - parsing case input\n   - executing problem code against cases\n   - testing framework\n  """\n  \n  class Framework(object):\n      class Case(object):\n          def __init__(self, caseNumber, caseData=None):\n              self.number = caseNumber\n              self.data = caseData\n              self.result = None\n      \n          @classmethod\n          def parser(cls, f_in):\n              pass\n      \n          def run(self):\n              pass\n      \n          def execute(self, f_in=None):\n              if self.data is None:\n                  self.data = self.parser(f_in)\n              self.result = self.run(**self.data)\n      \n          def __str__(self):\n              return "Case #%d: %s" % (self.number, self.result)\n      \n      \n      class Result(object):\n          def __init__(self, resultData):\n              self.data = resultData\n      \n          def __str__(self):\n              return str(self.ata)\n  \n      def __init__(self, f_in, f_out):\n          sys.stdout = f_out\n          self.f_in = f_in if f_in is not None else sys.stdin\n  \n      def run(self):\n          nCases = int(self.f_in.readline().strip())\n          for num in xrange(nCases):\n              case = type(self).Case(num+1)\n              case.execute( f_in=self.f_in)\n              print case\n  \n  \n      @classmethod\n      def __main__(cls):\n          f_in = sys.stdin\n          if len(sys.argv) > 1:\n              if sys.argv[1] == "-t":\n                  unittest.main()\n                  sys.exit()\n              f_in = open(sys.argv[1])\n          framework = cls(f_in, sys.stdout)\n          framework.run()\n      \n  class Test(unittest.TestCase):\n      cases = []\n      case = None\n      c=[]\n      \n      def setUp(self):\n          self.c = []\n          self.defineCases()\n          counter = 1\n          self.cases = []\n          for c in self.c:\n              case = self.case(counter)\n              case.data = case.parser(StringIO.StringIO(c[0]))\n              self.cases.append( [case, c[1]])\n      \n      def defineCases(self):\n          pass\n      \n      def tearDown(self):\n          pass \n  \n      def test_Name(self):\n          self.setUp()\n          for case in self.cases:\n              print case[0].data, case[1]\n              case[0].execute()\n              self.assertEqual(case[0].result, case[1])\n  '''\n  Created on Apr 8, 2012\n  \n  @author: Joe\n  '''\n  \n  \n  class B(Framework):\n      class Case(Framework.Case):\n          def parser(self, fh):\n              args = map(int, fh.readline().strip().split(" "))\n              N,S,p = args[:3]\n              scores = args[3:] \n              return {"N":N,"S":S,"p":p,"scores":scores}\n          \n          def run(self, N=None,S=None,p=None,scores=None):\n              ret = 0\n              surps = 0\n              for score in scores:\n                  if p > 0 and score == 0: continue\n                  if 3*p-2 <= score:\n                      ret += 1\n                  else:\n                      if 3*p - 4 <= score:\n                          surps += 1\n              return str(ret + min(surps,S))\n              \n  class Test(Test):\n      def defineCases(self):\n          self.case = B.Case\n          self.c = [\n                    ["3 1 5 15 13 11","3"],\n                    ["3 0 8 23 22 21","2"],\n                    ["2 1 1 8 0","1"],\n                    ["6 2 8 29 20 8 18 18 21","3"],\n                    ["1 1 1 1", "1"]\n                    ]\n  \n  if __name__ == "__main__":\n      B.__main__()\n      \n <CODESPLIT> 39
__author__ = 'jrokicki'\n  \n  RL = lambda: sys.stdin.readline().strip()\n  IA = lambda: map(int, RL().split(" "))\n  LA = lambda: map(long, RL().split(" "))\n  FA = lambda: map(float, RL().split(" "))\n  \n  T = int(sys.stdin.readline())\n  \n  def clear(R,C,b, x, y):\n      b = b[:]\n      n = 0\n      for i in range(max(0,x-1), min(R,x+2)):\n          for j in range(max(0,y-1), min(C, y+2)):\n              if b[C*i+j] == '*':\n                  n += 1\n                  b = b[:C*i+j] + '.' + b[C*i+j+1:]\n      return b, n\n  mem = dict()\n  def pb(R,C,b):\n      for x in range(R):\n          print b[x*C:x*C+C]\n  \n  def board(R,C,b,x,y,M,m):\n      global mem\n      print x\n      key = (R,C,b,M,x,y,m)\n      if key in mem: return mem[key]\n      if x >= R or y >= C:\n          mem[key] = None\n      else:\n          lb = b\n          n = 0\n          good = False\n          for i in range(y,C):\n              nb,nn = clear(R,C, lb, x, i)\n              n += nn\n              if m - n - M == 0:\n                  mem[key] = nb\n                  good = True\n                  break\n              elif m - n - M < 0:\n                  break\n              lb = bb\n          mem[key] = board(R,C,bb,M,x+1,0,m-n)\n      return mem[key]\n  \n  for CASE in range(T):\n      R,C,M = IA()\n      IMPOSSIBLE = "Impossible"\n  \n      b = ""\n      cleared = R*C-M\n      for x in range(R):\n          b += "*" * C\n      if M == R*C-1:\n          b = "c" + b[1:]\n          answer = b\n      else:\n          good = False\n          x,y = 0,0\n          q = [(b,0,0,0)]\n          mem = {}\n          while not good and q:\n              board,total_cleared,x,y = q.pop(0)\n              if (board,total_cleared,x,y) in mem:\n                  continue\n              mem[(board,total_cleared,x,y)] = True\n              if x >= R: continue\n              if y >= C:\n                  q.append((last_board,total_cleared,x+1,0))\n                  continue\n              last_board = board\n              new_board, cleared_mines = clear(R,C,last_board,x,y)\n              total_cleared += cleared_mines\n  \n              if total_cleared == cleared:\n                  good = True\n                  last_board = new_board\n                  q = []\n                  break\n              elif total_cleared - cleared == -1:\n                  q.append((new_board,total_cleared,x,y+1))\n                  q.append((new_board,total_cleared,x+1,0))\n                  q.append((last_board,total_cleared-cleared_mines,x+1,0))\n              elif total_cleared > cleared:\n                  q.append((last_board,total_cleared-cleared_mines,x+1,0))\n              else:\n                  q.append((new_board,total_cleared,x,y+1))\n              last_board = new_board\n          if good:\n              answer = last_board\n          else:\n              answer = None\n      if not answer:\n          answer = "Impossible"\n      else:\n          b = ""\n          for x in range(R):\n              b += answer[x*C:x*C+C] + "\n"\n          answer = "c" + b[1:-1]\n      print "Case #%d:\n%s" % (CASE+1, answer)\n  \n <CODESPLIT> 39
fin = open('B-small-attempt0.in', 'r')\n  fout = open('B-output.txt', 'w')\n  \n  cases = int(fin.readline()[:-1])\n  \n  for case in range(cases) :\n      line = map(int, fin.readline()[:-1].split(' '))\n      N, S, p = line[:3]\n      T = line[3:]\n      okLimit = p + 2*max(p-1,0)\n      okIfSLimit = p + 2*max(p-2,0)\n      ok = len(filter(lambda x : x >= okLimit, T))\n      okIfS = len(filter(lambda x : okLimit > x >= okIfSLimit, T))\n      res = ok + min(okIfS, S)\n      fout.write('Case #' + str(case+1) + ': ' + str(res) + '\n')\n      \n  fin.close()\n  fout.close()\n <CODESPLIT> 40
f = open('input.in')\n  g = open('output', 'w')\n  \n  T = int(f.readline()[:-1])\n  \n  for case in xrange(T) :\n      R, C, M = map(int, f.readline()[:-1].split())\n      FREE = R*C - M\n      if FREE == 0 : res = '\nImpossible'\n      elif FREE != 1 and M > 0 and (R == 2 or C == 2) and (FREE == 2 or FREE % 2 == 1) : res = '\nImpossible'\n      elif R > 2 and C > 2 and FREE in (2, 3, 5, 7) : res = '\nImpossible'\n      else :\n          MAP = [['.' for c in range(C)] for r in range(R)]\n          MAP[0][0] = 'c'\n          if R == 1 :\n              for i in range(C-1, C-M-1, -1) : MAP[0][i] = '*'\n          elif C == 1 :\n              for i in range(R-1, R-M-1, -1) : MAP[i][0] = '*'\n          elif R == 2 :\n              for i in range(C-1, C-M/2-1, -1) : MAP[0][i], MAP[1][i] = '*', '*'\n              if FREE == 1 : MAP[1][0] = '*'\n          elif C == 2 :\n              for i in range(R-1, R-M/2-1, -1) : MAP[i][0], MAP[i][1] = '*', '*'\n              if FREE == 1 : MAP[0][1] = '*'\n          else :\n              com = M / C\n              for i in range(R-1, max(R-com-1, 2), -1) :\n                  MAP[i] = ['*' for j in range(C)]\n                  M -= C\n              I = max([i for i, j in enumerate(MAP) if j[0] == '.'])\n              if I == 2 :\n                  com = M / 3\n                  if com == 0 : i = C\n                  for i in range(C-1, C-com-1, -1) :\n                      MAP[0][i], MAP[1][i], MAP[2][i] = '*', '*', '*'\n                      M -= 3\n                  if M >= 1 : MAP[2][i-1] = '*'\n                  if M >= 2 :\n                      if i != 1 : MAP[2][i-2] = '*'\n                      else : MAP[1][0] = '*'\n              else :\n                  for i in range(C-1, C-M-1, -1) : MAP[I][i] = '*'\n                  if i == 1 :\n                      MAP[I][i] = '.'\n                      MAP[I-1][C-1] = '*'\n          res = '\n' + '\n'.join([''.join(i) for i in MAP])\n      output = 'Case #' + str(case + 1) + ': ' + str(res)\n      g.write(output + '\n')\n      print output\n  \n  f.close()\n  g.close()\n <CODESPLIT> 40
T=int(input())\n  for t in range(T):\n    l = [int(x) for x in input().split()]\n    n,huh,p = l[:3]\n    ss = l[3:]\n    nice, maybe = 0,0\n    for s in ss:\n      if s>= p+2*max(p-1,0):\n        nice += 1\n      elif s>= p+2*max(p-2,0):\n        maybe += 1\n    y = nice + min(maybe,huh)\n    print('Case #',t+1,': ',y,sep = '')\n  \n  \n <CODESPLIT> 41
T = int(input())\n  \n  def solve(R,C,M):\n      if R>C:\n          flipboard = solve(C,R,M)\n          if flipboard:\n              return [[flipboard[j][i] for j in range(C)] for i in range(R)]\n          else:\n              return\n      if M==0:\n          board = [['.']*C for i in range(R)]\n          board[-1][-1] = 'c'\n          return board\n      if R == 1:\n          board = ['*' if i<M else '.' for i in range(R*C)]\n          board[-1] = 'c'\n          return [board]\n      if R == 2:\n          if R*C==M+1:\n              board = [['*']*C for i in range(R)]\n              board[-1][-1] = 'c'\n              return board\n          if (M%2) or (M+2)==(R*C):\n              return\n          board = [['*' if i<(M/2) else '.' for i in range(C)] for j in range(R)]\n          board[-1][-1] = 'c'\n          return board\n      if M>=R:\n          subboard = solve(R,C-1,M-R)\n          if subboard:\n              return [['*']+r for r in subboard]\n          return\n      if (R,C,M) == (3,3,2):\n          return\n      k = min(M,C-2)\n      board = [['*']*k+['.']*(C-k)]\n      for i in range(M-k):\n          board.append(['*']+['.']*(C-1))\n      while len(board)<R:\n          board.append(['.']*(C))\n      board[-1][-1] = 'c'\n      return board\n      \n           \n      \n  \n  for case in range(1,T+1):\n      print("Case #",case,": ",sep='')\n      R,C,M = (int(x) for x in input().split())\n      ans = solve(R,C,M)\n      if ans:\n          for r in ans:\n              print(''.join(r))\n      else:\n          print('Impossible')\n  \n  \n <CODESPLIT> 41
 fin = sys.stdin\n  T = int(fin.readline())\n  for case in range(1,T+1):\n      numbers = map(int, fin.readline().split())\n      N, S, p = numbers[:3]\n      T = numbers[3:]\n      normal_limit = p + 2*max(0, (p-1))\n      surpising_limit = p + 2*max(0, (p-2))\n  \n      normal_count = 0\n      surprising_count = 0\n  \n      for t in T:\n          if t >= normal_limit:\n              normal_count += 1\n          elif t >= surpising_limit:\n              surprising_count += 1\n  \n      result = normal_count + min(surprising_count, S)\n  \n      print "Case #%d: %s" % (case, result)\n  \n <CODESPLIT> 42
 \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n   \n  \n  \n  \n  \n  def debug(*args):\n      print(*args, file=sys.stderr)\n  \n  fin = sys.stdin\n  T = int(fin.readline())\n  for case in range(1, T + 1):\n      RR, CC, M = map(int, fin.readline().split())\n      R, C = None, None\n      blocks = RR*CC - M\n      inverse = False\n      if RR > CC:\n          inverse = True\n          R, C = CC, RR\n      else:\n          R, C = RR, CC\n      result = None\n      if R == 1:\n          result = [('.' * blocks) + ('*' * M)]\n      elif R == 2:\n          if blocks == 1:\n              result = ['.' + ('*' * (C-1)), '*' * C]\n          elif blocks % 2 == 0 and blocks != 2:\n              cc = blocks // 2\n              result = [('.' * cc) + ('*' * (C - cc)), ('.' * cc) + ('*' * (C - cc))] \n          else:\n              result = None\n      else:\n          if blocks == 1:\n              result = ['*' * C] * R\n          elif blocks == 4:\n              result = ['..' + (C-2)*'*']*2\n              result += ['*'*C] * (R-2)\n          elif blocks == 6:\n              result = ['...' + (C-3)*'*']*2\n              result += ['*'*C] * (R-2)\n          for rows in range(3, R+1):\n              for columns in range(rows, C+1):\n                  size = rows * columns\n                  if size - blocks >= 0:\n                      if size - blocks <= columns - 2: \n                          result = []\n                          for r in range(rows):\n                              if r < rows - 1:\n                                  result.append(('.' * columns) + ('*' * (C - columns)))\n                              else:\n                                  cc = columns - (size - blocks)\n                                  result.append(('.' * cc) + ('*' * (C - cc)))\n                          for r in range(R - rows):\n                              result.append('*' * C)\n                      elif size - blocks == columns - 1 and rows >= 4:\n                          result = []\n                          for r in range(rows):\n                              if r < rows - 2:\n                                  result.append(('.' * columns) + ('*' * (C - columns)))\n                              elif r == rows - 2:\n                                  cc = columns - 1\n                                  result.append(('.' * cc) + ('*' * (C - cc)))\n                              else:\n                                  cc = 2\n                                  result.append(('.' * cc) + ('*' * (C - cc)))\n                          for r in range(R - rows):\n                              result.append('*' * C)\n                      \n  \n  \n  \n      print("Case #%d: " % (case))\n      if result is None:\n          debug('impossible', blocks, RR, CC)\n          print("Impossible")\n      else:\n          mines = 0\n          for r in range(RR):\n              row = ''\n              for c in range(CC):\n                  rr, cc = r, c\n                  if inverse:\n                      rr, cc = c, r\n                  if rr == 0 and cc == 0:\n                      row += 'c'\n                  else:\n                      row += result[rr][cc]\n                      if result[rr][cc] == '*':\n                          mines += 1\n              print(row)\n          if mines != M:\n              raise Exception("%d != %d %d x %d" % (mines, M, RR, CC))\n              \n  \n  \n <CODESPLIT> 42
def build_table():\n  	table = []\n  	for i in range( 0, 31 ):\n  		table.append( ( get_max_score( i ), get_max_surprise_score( i ) ) )\n  \n  	return table\n  \n  \n  def get_max_score( i ):\n  	return max( 0, min( 10, ( i + 2 ) / 3 ) )\n  \n  def get_max_surprise_score( i ):\n  	return min( i, max( 0, min( 10, ( i + 4 ) / 3 ) ) )\n  \n  def get_max( x, scores, score_needed, num_surprises ):\n  	scores = sorted( scores, reverse=True )\n  	numPass = 0\n  	i = 0;\n  	while ( i < len(scores) ):\n  		if ( x[scores[i]][0] >= score_needed ):\n  			numPass += 1\n  		else:\n  			break\n  		i += 1\n  \n  	while ( i < len(scores) and num_surprises > 0 ):\n  		if ( x[scores[i]][1] >= score_needed ):\n  			numPass += 1\n  			num_surprises -= 1\n  			\n  		i += 1\n  \n  	return numPass\n  \n  x = build_table()\n  \n  num_cases = input()\n  \n  for i in range( 1, num_cases + 1 ):\n  	line = raw_input().split()\n  	num_surprises = int(line[1])\n  	score_needed = int(line[2])\n  	scores_raw = line[3:]\n  \n  	scores = [ int(y) for y in scores_raw ]\n  \n  	print 'Case #' + str( i ) + ': ' + str( get_max( x, scores, score_needed, num_surprises ) )\n <CODESPLIT> 43
 \n  def DrawMines( R, C, M, Flip, gridMines, sideMines, bottomMines ):\n    x = []\n    numSpaces = 0\n    numMines = 0\n  \n    gridRows = max( R-2, 0 )\n    gridCols = max( C-2, 0 )\n  \n    for r in xrange( 0, R ):\n      x.append( [] )\n      for c in xrange( 0, C ):\n        x[ r ].append( '.' )\n        numSpaces += 1\n  \n    if gridMines > 0:\n      for r in xrange( 0, gridRows ):\n        if numMines >= gridMines:\n          break;\n        for c in xrange( 0, gridCols ):\n          x[ r ][ c ] = '*'\n          numMines += 1\n          numSpaces -= 1\n          if numMines >= gridMines:\n            break;\n  \n    for r in xrange( 0, R ):\n      if sideMines <= 0:\n        break\n      for c in xrange( gridCols, C ):\n        x[ r ][ c ] = '*'\n        numMines += 1\n        numSpaces -= 1\n        sideMines -= 1\n        if sideMines <= 0:\n          break\n  \n    for c in xrange( 0, C ):\n      if bottomMines <= 0:\n        break\n      for r in xrange( gridRows, R ):\n        x[ r ][ c ] = '*'\n        numMines += 1\n        numSpaces -= 1\n        bottomMines -= 1\n        if bottomMines <= 0:\n          break\n      \n    x[ R - 1][ C - 1 ] = 'c'\n    \n    if numMines != M and ( R * C ) - M != 1:\n      print "ERROR!!!!!!!!!!!!!!!!!!!!!!!!"\n      print ( R * C ) - M\n  \n  \n    o = ""\n  \n    if Flip:\n      for c in xrange( 0, C ):\n        for r in xrange( 0, R ):\n           o += x[ r ][ c ]\n        o += '\n'\n    else:\n      for r in xrange( 0, R ):\n        for c in xrange( 0, C ):\n           o += x[ r ][ c ]\n        o += '\n'\n  \n    return o[:-1] #strip the extra newline\n  \n  \n  \n  \n  numCases = input()\n  for case in xrange( 1, numCases + 1 ):\n    R, C, M = [int(x) for x in raw_input().split()]\n  \n    Output = None\n  \n    Flip = C > R\n    if Flip:\n      temp = R\n      R = C\n      C = temp\n  \n    NonMines = ( R * C ) - M\n    if ( NonMines == 0 ):\n      Output = "Impossible"\n    elif ( C == 1 ):\n      gridMines = 0\n      extraMines = M - gridMines\n      Output = DrawMines( R, C, M, Flip, gridMines, extraMines, 0 )\n    elif ( NonMines == 2 or  NonMines == 3 ):\n      Output = "Impossible"\n    else:\n      maxGridCols = max( 0, C - 2 )\n      maxGridRows = max( 0, R - 2 )\n      gridMines = min( M, maxGridCols * maxGridRows )\n      extraMines = M - gridMines\n      extraPairs = ( extraMines + 1 ) / 2\n      extraPairsSide = max( min( extraPairs, maxGridRows - 1 ), 0 )\n      extraPairsBottom = max( min( extraPairs - extraPairsSide, maxGridCols - 1 ), 0 )\n      safeExtraPairs = extraPairsSide + extraPairsBottom\n      blockingPairsSide = max( min( extraPairs - safeExtraPairs, 1 ), 0 )\n      blockingPairsBottom = max( min( extraPairs - blockingPairsSide - safeExtraPairs, 1 ), 0 )\n      blockingPairs = blockingPairsSide + blockingPairsBottom\n      totalPairs = safeExtraPairs + blockingPairs\n  \n      \n      if ( gridMines > 0 and extraMines % 2 != 0 and blockingPairs == 0 ):\n        extraMines += 1\n        gridMines -= 1\n  \n      if ( NonMines == 1 ):\n        if extraMines % 2 != 0:\n          extraMines += 1\n        blockingPairsSide += 1\n        blockingPairsBottom += 1\n      \n      if extraMines % 2 == 0:\n        sideMines = 2 * ( extraPairsSide + blockingPairsSide )\n        bottomMines = 2 * ( extraPairsBottom + blockingPairsBottom )\n        Output = DrawMines( R, C, M, Flip, gridMines, sideMines, bottomMines )\n      else:\n        Output = "Impossible"\n  \n    output = "\n" + Output\n    print 'Case #' + str( case ) + ': ' + str( output )\n <CODESPLIT> 43
 \n  def program():\n  	T = int(stdin.readline())\n  	for Ti in xrange(T):\n  		numbers = a = map(int, stdin.readline().rstrip().split(' '))\n  		N, S, p, totals = numbers[0], numbers[1], numbers[2], numbers[3:]\n  		\n  		m = 0\n  		curr_S = S\n  		for i in xrange(N):\n  			t = totals[i]\n  			\n  			if t / 3 >= p or (t / 3 == p - 1 and t % 3 > 0):\n  				m += 1\n  			elif curr_S > 0 and t > 0:\n  				if (t / 3 == p - 1 and t % 3 == 0) or (t / 3 == p - 2 and t % 3 == 2):\n  					m += 1\n  					curr_S -= 1\n  		\n  		print 'Case #%d: %d' % (Ti + 1, m)	\n  	\n  if __name__ == '__main__':\n  	program()\n <CODESPLIT> 44
 \n  \n  def read_str(): return stdin.readline().rstrip('\n')\n  def read_int(): return int(stdin.readline())\n  def read_ints(): return map(int, stdin.readline().split())\n  def read_floats(): return map(float, stdin.readline().split())\n  \n  \n  def atos(A):\n      return '\n'.join([''.join(row) for row in A])\n      \n  \n  def get_field(r, c):\n      field = [['.'] * c for i in range(r)]\n      field[0][0] = 'c'\n      return field\n      \n      \n  def is_forbidden(i, j):\n      return i == 0 and j == 0 or i == 0 and j == 1 or \\n          i == 1 and j == 0 or i == 1 and j == 1\n      \n      \n  def fill(field, r, c, m):\n      left = m\n      for ii in range(r - 1, -1, -1):\n          i = ii\n          j = c - 1\n          while i < r and j >= 0:\n              if is_forbidden(i, j):\n                  i += 1\n                  j -= 1\n                  continue\n              if left == 0:\n                  return 0\n              field[i][j] = '*'\n              left -= 1\n              \n              i += 1\n              j -= 1\n              \n          if ii == 0:\n              for jj in range(c - 2, 1, -1):\n                  i = ii\n                  j = jj\n                  while i < r and j >= 0:\n                      if is_forbidden(i, j):\n                          i += 1\n                          j -= 1\n                          continue\n                      if left == 0:\n                          return 0\n                      field[i][j] = '*'\n                      left -= 1\n                      \n                      i += 1\n                      j -= 1\n              \n      if r * c == m + 1:\n          if r > 1:\n              field[1][0] = '*'\n          if c > 1:\n              field[0][1] = '*'\n          if r > 1 and c > 1:\n              field[1][1] = '*'\n          return 0\n              \n      return left\n  \n      \n  def solve_case():\n      r, c, m = read_ints()\n      \n      field = get_field(r, c)\n          \n      left = fill(field, r, c, m)\n          \n      return 'Impossible' if left != 0 else atos(field)\n      \n      \n  def main():\n      cases = read_int()\n      for case in range(1, cases + 1):\n          print('Case #{}:\n{}'.format(case, solve_case()))\n  \n          \n  main()\n <CODESPLIT> 44
 data = [[100],[3,1,5,15,13,11],[3,0,8,23,22,21],[2,0,8,26,20],[1,0,3,30],[2,2,5,6,19],[2,0,9,18,2],[3,0,8,0,22,23],[3,2,4,29,17,28],[2,2,10,6,7],[2,1,1,17,0],[1,0,9,2],[2,0,10,27,27],[1,0,10,12],[2,2,6,20,12],[3,1,2,5,24,15],[3,0,8,29,20,20],[1,1,9,13],[1,1,7,11],[2,0,2,2,2],[1,0,5,11],[1,0,4,8],[1,0,4,1],[3,1,3,10,9,3],[2,2,7,15,2],[2,0,1,26,28],[3,0,10,5,27,9],[2,2,5,21,7],[3,0,1,23,11,26],[3,3,2,23,28,22],[2,1,5,11,11],[2,0,4,16,26],[3,0,10,26,30,18],[3,2,5,15,19,11],[1,0,1,4],[3,0,4,2,3,30],[3,1,2,3,0,3],[2,0,3,21,30],[3,1,6,14,16,14],[1,0,7,17],[3,3,3,22,18,22],[2,1,7,17,17],[2,0,1,19,14],[1,0,1,0],[3,0,4,8,3,25],[2,0,3,5,30],[2,0,6,14,15],[1,0,10,22],[1,0,7,18],[1,0,3,5],[3,3,8,26,17,4],[3,3,0,3,9,21],[3,2,1,14,12,0],[2,0,7,29,18],[2,0,3,6,8],[1,1,8,3],[3,1,9,17,12,14],[2,0,3,22,6],[2,0,8,29,9],[3,3,9,16,26,13],[1,1,0,12],[2,1,7,27,14],[2,0,6,22,19],[1,0,0,0],[2,1,5,18,22],[3,1,9,28,24,23],[3,0,1,4,15,29],[1,0,3,20],[3,0,1,30,21,30],[2,0,9,19,7],[1,0,9,10],[1,0,0,1],[2,1,3,6,6],[3,1,0,11,28,27],[2,0,4,25,8],[1,0,6,15],[3,3,9,12,23,26],[2,1,5,12,12],[3,1,9,28,3,28],[3,1,6,20,14,15],[1,0,10,30],[1,1,9,9],[2,0,9,3,10],[2,0,10,26,26],[2,1,9,23,23],[3,0,2,6,3,22],[1,1,0,27],[3,0,9,23,23,24],[1,1,7,2],[2,1,0,10,3],[1,0,4,1],[1,0,7,12],[3,0,9,23,15,8],[1,0,10,27],[3,0,0,30,30,30],[3,0,3,19,2,14],[3,1,3,6,21,5],[3,0,3,11,16,11],[1,1,8,3],[2,0,10,26,19],[1,0,7,18]]\n  count = 0\n  for line in data[1:]:\n  	count += 1\n  	supps = line[1]\n  	score = line[2]\n  	maxes = 0\n  	nonsuptot = (score*3)-2\n  	suptot = (score*3)-4\n  	if suptot < 0:\n  		suptot = 1\n  	for i in range(3,(len(line))):\n  		if line[i] >= nonsuptot:\n  			maxes += 1\n  			continue\n  		if (line[i] >= suptot) and (supps > 0):\n  			maxes += 1\n  			supps -= 1\n  	if score == 0:\n  		maxes = line[0]\n  	print ("Case #"+str(count)+":", maxes)\n  		\n  			\n  \n  \n  \n  \n <CODESPLIT> 45
 \n  def check_bounds(state, coord):\n      if coord[0] < 0 or coord[1] < 0:\n          return False\n      elif coord[0] > (len(state) - 1):\n          return False\n      elif coord[1] > (len(state[coord[0]]) - 1):\n          return False\n      else:\n          return True\n  \n  def clear(state, coord):\n      for r in range(-1,2):\n          for c in range(-1,2):\n              row = coord[0] + r\n              col = coord[1] + c\n              if check_bounds(state, (row, col)):\n                  state[row][col] = 0\n  \n  def count(state):\n      return sum([sum(x) for x in state])\n  \n  def state_print(state):\n      print("c" + "".join(["*"  if x else "." for x in state[0][1:]]))\n      for line in state[1:]:\n          print("".join(["*"  if x else "." for x in line]))\n  \n  def solve(state, mines):\n      prev_state = deepcopy(state)\n      for row in range(len(state)):\n          for col in range(len(state[row])):\n              new_state = deepcopy(state)\n              clear(new_state, (row, col))\n              c = count(new_state)\n              if(c < mines):\n                  state = prev_state\n              elif( c == mines):\n                  state_print(new_state)\n                  return True\n              else:\n                  if col == len(state[row]) -2:\n                      prev_state = deepcopy(state)\n                  state = new_state\n      print("Impossible")\n      return False\n  \n  \n  \n  \n  def main():\n      filename = "C-small-attempt0.in"\n  \n  \n      inp = open(filename, "rU")\n  \n      n = int(inp.readline().strip())\n  \n      for case in range(1, n + 1):\n          R, C, M = map(int, inp.readline().strip().split(" "))\n          state = [[1 for x in range(C)] for y in range(R)]\n          print("Case #{}:".format(case))\n          solve(state, M)\n  \n  main()\n <CODESPLIT> 45
arq = file("input.in")\n  n_cases = eval(arq.readline())\n  out = file("output.txt", "w")\n  \n  for case in xrange(n_cases):\n  \n  	data = arq.readline()\n  	data = data.strip()\n  	data = data.split(" ")\n  \n  	n = eval(data[0])\n  	s = eval(data[1])\n  	p = eval(data[2])\n  \n  	scores = []\n  	n_googlers_with_best_result = 0\n  	candidates = 0\n  \n  	for j in data[3:]:\n  		i = eval(j)\n  		if i%3 == 0:\n  			score = i/3\n  			scores.append([score, score, score])\n  		elif (i+1)%3 == 0:\n  			score = (i+1)/3\n  			scores.append([score-1, score, score])\n  		else: #(i+2)%3 == 0\n  			score = (i+2)/3\n  			scores.append([score-1, score-1, score])\n  \n  	for score in scores:\n  		if score[2] >= p:\n  			n_googlers_with_best_result +=1\n  		elif score[2] + 1 == p and score[1] == score[2] and score[2] != 0:\n  			candidates += 1\n  \n  	n_googlers_with_best_result = n_googlers_with_best_result + min(s, candidates)\n  \n  	out.write("Case #%d: %d\n" % (case+1, n_googlers_with_best_result))\n <CODESPLIT> 46
 \n  def transpose(result, R, C):\n  	resultSplitted = result.split("\n")\n  	aux = R*[""]\n  	for i in xrange(R):\n  		for j in xrange(C):\n  		    aux[i] += resultSplitted[j][i]\n  		aux[i] += "\n"\n  	result = ""\n  	for item in aux:\n  		result += item + "\n"\n  	return result.strip()\n  \n  \n  inputFileName = sys.argv[1]\n  \n  f = file(inputFileName)\n  fout = file("output.txt", "w")\n  \n  T = int(f.readline())\n  \n  for case in xrange(T):\n  	data = f.readline().strip().split(" ")\n  	R = int(data[0])\n  	C = int(data[1])\n  	M = int(data[2])\n  \n  	result = ""\n  \n  	x = min(R,C)\n  	y = max(R,C)\n  \n  	if M > (y - 2)*x and M != y*x - 1:\n  		N = M - (y-2)*x\n  		if N%2 == 1 or y*x - M == 2:\n  			result = "Impossible"\n  	if result != "Impossible":\n  		i = 0\n  		while M > 0: # 2\n  			if i < y - 2:\n  				if M >= x:\n  					result += x*"*" + "\n"\n  					M -= x\n  					i += 1\n  				elif M <= x - 2:\n  					result += M*"*" + (x - M) * "." + "\n"\n  					M = 0\n  					i += 1\n  				elif i + 2 < y - 1:\n  					result += (M-1)*"*" + (x - M + 1) * "." + "\n" + "*" + (x-1)*"." + "\n"\n  					M = 0\n  					i += 2\n  				else:\n  					result = "Impossible"\n  					break\n  			else:\n  				if M%2 != 0:\n  					result += x*"*" + "\n"\n  					result += (x-1)*"*" + "c"\n  				else:\n  					n = M/2\n  					result += n*"*" + (x-n)*"." + "\n"\n  					result += n*"*" + (x-n-1)*"." + "c"\n  				M = 0\n  				i += 2\n  					\n  		while i <= y - 1 and result != "Impossible":\n  			if i == y - 1:\n  				result += (x-1)*"." + "c"\n  			else:\n  				result += x*"." + "\n"\n  			i += 1\n  	\n  	if R < C and result != "Impossible":\n  		result = transpose(result, R, C)\n  \n  	fout.write("Case #%d:\n%s\n" %(case + 1, result))\n <CODESPLIT> 46
 \n  mod_plus_conv_with_s = {0:1, 1:1, 2:2}\n  mod_plus_conv_without_s = {0:0, 1:1, 2:1}\n  \n  def solve_case(s, p, scores,case_number):\n  	ans = 0\n  	for score in scores:\n  		if p <= (score / 3) + mod_plus_conv_without_s[score % 3]:\n  			ans = ans + 1\n  		elif s > 0 and (score / 3) > 0: \n  			if p <= (score / 3) + mod_plus_conv_with_s[score % 3]:\n  				ans = ans + 1\n  				s = s - 1\n  	print "Case #%d: %d" % (case_number, ans)\n  \n  r = sys.stdin\n  \n  if len(sys.argv) > 1:\n  	r = open(sys.argv[1], 'r')\n  \n  total_cases = r.readline()\n  for case_number in range(1, int(total_cases) + 1):\n  	case_line = map(int, r.readline().rstrip().split(' '))\n  	solve_case(case_line[1], case_line[2], case_line[3:], case_number)\n  \n <CODESPLIT> 47
 \n  \n  def print_basic_board(no_mine, r, c):\n      printed_c = False\n      for row in range(0, r):\n          line = []\n          for column in range(0, c):\n              if printed_c:\n                  if no_mine > 0:\n                      line.append(".")\n                      no_mine -= 1\n                  else:\n                      line.append("*")\n              else:\n                  line.append("c")\n                  no_mine -= 1\n                  printed_c = True\n          print "".join(line)\n  \n  \n  def print_board(no_mine_row, no_mine_column, rest_no_mine_for_row, rest_no_mine_for_column, r, c):\n      printed_c = False\n      for row in range(0, r):\n          line = []\n          for column in range(0, c):\n              if printed_c:\n                  if row < no_mine_row and column < no_mine_column:\n                      line.append(".")\n                  elif rest_no_mine_for_column > 0 and column == no_mine_column:\n                      line.append(".")\n                      rest_no_mine_for_column -= 1\n                  elif rest_no_mine_for_row > 0 and row == no_mine_row:\n                      line.append(".")\n                      rest_no_mine_for_row -= 1\n                  else:\n                      line.append("*")\n              else:\n                  line.append("c")\n                  printed_c = True\n          print "".join(line)\n  \n  \n  def solve_case(r, c, m, case_number):\n      print "Case #%d:" % case_number\n      no_mine = r * c - m\n      if r < 2 or c < 2 or no_mine == 1:\n          print_basic_board(no_mine, r, c)\n      else:\n          no_mine_row_max = int(math.ceil(float(no_mine) / 2))\n          if no_mine_row_max > r:\n              no_mine_row_max = r\n          for no_mine_column in range(2, int(math.ceil(float(no_mine) / 2)) + 1):\n              if no_mine_column > c:\n                  break\n              for no_mine_row in range(2, no_mine_row_max + 1):\n                  rest_no_mine = no_mine - (no_mine_column * no_mine_row)\n                  if rest_no_mine < 0:\n                      continue\n                  if rest_no_mine == 1:\n                      continue\n  \n                  if rest_no_mine == 0:\n                      print_board(no_mine_row, no_mine_column, 0, 0, r, c)\n                      return\n                  if rest_no_mine <= no_mine_row and no_mine_column < c:\n                      print_board(no_mine_row, no_mine_column, 0, rest_no_mine, r, c)\n                      return\n                  if rest_no_mine <= no_mine_column and no_mine_row < r:\n                      print_board(no_mine_row, no_mine_column, rest_no_mine, 0, r, c)\n                      return\n  \n                  if rest_no_mine > 3 and no_mine_column < c and no_mine_row < r:\n                      for rest_no_mine_for_row in range(2, no_mine_column):\n                          rest_no_mine_for_column = rest_no_mine - rest_no_mine_for_row\n                          if rest_no_mine_for_column < no_mine_row:\n                              print_board(no_mine_row, no_mine_column, rest_no_mine_for_row, rest_no_mine_for_column, r, c)\n                              return\n  \n          print "Impossible"\n  \n  r_file = sys.stdin\n  \n  if len(sys.argv) > 1:\n      r_file = open(sys.argv[1], 'r')\n  \n  total_cases = r_file.readline()\n  for case_number in range(1, int(total_cases) + 1):\n      values = map(int, r_file.readline().split(' '))\n      solve_case(values[0], values[1], values[2], case_number)\n  \n <CODESPLIT> 47
 \n  def readfile(filename):\n  	"""\n  		The first line of the input gives the number of test\n  		cases, T. T test cases follow. Each test case consists of\n  		a single line containing integers separated by single\n  		spaces. The first integer will be N, the number of\n  		Googlers, and the second integer will be S, the number\n  		of surprising triplets of scores. The third integer will\n  		be p, as described above. Next will be N integers ti:\n  		the total points of the Googlers.\n  	"""\n  \n  	file = open(filename, "rt")\n  \n  	retval = {}\n  \n  	T = int(file.readline().strip())\n  	retval['T'] = T\n  \n  	tests = []\n  \n  	for i in xrange(T):\n  		line = file.readline().strip()\n  \n  		parts = line.split(" ")\n  \n  		N = int(parts[0])\n  		S = int(parts[1])\n  		p = int(parts[2])\n  		t = []\n  \n  		for j in xrange(N):\n  			t = t + [int(parts[3 + j]), ]\n  \n  		test = { 'N' : N, 'S': S, 'p' : p, 't' : t }\n  		tests = tests + [test, ]\n  \n  	retval['tests'] = tests\n  	return retval\n  \n  def spread(triplet):\n  	return max(abs(triplet[0] - triplet[1]), abs(triplet[1] - triplet[2]), abs(triplet[2] - triplet[0]))\n  \n  def bestresult(triplet):\n  	if triplet:\n  		return max(triplet)\n  	return 0\n  \n  def getcombos(points):\n  	"""\n  		Returns ([unsurprising possibilities, ], [surprising possibilities])\n  	"""\n  \n  	unsurps = []\n  	surps = []\n  \n  	avg = points / 3.0\n  \n  	avg = int(avg)\n  \n  	tested = []\n  \n  	for i in xrange(max(avg - 2, 0), min(avg + 3, 10)+1):\n  		for j in xrange(max(avg - 2, 0), min(avg + 3, 10)+1):\n  			for k in xrange(max(avg - 2, 0), min(avg + 3, 10)+1):\n  				if (i + j + k) != points:\n  					continue\n  \n  				scores = (i,j,k)\n  				scores = sorted(scores)\n  \n  				if scores in tested:\n  					continue\n  				tested.append(scores)\n  \n  				s = spread((i,j,k))\n  \n  				if (s < 2):\n  					unsurps.append(scores)\n  				elif (s == 2):\n  					surps.append(scores)\n  				else:\n  					continue\n  \n  	return (unsurps, surps)\n  \n  def getbesttriplet(triplets):\n  	best = None\n  \n  	for i in triplets:\n  		if best:\n  			if (bestresult(i) > bestresult(best)):\n  				best = i\n  		else:\n  			best = i\n  \n  	return best\n  	\n  \n  def getmulticombos(peeps):\n  	"""\n  		Return the best surprising and non-surprising possibility for\n  		each person.\n  	"""\n  \n  	ret = []\n  \n  	for p in peeps:\n  		u,s = getcombos(p)\n  \n  		bestu = getbesttriplet(u)\n  		bests = getbesttriplet(s)\n  \n  		ret.append((bestu, bests))\n  \n  	return ret\n  \n  def getbestresults(scores, best, numsur):\n  	"""\n  		Figure out the maximum number of people that could have gotten\n  		a single score >= best.  Limited to choosing only numsur surprising\n  		triplets.\n  	"""\n  \n  	peeps = getmulticombos(scores)\n  \n  	count = 0\n  	surcount = 0\n  \n  	for p in peeps:\n  		if (bestresult(p[0]) >= best):\n  			count = count + 1\n  		elif ((bestresult(p[1]) >= best) and (surcount < numsur)):\n  			count = count + 1\n  			surcount = surcount + 1\n  \n  	return count\n  \n  def process(test):\n  	N = test['N']\n  	S = test['S']\n  	p = test['p']\n  	t = test['t']\n  \n  	return getbestresults(t, p, S)\n  \n  data = readfile("B-small-attempt0.in")\n  \n  for i in xrange(data['T']):\n  	test = data['tests'][i]\n  \n  	result = process(test)\n  \n  	print "Case #%d: %d" % (i+1, result)\n <CODESPLIT> 48
 \n  \n  \n  class Minesweeper_2014_QC(puzutils.CodeJamProblem):\n    def __init__(self, inputFilename):\n      puzutils.CodeJamProblem.__init__(self, inputFilename)\n  \n      self.T = None\n  \n    def load(self):\n      """\n        input:\n  \n        T (number of test cases)\n  \n        R C M (integers)\n  \n      """\n  \n      self.tests = []\n  \n      with open(self.inputFilename, "rt") as file:\n        self.T = int(file.readline().strip())\n  \n        for i in xrange(self.T):\n          (R,C,M) = [int(x) for x in file.readline().split(' ')]\n  \n          self.tests.append([R,C,M])\n  \n      return True\n  \n    def boardToString(self, board):\n      retval = ""\n  \n      for row in board:\n        retval = retval + "\n" + "".join(row)\n  \n      return retval\n  \n    def executeTest(self, test):\n      """\n        Run a test and return output.\n      """\n  \n      (R,C,M) = test\n  \n      spaces = R * C\n      blanks = spaces - M\n  \n      if (blanks <= 0):\n        return "Impossible"\n  \n      board = [['.' for x in range(C)] for y in range(R)]\n  \n      board[R-1][C-1] = "c"\n  \n      badpositions=[]\n      positions=[]\n  \n      for x in xrange(C):\n        for y in xrange(R):\n          if (x == (C-1)) and (y == (R-1)):\n            continue\n          if (x == (C-1)) and (y == (R-2)):\n            badpositions.append((x,y))\n            continue\n          if (x == (C-2)) and (y == (R-1)):\n            badpositions.append((x,y))\n            continue\n          if (x == (C-2)) and (y == (R-2)):\n            badpositions.append((x,y))\n            continue\n  \n          positions.append((x,y))\n  \n      positions.reverse()\n  \n      for x in badpositions:\n        positions.insert(0, x)\n  \n      m = M\n  \n      while (m > 0):\n        if len(positions) <= 0:\n          return "Impossible"\n  \n        pos = positions.pop()\n        (x,y) = pos\n  \n        if (board[y][x] != "."):\n          return "Impossible"\n  \n        board[y][x] = '*'\n        m = m - 1\n  \n      mines = sum([x.count('*') for x in board])\n  \n      if (mines != M):\n        return "Impossible"\n  \n      if (blanks > 1):\n        if (R > 1):\n          if board[R - 2][C - 1] == "*":\n            return "Impossible"\n  \n        if (C > 1):\n          if board[R - 1][C - 2] == "*":\n            return "Impossible"\n  \n        if (R > 1) and (C > 1):\n          if board[R - 2][C - 2] == "*":\n            return "Impossible"\n  \n      return self.boardToString(board)\n  \n  with Minesweeper_2014_QC(sys.argv[1]) as problem:\n    problem.load()\n  \n    problem.run()\n <CODESPLIT> 48
'''\n  Created on Apr 14, 2012\n  \n  @author: moatasem\n  '''\n  \n  \n  def isSurprising(t):\n      if(abs(t[0]-t[1])==2 or abs(t[2]-t[1])==2 or abs(t[0]-t[2])==2):\n          return True\n      else:\n          return False\n  \n  \n  def getAllTriplets(n):\n      h=[]\n      for i in xrange(11):\n          for j in xrange(i,11):\n              for  k in xrange(j,11):\n                  if(i+j+k==n and abs(i-j)<3 and abs(k-j)<3 and abs(i-k)<3):\n                      h.append((i,j,k))\n              \n      return  h\n  \n  def getInfo(p,total,S):\n      g= getAllTriplets(total)\n      if(S):\n          s_=len(g)\n          indcies=[]\n          for i in xrange (s_):\n              if(isSurprising(g[i])):\n                  indcies.append(i)\n          for i in xrange (len(indcies)):  \n              g.remove(g[indcies[i]])\n      equ=False\n      sur=False\n      sur_equ=False\n      for i in xrange(len(g)):\n          if(max(g[i])>=p):\n              if(isSurprising(g[i])):\n                  sur_equ=True\n              else:\n                  equ=True\n          elif(isSurprising(g[i])):\n                  sur=True\n      return sur_equ,equ,sur\n             \n  f = open("b_.in", "r")\n  n=int(f.readline().strip())\n  for k  in xrange(n):\n      d=f.readline().strip()\n      googlers=[]\n      g=[int(i) for i in d.split(" ")]\n      N=g[0]\n      S=g[1]\n      noSu=False\n      if(S==0):\n          noSu=True\n      p=g[2]\n      count=0\n      equ_count=0;\n      both_count=0;\n      sur_count=0;\n      first_count=0;\n      googlers=g[3:len(g)]\n      for o in xrange(N):\n          info=getInfo(p,googlers[o],noSu)\n          if(info[0]==True and info[1]==False and S<>0): #101 /100\n              count+=1\n              S-=1\n          elif(info[0]==True and info[1]==True):#110 / 111\n              first_count+=1\n          elif(info[1]==True and info[2]==True):#011\n              both_count+=1\n          elif(info[1]==True):#010\n              count+=1\n          elif(info[2]==True):#001\n              sur_count+=1\n      count+=first_count\n      if(S>0):\n          if(first_count>S):\n              S=0\n          elif(first_count <=S) :\n              S-=first_count\n              if(S>0):\n                   if(both_count>S):\n                      both_count-=S\n                      S=0\n                   else:\n                      both_count=0\n      count+=both_count\n      \n      print 'Case #'+str((k+1))+": "+str(count)\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n      \n  \n <CODESPLIT> 49
'''\n  Created on Apr 12, 2014\n  \n  @author: mostasem\n  '''\n  \n  def getFloorRoots(m):\n      r1 = -1 + math.sqrt(1 + (8 * m))/2\n      r2 = -1 - math.sqrt(1 + (8 * m))/2\n      return int(math.floor(r1))\n      \n  def boardHasZero(R,C,M):\n      if(R > 1 and C > 1):\n          S = M/C\n          Sr = M % C\n          print S,Sr\n          return R >= S+3 or (R == S+2 and ((Sr % 2) == 0 or (((C + Sr) % 3 == 0) and (2*C >= (C + Sr + 4))))) or (R == S+1  and (C + Sr) % 2 == 0 and (2*C >= (C + Sr + 4)))  #M <= ((R*C) - 4)\n      else :\n          return M <= ((R*C) - 2)\n  \n  \n  def generateMineSweeperCase(R,C,M):\n  \n      board = ""\n  \n      if( R > 1 and C > 1 ): # generate special\n          S = M/C\n          Sr = M % C\n          print S,Sr\n          if(S): # all rows of *\n              board +="\n"\n              if(R >= S+3 or (R == S+2 and Sr % 2 == 0)):\n                  board += (S - 1) * ((C*"*") + "\n")\n              else:\n                  board += (S - 2) * ((C*"*") + "\n")\n              board +=  ((C*"*"))\n              \n          if(R >= S+3):\n              if(Sr):\n                  board +="\n"\n                  board += ((Sr *"*") + ((C - Sr) *"."))\n              Rm = R - (S + 1)\n              if(Rm):\n                  board +="\n"\n                  board += (Rm - 1) * ((C*".") + "\n")\n                  board +=  ((C*"."))\n                  \n          elif(R == S + 2):\n              Sm = 0\n              if(Sr % 2 == 0):\n                  board +="\n"\n                  board += (((Sr / 2) *"*") + ((C - (Sr / 2)) *".") +"\n")\n                  board += ((Sr / 2) *"*") + ((C - (Sr / 2)) *".")\n              else:\n                  board +="\n"\n                  board += (((Sr / 3) *"*") + ((C - (Sr / 3)) *".") +"\n")\n                  board += ((Sr / 3) *"*") + ((C - (Sr / 3)) *".")\n          else :\n              Sm = Sr + C\n              board +="\n"\n              board += (((Sm / 2) *"*") + ((C - (Sm / 2)) *".") +"\n")\n              board += ((Sm / 2) *"*") + ((C - (Sm / 2)) *".")\n                  \n          list_board = list(board)\n          list_board[len(list_board) - 1] = 'c'\n          board = "".join(list_board)\n      else:\n          board +="\n"\n          if(C == 1):\n              board += M * "*\n"\n              board += (R-M-1) * ".\n"\n              board +=  "c"\n          else:\n              board += M * "*"\n              board += (C-M-1) * "."\n              board += "c"\n              \n      return board\n         \n         \n         \n  \n  f_r = open('C.in',"r")\n  n_test=int(f_r.readline().strip()) \n  f_w = open("C.out", "w")\n  result = ""\n  for i in range(n_test):\n      R,C,M = map(int,f_r.readline().split())\n      print R,C,M\n      if(boardHasZero(R,C,M)):\n          result = generateMineSweeperCase(R,C,M)\n      else :\n          result ="\nImpossible"\n      print result\n      output_str='Case #{itr}:{res}'.format(itr=(i+1),res=result)\n      f_w.write(output_str+'\n')\n      \n  f_r.close()\n <CODESPLIT> 49
 \n  \n  def calculate_max_score(scores_sum):\n      if scores_sum % 3 == 1:\n          max_score = (scores_sum + 2) / 3\n          return (max_score, max_score)\n      if scores_sum % 3 == 2:\n          max_score = (scores_sum + 1) / 3\n          return (max_score, max_score + 1)\n      max_score = scores_sum / 3\n      if max_score == 0:\n          return (0, 0)\n      return (max_score, max_score + 1)\n  \n  def find_max_dancers(s, p, *scores_sums):\n      dancers_count = 0\n      for scores_sum in scores_sums:\n          (normal_max, surprise_max) = calculate_max_score(scores_sum)\n          if normal_max >= p:\n              dancers_count = dancers_count + 1\n              continue\n          if surprise_max >= p and s > 0:\n              s = s - 1\n              dancers_count = dancers_count + 1\n              continue\n      return dancers_count\n  \n  def main():\n  \n      case_count = int(sys.stdin.readline())\n  \n      for case_index in range(1, case_count + 1):\n          line = sys.stdin.readline().strip().split(' ')\n          s = int(line[1])\n          p = int(line[2])\n          scores_sums = [int(scores_sum) for scores_sum in line[3:]]\n          print 'Case #%i: %s' % (case_index, find_max_dancers(s, p, *scores_sums))\n  \n  if __name__ == '__main__':\n      main()\n <CODESPLIT> 50
 \n  NEIGHBOURS = [\n      (-1, -1), (-1, 0), (-1, 1),\n      ( 0, -1),          ( 0, 1),\n      ( 1, -1), ( 1, 0), ( 1, 1),\n  ]\n  \n  MOVES = [(-1, 0), (1, 0), (0, 1), (0, -1)]\n  \n  def valid(size, location, changes):\n      y, x = location\n      for y1, x1 in changes:\n          y1 += y\n          x1 += x\n          if y1 < 0 or y1 >= size[0]:\n              continue\n          if x1 < 0 or x1 >= size[1]:\n              continue\n          yield (y1, x1)\n  \n  def click(size, grid, location):\n      y, x = location\n      if grid[y][x] is 0:\n          return None\n  \n      grid = [row[:] for row in grid]\n      grid[y][x] = 0\n  \n      for y, x in valid(size, location, NEIGHBOURS):\n          if grid[y][x]:\n              grid[y][x] = False\n  \n      return grid\n  \n  def sweep(R, C, M):\n      grid = [[True] * C for _ in range(R)]\n      size = (R, C)\n  \n      if M + 1 == R * C:\n          grid[0][0] = False\n          return grid, (0, 0)\n  \n      states = []\n      for y in range(R):\n          for x in range(C):\n              location = (y, x)\n              states.append((click(size, grid, location), location))\n  \n      while states:\n          grid, location = states.pop(0)\n  \n          mines_count = sum([sum(row) for row in grid])\n          if mines_count == M:\n              return grid, location\n  \n          if mines_count < M:\n              continue\n  \n          for new_location in valid(size, location, NEIGHBOURS):\n              new_grid = click(size, grid, new_location)\n              if new_grid:\n                  states.insert(0, (new_grid, new_location))\n  \n      return None\n  \n  def validate(size, grid, location):\n  \n      result = [row[:] for row in grid]\n  \n      y, x = location\n      result[y][x] = sum([\n          grid[y1][x1]\n          for y1, x1 in valid(size, (y, x), NEIGHBOURS)\n      ])\n      assert result[y][x] == 0\n  \n      seen = set([location])\n      locations = set([location])\n  \n      while locations:\n          location = locations.pop()\n          for y, x in valid(size, location, NEIGHBOURS):\n              assert grid[y][x] is not True\n              result[y][x] = sum([\n                  grid[y1][x1]\n                  for y1, x1 in valid(size, (y, x), NEIGHBOURS)\n              ])\n              if result[y][x] == 0 and (y, x) not in seen:\n                  locations.add((y, x))\n                  seen.add((y, x))\n  \n      for row in result:\n          for col in row:\n              assert col is not False\n  \n      for y, row in enumerate(result):\n          output = ''\n          for x, col in enumerate(row):\n              if col is True:\n                  output += '*'\n              else:\n                  output += str(col)\n          print output\n  \n  \n  def process(case, R, C, M):\n      result = sweep(R, C, M)\n  \n      print 'Case #%d:' % (case + 1)\n      if not result:\n          print 'Impossible'\n          return\n  \n      grid, location = result\n      for y, row in enumerate(grid):\n          output = ''\n          for x, col in enumerate(row):\n              if (y, x) == location:\n                  output += 'c'\n              elif col:\n                  output += '*'\n              else:\n                  output += '.'\n          print output\n  \n  \n  \n  def main():\n      cases = int(sys.stdin.readline())\n  \n      for case in range(cases):\n          R, C, M = map(int, sys.stdin.readline().split())\n          process(case, R, C, M)\n  \n      return\n      for case in range(100):\n          R = random.randrange(51) + 1\n          C = random.randrange(51) + 1\n          M = random.randrange(R * C - 1) + 1\n          process(case * 100000 + M - 1, R, C, M)\n  \n  \n  if __name__ == '__main__':\n      main()\n <CODESPLIT> 50
directory = 'C:/users/hai/my projects/google code jam/2012/qualification/B/'\n  \n  \n  def solve (f_in, f_out):\n      T = int(f_in.readline())\n      print ('Test cases : ',T)\n      for i in range(1,T+1):\n          line = f_in.readline()\n          nnn = [int(x) for x in line.split()]\n          S = nnn[1]\n          p = nnn[2]\n          t = nnn[3:]\n          if p > 1:\n              A = 0\n              B = 0\n              for t_i in t:\n                  if t_i >=3*p-2:\n                      A += 1\n                  elif t_i >= 3*p-4:\n                      B += 1\n              result = A + min(B,S)\n          if p == 1:\n              result = len([x for x in t if x>=1])\n          if p == 0:\n              result=  len(t)\n          f_out.write('Case #' + str(i) + ': ' + str(result) + '\n')\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  def main_run():\n      filenames = [x for x in os.listdir (directory)]\n      filenames = [x for x in filenames if x.endswith('.in')]\n      l1 = [(os.stat(directory+x).st_ctime, x) for x in filenames]\n      chosen_filename =  sorted(l1)[-1][1][:-3]\n  \n      print ('Directory : ', directory)\n      print ('Chosen Filename : ',chosen_filename)\n      print()\n      f_in = open(directory+chosen_filename+'.in')\n      f_out = open(directory+chosen_filename+'.out', 'w')\n      solve(f_in,f_out)\n      f_in.close()\n      f_out.close()\n  \n  \n  \n  \n  main_run()\n <CODESPLIT> 51
directory = 'C:/users/me/desktop/google code jam/2014/qualification/C/'\n  \n  \n  \n  def solve_one_case (R,C,M):\n          l = []\n          for i in range(R):\n              for j in range(C):\n                  l.append((i,j))\n  \n          empty_mat = []\n          for i in range(R):\n              empty_mat.append(['.']*C)\n  \n          found = False\n  \n          assert (0,0) in l\n          l = l[1:]\n          l = l[::-1]\n          assert (0,0) not in l\n          \n          output = ''\n          \n          for mine_placement in itertools.combinations(l,M):\n              mat = deepcopy(empty_mat)\n              for cell in mine_placement:\n                  mat[cell[0]][cell[1]] = '*'\n              if isOneClick(mat, R, C, M):\n                  mat[0][0] = 'c'\n                  for line in mat:\n                      output += ''.join(line) + '\n'\n                  found = True\n                  return output\n              \n          if not found:\n              return 'Impossible\n'\n          \n          assert ValueError()\n          \n  def solve (f_in, f_out):\n      T = int(f_in.readline())\n      for testcase in range(1,T+1):\n          line = f_in.readline()\n          R,C,M = [int(q) for q in line.split()]\n          print (testcase,R,C,M)\n  \n          output = solve_one_case (R,C,M)\n          f_out.write('Case #' + str(testcase) + ':\n')\n          f_out.write(output)\n  \n          \n  \n  \n  def isOneClick (mat, R, C, M):\n  \n      mat_cpy = deepcopy(mat)\n      oneclickcells = [(0,0)]\n      while oneclickcells:\n          node = oneclickcells.pop()\n          mat_cpy[node[0]][node[1]] = 'v'\n          if noNearbyMines(mat_cpy,node):\n              oneclickcells.extend(getNearbyUnvisited(mat_cpy, node))\n  \n      return sum([l.count('.') for l in mat_cpy]) == 0\n      \n  \n  def getNearbyUnvisited(mat, node):\n      R = len(mat)\n      C = len(mat[0])\n      deltas_r = [0]\n      deltas_c = [0]\n      if node[0] > 0:\n          deltas_r.append(-1)\n      if node[1] > 0:\n          deltas_c.append(-1)\n      if node[0] < R-1:\n          deltas_r.append(1)\n      if node[1] < C-1:\n          deltas_c.append(1)\n  \n      ret_list = []\n      for delta_r in deltas_r:\n          for delta_c in deltas_c:\n              next_node = (node[0]+delta_r, node[1] + delta_c)\n              if mat[next_node[0]][next_node[1]] not in ['*','v']:\n                  ret_list.append((next_node[0],next_node[1]))\n  \n      return ret_list\n  \n  def noNearbyMines(mat,node):\n      R = len(mat)\n      C = len(mat[0])\n      deltas_r = [0]\n      deltas_c = [0]\n      if node[0] > 0:\n          deltas_r.append(-1)\n      if node[1] > 0:\n          deltas_c.append(-1)\n      if node[0] < R-1:\n          deltas_r.append(1)\n      if node[1] < C-1:\n          deltas_c.append(1)\n  \n      for delta_r in deltas_r:\n          for delta_c in deltas_c:\n              if mat[node[0] + delta_r][node[1] + delta_c] == '*':\n                  return False\n      return True\n      \n  def main_run():\n      filenames = [x for x in os.listdir (directory)]\n      filenames = [x for x in filenames if x.endswith('.in')]\n      l1 = [(os.stat(directory+x).st_mtime, x) for x in filenames]\n      chosen_filename =  sorted(l1)[-1][1][:-3]\n  \n      print ('Directory : ', directory)\n      print ('Chosen Filename : ',chosen_filename)\n      print()\n      print ('Start : ', time.ctime())\n      print()\n      \n      f_in = open(directory+chosen_filename+'.in')\n      f_out = open(directory+chosen_filename+'.out', 'w')\n      solve(f_in,f_out)\n      f_in.close()\n      f_out.close()\n  \n      print ()\n      print ('End : ', time.ctime())\n  \n  \n  main_run()\n  \n <CODESPLIT> 51
 \n  OEXT = ".out"\n  IN_S = "small.in"\n  IN_L = "large.in"\n  CASE_PRFX = "Case #%s: "\n  \n  \n  def avg(L):\n      return 1.0*sum(L)/len(L)\n  \n  triplets = [[0,0,0], [0,0,1], [0,1,1], \n              [0,0,2], [0,2,2], [0,1,2],\n              [10,10,9], [10,9,8], [10,9,9], [10, 10, 8],\n              ]\n  \n  def analyze_sum(sm, tgt):\n      av = 1.0 * sm / 3\n      av_cls = av % 1\n  \n      if av_cls > 0.1:\n          ns_max_val = math.ceil(av)\n      else:\n          ns_max_val = av \n      \n      s_max_val = 0 \n      if sm >= 2 and sm <= 28:\n          if av_cls > 0.5:\n              s_max_val = math.ceil(av) + 1\n          elif av_cls > 0.1:\n              s_max_val = math.ceil(av) \n          else:\n              s_max_val = av + 1\n      \n      if ns_max_val >= tgt:\n          res = [ns_max_val, None]\n          kind = 1\n      elif s_max_val < tgt:\n          res = [None, None]\n          kind = 0\n      else:\n          res = [None, s_max_val]\n          kind = 2\n          \n      print sm, tgt, av, av_cls, ns_max_val, s_max_val, res, kind\n      return res, kind\n  \n  def analyze_triplet(trip, tgt):\n      sm = sum(trip)\n      analyze_triplet(sm, tgt)\n      \n  \n  def read_input(filename):\n      data = []\n      with open(filename, "r") as f:\n          cases = int(f.readline())\n          for _ in xrange(cases):\n              case = f.readline().strip().split()\n              case = [int(c) for c in case]\n              data.append({"ngoog": case[0], "ssurp": case[1], "ptgt": case[2],\n                           "trips": case[3:]})\n      return data\n  \n  def make_output(fname, output):\n      fname = fname + OEXT\n      with open(fname, "w") as f:\n          restext = []\n          for i, v in enumerate(output):\n              restext.append(CASE_PRFX % (i+1,) + str(v) + "\n")\n          f.writelines(restext)\n      \n  def main(fname):\n      data = read_input(fname)\n      output = []\n      for case in data:\n          ansys = [analyze_sum(c, case["ptgt"]) for c in case["trips"]]\n          non_surp_is_enough = len([k for _, k in ansys if k == 1])\n          surp_needed = len([k for _, k in ansys if k == 2])\n          if surp_needed >= case["ssurp"]:\n              res = non_surp_is_enough + case["ssurp"]\n          else:\n              res = non_surp_is_enough + surp_needed\n          output.append(res)\n      print "output:", output\n      make_output(fname, output)\n       \n  \n  main("examples.in")\n  main("small.in")\n <CODESPLIT> 52
 \n  \n  EOL = "\n"\n  \n  \n  def is_equal_approx(x, y, epsilon=1e-6):\n      """Returns True iff y is within relative or absolute 'epsilon' of x.\n      \n      By default, 'epsilon' is 1e-6.\n      """\n      if -epsilon <= x - y <= epsilon:\n          return True\n  \n      if -epsilon <= x <= epsilon or -epsilon <= y <= epsilon:\n          return False\n  \n      return (-epsilon <= (x - y) / x <= epsilon\n          or -epsilon <= (x - y) / y <= epsilon)\n    \n  def read_syms(fd):\n      """Read a line of whitespace separated symbols."""\n      return fd.readline().strip().split()\n  \n  def read_ints(fd):\n      """Read a line of whitespace separated integers."""\n      return [int(p) for p in read_syms(fd)]\n  \n  def read_floats(fd):\n      """Read a line of whitespace separated floats."""\n      return [float(p) for p in read_syms(fd)]\n  \n  \n  class Mtrx(object):\n      """A matrix object."""\n      \n      def __init__(self, rows, cols, data):\n          assert len(data) == rows * cols\n          self.rows = rows\n          self.cols = cols\n          self.data = data\n          \n      def cell(self, r, c):\n          return self.data[r * self.cols + c]\n      \n      def getrow(self, i):\n          return [self.cell(i, c) for c in xrange(self.cols)]\n  \n      def getcol(self, i):\n          return [self.cell(c, i) for c in xrange(self.rows)]\n      \n      @classmethod\n      def readfromfile(cls, fd, readfunc, rows=None, cols=None):\n          """Read matrix from file, assuming first line at location is `R C`.\n          \n          Return a new Mtrx object. Reading values is performed by the `readfunc`.\n          Pre-determined size can be passed using `rows` and `cols`.\n          """\n          data = []\n          if rows is None:\n              assert cols is None\n              rows, cols = read_ints(fd)\n          else:\n              assert cols is not None\n          for _ in range(rows):\n              line = readfunc(fd)\n              assert len(line) == cols\n              data.extend(line)\n          return Mtrx(rows, cols, data)\n              \n      @classmethod\n      def read_int_matrix(cls, fd, rows=None, cols=None):\n          return cls.readfromfile(fd, read_ints, rows, cols)\n              \n      @classmethod\n      def read_sym_matrix(cls, fd, rows=None, cols=None):\n          return cls.readfromfile(fd, read_syms, rows, cols)\n              \n      def __str__(self):\n          res = ""\n          for i in xrange(self.rows):\n              res += str(self.getrow(i)) + EOL\n          return res\n      \n      def __repr__(self):\n          return "{}({}, {}, {})".format(self.__class__.__name__, self.rows,\n                                         self.cols, self.data)\n  \n  \n  cachetotals = 0\n  cachemisses = 0\n  \n  def statreset():\n      global cachemisses, cachetotals\n      cachemisses = 0\n      cachetotals = 0\n  \n  class memoizeit(object):\n      """Decorator. Caches a function's return value each time it is called.\n      \n      If called later with the same arguments, the cached value is returned \n      (not reevaluated).\n      """\n      \n      def __init__(self, func):\n          self.func = func\n          self.cache = {}\n          \n      def __call__(self, *args):\n          \n          global cachetotals, cachemisses\n          cachetotals += 1\n          \n          try:\n              return self.cache[args]\n          except KeyError:\n              \n              cachemisses += 1\n              \n              value = self.func(*args)\n              self.cache[args] = value\n              return value\n          except TypeError:\n  \n              cachemisses += 1\n  \n              return self.func(*args)\n      \n      @property\n      def __name__(self):\n          return self.func.__name__\n      \n      def __get__(self, obj, objtype):\n          """Support instance methods."""\n          return functools.partial(self.__call__, obj)\n  \n  \n  class timeit(object):\n      """Decorator that times a function.\n      \n      When function ends, print name, runtime, return value and cache stats.\n      """\n      \n      def __init__(self, func):\n          self.func = func\n          \n      def __call__(self, *args):\n          start = time.time()\n          value = self.func(*args)\n          delta = time.time() - start\n          cachedata = (1 - cachemisses/(cachetotals * 1.0)) if \\n              cachetotals else 0\n          print self.func.__name__, "{:7.3f}s, (res: {}, cache: {:.2%})".format(\n              delta, value, cachedata)\n          return value\n      \n      def __get__(self, obj, objtype):\n          return functools.partial(self.__call__, obj)\n  \n  \n  def read_input(filename):\n      data = []\n      with open(filename, "r") as f:\n          cases = read_ints(f)[0]\n          for _ in xrange(cases):\n              case = {}\n              case["R"], case["C"], case["M"] = read_ints(f)\n              data.append(case)\n      return data\n  \n  def make_output(fname, output):\n      CASE_PRFX = "Case #%s: "\n      fname = fname + time.strftime("%H%M%S") + ".out"\n      with open(fname, "w") as f:\n          restext = []\n          print "Output content ==============="\n          for i, outdata in enumerate(output):\n              line = CASE_PRFX % (i + 1,) + EOL + str(outdata) + EOL\n              print line,\n              restext.append(line)\n          print "=" * 30\n          f.writelines(restext)\n  \n  \n  MINE = "*"\n  CLICK = "c"\n  UNK = "."\n  \n  class Board(object):\n      \n      def __init__(self, r, c):\n          self.rows = r\n          self.cols = c\n          self.edge_row_idx = self.rows - 1\n          self.edge_col_idx = self.cols - 1\n          self.board = [[UNK for _ in xrange(c)] for _ in xrange(r)]\n          self.board[0][0] = CLICK\n  \n      def fill_edge_row(self, m):\n          i = self.edge_col_idx\n          while m > 0 and i >= 0:\n              self.board[self.edge_row_idx][i] = MINE\n              i -= 1\n              m -= 1\n          self.edge_row_idx -= 1\n  \n      def fill_edge_col(self, m):\n          i = self.edge_row_idx\n          while m > 0 and i >= 0:\n              self.board[i][self.edge_col_idx] = MINE\n              i -= 1\n              m -= 1\n          self.edge_col_idx -= 1\n  \n      def __str__(self):\n          return EOL.join(["".join(r) for r in self.board])\n  \n  @memoizeit\n  def is_stage_solvable(rows, cols, mines):\n      """Return True iff stage is solvable. \n      Also return fill instruction:\n      0 if impossible/dontcare, 1 to fill row, 2 to fill column, \n      3 for row special (most in the row), 4 for col special (most in the col)\n      """\n      rc = rows * cols\n      \n      if mines == rc:\n          return False, 0\n  \n      if rows == 1:\n          return mines <= rc - 1, 2\n      if cols == 1:\n          return mines <= rc - 1, 1\n      \n      if mines == rc - 1:\n          return True, 1  # doesn't matter what to fill\n      \n      if mines > rc - 4:\n          return False, 0\n      \n      if rows == 2:\n          return (False, 0) if mines == 1 else (True, 2)\n      if cols == 2:\n          return (False, 0) if mines == 1 else (True, 1)\n          \n      if rows <= cols:\n          if mines >= rows:\n              return True, 2\n          if mines == rows - 1:\n              if mines == cols - 1:\n                  if rows == 3:\n                      return False, 0\n                  return True, 4 # L shape fill, most in the column\n              else:\n                  return True, 1 # fill row\n          return True, 2 \n      else:\n          if mines >= cols:\n              return True, 1\n          if mines == cols - 1:\n              if mines == rows - 1:\n                  if cols == 3:\n                      return False, 0\n                  return True, 3 # L shape fill, most in the row\n              else:\n                  return True, 2 # fill column\n          return True, 1 \n  \n  @timeit\n  def solveit(case):\n      rows = case["R"]\n      cols = case["C"]\n      mines = case["M"]\n      \n      b = Board(rows, cols)\n      r, c, m = rows, cols, mines\n      \n      while m >= 0:\n          okgo, howtofill = is_stage_solvable(r, c, m)\n          if not okgo:\n              return "Impossible"\n          if howtofill == 1: # fill row\n              b.fill_edge_row(m)\n              if m <= c:\n                  break # fill and done\n              m -= c\n              r -= 1\n          elif howtofill == 2: # fill column\n              b.fill_edge_col(m)\n              if m <= r:\n                  break # fill and done\n              m -= r\n              c -= 1\n          elif howtofill == 3: # L shape fill, most in the row\n              b.fill_edge_row(m - 1)\n              b.fill_edge_col(1)\n              break # fill and done\n          elif howtofill == 4: # L shape fill, most in the column\n              b.fill_edge_col(m - 1)\n              b.fill_edge_row(1)\n              break # fill and done\n          else:\n              assert False\n  \n      return str(b) \n  \n  \n  \n  @timeit\n  def main(fname):\n      data = read_input(fname)\n      output = []\n      for case in data:\n          statreset() # reset cache stats\n          res = solveit(case)\n          output.append(res)\n      make_output(fname, output)\n  \n  \n  if __name__ == '__main__':\n      main("C-small-attempt0.in")\n <CODESPLIT> 52
 \n  f = file("B-small-attempt0.in")\n  w = file("answer.txt", "w")\n  cnt = int(f.readline()[:-1])\n  for no in range(cnt):\n  	l = f.readline()[:-1].split()\n  	T, s, p = map(int, l[:3])\n  	ts = map(int, l[3:])\n  	ns = p*3-2 if p*3-2 > 0 else 0\n  	ss = p*3-4 if p*3-4 > 0 else 31\n  	l = filter(lambda x: x<ns, ts)\n  	c = min([len(filter(lambda x: x>=ss, l)), s])\n  	\n  	print>>w, "Case #%d:"%(no+1), T-len(l)+c\n  \n  \n <CODESPLIT> 53
 \n  lines = iter('''\n  13\n  5 5 23\n  3 1 1\n  1 3 1\n  2 2 1\n  4 7 3\n  10 10 82\n  10 1 4\n  1 10 5\n  2 10 8\n  10 2 8\n  2 10 9\n  10 2 7\n  5 3 3\n  '''.splitlines(False)[1:])\n  out = sys.stdout\n  \n  sys.setrecursionlimit(1500)\n  \n  \n  class MyException(Exception):\n  	pass\n  lines = iter(open(r'C-small-attempt7.in').readlines(False))\n  out = open('c-small.answer', 'w')\n  \n  def solve(C, R, M):\n  	board = [['.']*C for _ in range(R)]\n  	board[-1][-1] = 'c'\n  	try:\n  		for r in range(R-2):\n  			for c in range(C-2):\n  				if r == R-3 and c == C-3:\n  					raise StopIteration()\n  				board[r][c] = '*'\n  				M -= 1\n  				if M == 0:\n  					return board \n  	except StopIteration:\n  		pass\n  		\n  	if M % 2 == 0:\n  		for r in range(R-3):\n  			board[r][C-1] = '*'\n  			board[r][C-2] = '*'\n  			M -= 2\n  			if M == 0:\n  				return board\n  		for c in range(C-3):\n  			board[R-1][c] = '*'\n  			board[R-2][c] = '*'\n  			M -= 2\n  			if M == 0:\n  				return board\n  		\n  		\n  		raise MyException()\n  	else:\n  		board[R-3][C-3] = '*'\n  		M -= 1\n  		if M == 0:\n  			return board\n  		for r in range(R-2):\n  			board[r][C-1] = '*'\n  			board[r][C-2] = '*'\n  			M -= 2\n  			if M == 0:\n  				return board\n  		for c in range(C-2):\n  			board[R-1][c] = '*'\n  			board[R-2][c] = '*'\n  			M -= 2\n  			if M == 0:\n  				return board\n  		\n  		raise MyException()\n  		\n  	\n  caseCnt = int(next(lines))\n  \n  for case in range(1, caseCnt+1):\n  	R,C,M = map(int, next(lines).split())\n  	\n  	print('Case #%d:'%case, file=out)\n  	if M == 0:\n  		print('c' + '.'*(C-1), file=out)\n  		for _ in range(R-1):\n  			print('.'*C, file=out)\n  	elif R*C==M+1:\n  		print('c' + '*'*(C-1), file=out)\n  		for _ in range(R-1):\n  			print('*'*C, file=out)\n  	elif C == 1 and R == 1:\n  		print('Impossible', file=out)\n  	elif C == 1:\n  		if M > R-1:\n  			print('Impossible', file=out)\n  		else:\n  			print('c', file=out)\n  			for _ in range(R-M-1):\n  				print('.', file=out)\n  			for _ in range(M):\n  				print('*', file=out)\n  	elif R == 1:\n  		if M > C-1:\n  			print('Impossible', file=out)\n  		else:\n  			print('c' + '.'*(C-M-1) + '*'*M, file=out)\n  	elif C == 2:\n  		if M %2 or M//2 > R-2:\n  			print('Impossible', file=out)\n  		else:\n  			print('c.', file=out)\n  			for _ in range(R-M//2-1):\n  				print('..', file=out)\n  			for _ in range(M//2):\n  				print('**', file=out)\n  	elif R == 2:\n  		if M %2 or M//2 > C-2:\n  			print('Impossible', file=out)\n  		else:\n  			print('c' + '.'*(C-M//2-1) + '*'*(M//2), file=out)\n  			print(      '.'*(C-M//2)   + '*'*(M//2), file=out)\n  	elif M > R*C-4:\n  		print('Impossible', file=out)\n  	else:\n  		try:\n  			board = solve(C, R, M)\n  			for line in board:\n  				print(''.join(line), file=out)\n  		except MyException:\n  			print('Impossible', file=out)\n  	\n  	\n <CODESPLIT> 53
 \n  \n  for i, line in enumerate(sys.stdin):\n      if i == 0:\n          continue\n  \n      params = [int(n) for n in line.split(' ')]\n      (N, S, p) = params[:3]\n      scores = params[3:]\n  \n      (clear, possible) = (0, 0)\n      normal_min = max(p * 3 - 2, 0)\n      suprising_min = max(p * 3 - 4, 0)\n      for score in scores:\n          if p > score:\n              continue\n          elif score >= normal_min:\n              clear += 1\n          elif score >= suprising_min:\n              possible += 1\n  \n      ans = clear + min(possible, S)\n      print 'Case #%(i)s: %(ans)s' % locals()\n <CODESPLIT> 54
 \n  \n  \n  def show_board(board):\n      for row in board:\n          print ''.join(row)\n  \n  \n  N = int(sys.stdin.readline())\n  \n  for T in range(1, N+1):\n      (R, C, M) = map(int, sys.stdin.readline().split(' '))\n      E = R*C-M # empty\n      possible, reverse, need_adjust, column_base = (False, False, False, False)\n      if C > R:\n          (R, C) = (C, R)\n          reverse = True\n  \n      W = 0\n      lastRow = 0\n      if E == 0:\n          pass\n      elif E == 1 or M == 0:\n          W = C\n          possible = True\n      elif C == 1:\n          W = 1\n          if E > 0:\n              possible = True\n      elif C == 2:\n          W = 2\n          lastRow = int(E / 2) + 1   # 1 base\n          if E % 2 == 0 and E >= 4:\n              possible = True\n      elif C >= 3:\n          for w in range(2, C+1):\n              lastRow = int(E / w) + 1   # 1 base\n              if lastRow > R: continue\n              lastRowNum = E % w\n              \n              if lastRow == 2 and lastRowNum == 0:\n                  pass\n              elif lastRow == 2:   # lastRow == 1 => impossible\n                  if lastRowNum == 0:\n                      W = w\n                      possible = True\n                      break\n              elif lastRow >= 3:\n                  if lastRowNum >= 2 or lastRowNum == 0:\n                      W = w\n                      possible = True\n                      break\n                  elif C >= 4 and lastRowNum == 1 and R >= 3:\n                      W = w\n                      possible = True\n                      need_adjust = True\n                      break\n          if not possible:\n              for w in range(2, R+1):\n                  lastRow = int(E / w) + 1   # 1 base\n                  if lastRow > R: continue\n                  lastRowNum = E % w\n                  if lastRow == 2 and lastRowNum == 0:\n                      pass\n                  elif lastRow == 2:   # lastRow == 1 => impossible\n                      if lastRowNum == 0:\n                          W = w\n                          possible = True\n                          column_base = True\n                          break\n                  elif lastRow >= 3:\n                      if lastRowNum >= 2 or lastRowNum == 0:\n                          W = w\n                          possible = True\n                          column_base = True\n                          break\n                      elif C >= 4 and lastRowNum == 1 and R >= 3:\n                          W = w\n                          possible = True\n                          need_adjust = True\n                          column_base = True\n                          break\n                                  \n      if not possible:\n          if reverse:\n              R, C = (C, R)        \n          ans = 'Impossible %sx%s M=%s' % (R, C, M)\n          print 'Case #%(T)s: %(ans)s' % locals()\n          continue\n  \n      board = [['*'] * C for i in range(R)]\n      for i in range(E):\n          if not column_base:\n              c = i % W\n              r = i / W\n          else:\n              r = i % W\n              c = i / W            \n          board[r][c] = '.'\n      if need_adjust:\n          board[lastRow-1][1], board[lastRow-2][-1] = board[lastRow-2][-1], board[lastRow-1][1]\n      if reverse:\n          board = map(list, zip(*board))\n          R, C = (C, R)\n  \n      clicked = False\n      for r in range(R):\n          if clicked: break\n          for c in range(C):\n              cell = board[r][c]\n              if cell != '.': continue\n              if E == 1:\n                  board[r][c] = 'c'\n                  clicked = True\n                  break\n              \n              if r >= 1  and c >= 1  and board[r-1][c-1] == '*': continue\n              if r >= 1              and board[r-1][c]   == '*': continue\n              if r >= 1  and c < C-1 and board[r-1][c+1] == '*': continue\n              if             c >= 1  and board[r][c-1]   == '*': continue\n              if             c < C-1 and board[r][c+1]   == '*': continue\n              if r < R-1 and c >= 1  and board[r+1][c-1] == '*': continue\n              if r < R-1             and board[r+1][c]   == '*': continue\n              if r < R-1 and c < C-1 and board[r+1][c+1] == '*': continue\n              board[r][c] = 'c'\n              clicked = True\n              break\n  \n      ans = 'Possible' if possible else 'Impossible'\n      print 'Case #%(T)s:' % locals()\n      show_board(board)\n <CODESPLIT> 54
 \n  \n  def findbest(score):\n  	if score == 0: return (0, 0)\n  \n  	best = math.ceil(score / 3)\n  	bestsurp = round(score / 3) + 1\n  \n  	return (best, bestsurp)\n  	\n  sys.stdin.readline()\n  \n  casenum = 0\n  for line in sys.stdin:\n  	casenum += 1\n  \n  	data = line.strip().split(' ')\n  	maxsurprising = int(data[1])\n  	p = int(data[2])\n  	scores = data[3:]\n  	maxgooglers = 0\n  \n  	for s in scores:\n  		(best, bestsurp) = findbest(int(s))\n  		if best >= p:\n  			maxgooglers += 1\n  		else:\n  			if bestsurp >= p and maxsurprising > 0:\n  				maxgooglers += 1\n  				maxsurprising -= 1\n  \n  	print("Case #%d: %d" % (casenum, maxgooglers))\n <CODESPLIT> 55
 \n  \n  ncases = int(sys.stdin.readline().strip())\n  \n  def print_board(r, c, free):\n      board = {}\n      for row in range(0, r):\n          board[row] = {}\n          for col in range(0, c):\n              board[row][col] = '*'\n  \n      pending = free\n  \n      if free == 1:\n          board[0][0] = '.'\n      elif r == 1 or c == 1:\n          for row in range(0, r):\n              for col in range(0, c):\n                  if pending > 0:\n                      pending -= 1\n                      board[row][col] = '.'\n      else:\n          for row in range(0,2):\n              for col in range(0,2):\n                  board[row][col] = '.'\n          pending -= 4\n          col=2\n          row=2\n  \n          while pending >= 2 and (col<c or row<r):\n              if pending >= 2 and col<c:\n                  board[0][col] = '.'\n                  board[1][col] = '.'\n                  col += 1\n                  pending -= 2\n              if pending >= 2 and row<r:\n                  board[row][0] = '.'\n                  board[row][1] = '.'\n                  row += 1\n                  pending -= 2\n  \n          for row in range(2, r):\n              for col in range(2, c):\n                  if pending > 0:\n                      board[row][col] = '.'\n                      pending -= 1\n  \n      board[0][0] = 'c'\n  \n      for row in range(0, r):\n          line = ''\n          for col in range(0, c):\n              line += board[row][col]\n          print(line)\n  \n  \n  for t in range(1, ncases+1):\n      values = sys.stdin.readline().strip().split()\n      r = int(values[0])\n      c = int(values[1])\n      m = int(values[2])\n  \n      cells = r * c\n      free = cells - m\n  \n      possible = False\n  \n      if r == 1 or c == 1:\n          if free >= 1:\n              possible = True\n      elif r == 2 or c == 2:\n          if free == 1 or (free >= 4 and free%2 == 0):\n              possible = True\n      else:\n          if free == 1 or (free >= 4 and free != 5 and free != 7):\n              possible = True\n  \n      print("Case #{0}:".format(t))\n  \n      if possible:\n          print_board(r, c, free)\n      else:\n          print("Impossible")\n <CODESPLIT> 55
T = int(raw_input())\n  \n  for z in xrange(1, T+1):\n      a = map(int, raw_input().split())\n      s, p = a[1:3]\n      a = a[3:]\n      A = 0 if p == 0 else 3*p - 2\n      B = 0 if p == 0 else 1 if p == 1 else 3*p-4\n      x = len(filter(lambda x: x >= A, a))\n      y = len(filter(lambda x: x >= B, a)) - x\n      res = x + min(s, y)\n      print "Case #%d:" % z, res\n <CODESPLIT> 56
 \n  T = int(raw_input())\n  \n  def generate(R, C, a, sw):\n      if sw:\n          R, C = C, R\n      res = [['*']*C for i in xrange(R)]\n      for i in xrange(len(a)):\n          for j in xrange(a[i]):\n              if sw:\n                  res[j][i] = '.'\n              else:\n                  res[i][j] = '.'\n      res[0][0] = 'c'\n      return str(res)[2:-2].replace(' ', '').replace("'",'').replace('[', '').replace('],','\n').replace(',', '')\n  \n  \n  def solveEq(k, s, x1):\n      if 2*(x1 + k - 2) > s or k*x1 < s:\n          return None\n      r = [0]*k\n      r[0] = r[1] = x1\n      s -= 2*x1\n      for i in xrange(k-2, 0, -1):\n          t = min(x1, s - 2*i + 2)\n          r[k-i] = t\n          s -= t\n      return r\n  \n  def solve(R, C, M):\n      S = R*C\n      nm = S - M\n      if R == 1 or C == 1:\n          if R == 1:\n              return '*'*M + '.'*(S-M-1) + 'c'\n          else:\n              return '*\n'*M + '.\n'*(S-M-1) + 'c'\n      else:\n          sw = False\n          if R > C:\n              R, C = C, R\n              sw = True\n          if nm == 2 or nm == 3 or nm == 5 or nm == 7 or (R == 2 and nm%2 == 1 and nm > 1):\n              return "Impossible"\n          if nm == 1:\n              return generate(R, C, [1], sw)\n          for k in xrange(2, R+1):\n              for x1 in xrange(2, C+1):\n                  r = solveEq(k, nm, x1)\n                  if r != None:\n                      return generate(R, C, r, sw)\n          return "Something wrong"\n  \n  for z in xrange(T):\n      c, f, x = map(int, raw_input().split())\n      print "Case #%d:\n%s" % (z+1, solve(c, f, x))\n <CODESPLIT> 56
 \n  main = interact (unlines . map showCase . zip [1..] . tail . lines)\n    where\n      showCase (i, t) = "Case #" ++ show i ++ ": " ++ solve t\n  \n  solve = show . solve' . map read . words\n    where\n      solve' (n:s:p:ts) = \n          let pts = map maxPoints ts\n              directs = filter ((>= p) . fst) pts\n              surps = filter (\(pd, ps) -> pd < p && ps >= p) pts\n          in length directs + min (length surps) s\n          \n  maxPoints :: Int -> (Int, Int)\n  maxPoints tot = \n      (maxScore $ scores normal, maxScore $ scores surprising)\n    where\n      scores cond = [ (x, y, z) |\n          x <- [0..10], y <- [0..10], z <- [0..10]\n          , x + y + z == tot, cond (x, y, z)\n          ]\n      normal t = bestScore t - badScore t <= 1\n      surprising t = bestScore t - badScore t <= 2\n      maxScore = maximum . map bestScore \n  \n  bestScore (x, y, z) = maximum [x, y, z]\n  badScore (x, y, z) = minimum [x, y, z]\n <CODESPLIT> 57
t = int(input())\n  \n  VIDE = 0\n  MINE = 1\n  CURSEUR = 2\n  \n  def test_position(arr, lignes, cols, y, x):\n      def voisinage_libre(arr, y, x):\n          if y > 0:\n              if x > 0 and arr[y-1][x-1] == MINE:\n                  return False\n              if arr[y-1][x] == MINE:\n                  return False\n              if x < cols - 1 and arr[y-1][x+1] == MINE:\n                  return False\n  \n          if x > 0 and arr[y][x-1] == MINE:\n              return False\n          if x < cols - 1 and arr[y][x+1] == MINE:\n              return False\n  \n          if y < lignes - 1:\n              if x > 0 and arr[y+1][x-1] == MINE:\n                  return False\n              if arr[y+1][x] == MINE:\n                  return False\n              if x < cols - 1 and arr[y+1][x+1] == MINE:\n                  return False\n  \n          return True\n  \n      def remplissage_rec(arr, y, x):\n          if x < 0 or y < 0 or x >= cols or y >= lignes:\n              return\n          elif arr[y][x] == CURSEUR:\n              return\n  \n          arr[y][x] = CURSEUR\n          if voisinage_libre(arr, y, x):\n              remplissage_rec(arr, y-1, x-1)\n              remplissage_rec(arr, y-1, x)\n              remplissage_rec(arr, y-1, x+1)\n              remplissage_rec(arr, y, x-1)\n              remplissage_rec(arr, y, x+1)\n              remplissage_rec(arr, y+1, x-1)\n              remplissage_rec(arr, y+1, x)\n              remplissage_rec(arr, y+1, x+1)\n  \n      if arr[y][x] != VIDE:\n          return False\n  \n      arr2 = [ [ arr[i][j] for j in range(0, cols) ] for i in range(0, lignes) ]\n  \n      remplissage_rec(arr2, y, x)\n  \n      for i in range(0, lignes):\n          for j in range(0, cols):\n              if arr2[i][j] == VIDE:\n                  return False\n      return True\n  \n  def dfs(arr, lignes, cols, mines, y, x):\n      cases_restantes = (cols - x) + ((lignes - y) * cols)\n  \n      if cases_restantes < mines:\n          return None\n      elif mines <= 0:\n          for i in range(0, lignes):\n              for j in range(0, cols):\n                  if test_position(arr, lignes, cols, i, j):\n                      return (i, j)\n      elif x >= cols:\n          return dfs(arr, lignes, cols, mines, y+1, 0)\n      elif y >= lignes:\n          return None\n      else:\n          res = dfs(arr, lignes, cols, mines, y, x+1)\n          if res != None:\n              return res\n  \n          arr[y][x] = MINE\n          res = dfs(arr, lignes, cols, mines-1, y, x+1)\n          if res != None:\n              return res\n  \n          arr[y][x] = VIDE\n          return None\n  \n  for i in range(0, t):\n      ligne  = input().split(" ")\n      lignes = int(ligne[0])\n      cols   = int(ligne[1])\n      mines  = int(ligne[2])\n  \n      arr = [ [VIDE] * cols for _ in range(0, lignes) ]\n  \n      res = dfs(arr, lignes, cols, mines, 0, 0)\n  \n      print ("Case #"+str(i+1)+":")\n  \n      if res == None:\n          print ("Impossible")\n      else:\n          (y, x) = res\n  \n          for i in range(0, lignes):\n              for j in range(0, cols):\n                  if i == y and j == x:\n                      print('c', end='')\n                  elif arr[i][j] == VIDE:\n                      print('.', end='')\n                  else:\n                      print('*', end='')\n  \n              print('', end='\n')\n <CODESPLIT> 57
 \n  if __name__ == "__main__":\n      f = sys.stdin\n      if len(sys.argv) >= 2:\n          fn = sys.argv[1]\n          if fn != '-':\n              f = open(fn)\n  \n      t = int(f.readline())\n      for _t in xrange(t):\n          ns = map(int, f.readline().split())\n          n = ns[0]\n          s = ns[1]\n          p = ns[2]\n          assert len(ns) == n + 3\n          scores = ns[3:3+n]\n  \n          sure = 0\n          if_surprising = 0\n          for x in scores:\n              not_surprising = (x + 2) / 3\n              is_surprising = (x + 4) / 3\n              if not_surprising >= p:\n                  sure += 1\n              elif (2 <= x <= 28) and is_surprising >= p:\n                  if_surprising += 1\n          print "Case #%d: %d" % (_t+1, sure + min(if_surprising, s))\n <CODESPLIT> 58
 \n  if __name__ == "__main__":\n      f = sys.stdin\n      if len(sys.argv) >= 2:\n          fn = sys.argv[1]\n          if fn != '-':\n              f = open(fn)\n  \n      T = int(f.readline())\n      for _T in xrange(T):\n          R, C, M = map(int, f.readline().split())\n  \n          print "Case #%d:" % (_T+1)\n  \n          left = R * C - M\n  \n          if R == 1:\n              s = 'c'\n              s += '.' * (left - 1)\n              s += '*' * M\n              print s\n              continue\n          if C == 1:\n              print 'c'\n              for i in xrange(left - 1):\n                  print '.'\n              for i in xrange(M):\n                  print '*'\n              continue\n  \n          if left == 1:\n              print 'c' + '*' * (C-1)\n              for i in xrange(R-1):\n                  print '*' * C\n              continue\n  \n          if (R == 2 or C == 2) and (M % 2 == 1 or left == 2):\n              print "Impossible"\n              continue\n          if R == 2:\n              assert left not in (2, 3, 5, 7)\n              assert left >= 4\n              print 'c' + '.' * (left/2 - 1) + '*' * (M/2)\n              print '.' + '.' * (left/2 - 1) + '*' * (M/2)\n              continue\n          if C == 2:\n              assert left >= 4\n              assert left not in (2, 3, 5, 7)\n              print 'c.'\n              left -= 2\n              R -= 1\n              while left:\n                  print '..'\n                  left -= 2\n                  R -= 1\n              assert R >= 0\n              while R:\n                  print '**'\n                  R -= 1\n              continue\n  \n          assert R >= 3\n          assert C >= 3\n  \n          if left == 4:\n              print 'c.' + '*' * (C-2)\n              print '..' + '*' * (C-2)\n              for i in xrange(R-2):\n                  print '*' * C\n              continue\n  \n          if left in (2, 3, 5, 7):\n              print "Impossible"\n              continue\n  \n          assert left >= 6\n  \n          cols = max(3, (left + R-1) // R)\n  \n          if left % cols == 1:\n              assert left >= 10\n  \n              print 'c' + '.' * (cols - 1) + '*' * (C - cols)\n              left -= cols\n              R -= 1\n  \n              while left > cols + 1:\n                  print '.' * cols + '*' * (C - cols)\n                  left -= cols\n                  R -= 1\n              assert left == cols + 1\n              print '.' * (cols - 1) + '*' * (C - cols + 1)\n              print '.' * (2) + '*' * (C - 2)\n              R -= 2\n  \n              assert R >= 0\n  \n              while R:\n                  print '*' * C\n                  R -= 1\n              continue\n          else:\n              assert left >= 6\n  \n              print 'c' + '.' * (cols - 1) + '*' * (C - cols)\n              left -= cols\n              R -= 1\n  \n              while left > cols:\n                  print '.' * cols + '*' * (C - cols)\n                  left -= cols\n                  R -= 1\n              assert left >= 2\n              print '.' * (left) + '*' * (C - left)\n              R -= 1\n  \n              assert R >= 0\n  \n              while R:\n                  print '*' * C\n                  R -= 1\n              continue\n  \n          1/0\n <CODESPLIT> 58
T = int(raw_input());\n  for i in range(T):\n     Data = map(int, raw_input().split());\n     N = Data.pop(0);\n     S = Data.pop(0);\n     p = Data.pop(0);\n     \n     Good = 0;\n     for score in Data:\n        if score >= 3*p-2:\n           Good += 1;\n        else:\n           if (S > 0) and (score >= 3*p-4) and (score >= p):\n              S -= 1;\n              Good += 1;\n  \n     print "Case #%d:" % (i+1),;\n     print Good;\n     \n  \n <CODESPLIT> 59
def Trivial(R,C,char):\n      for i in range(R):\n          Ans = '';\n          for j in range(C):\n              if (i==j==0):\n                  Ans += 'c';\n              else:\n                  Ans += char;\n          print Ans;\n  \n  \n  def Draw1(R,C,Blank):\n      Ans = "c";\n      for i in range(Blank-1):\n          Ans += '.';\n      for i in range(R*C-Blank):\n          Ans += '*';\n      if (R == 1):\n          print Ans;        \n          return;\n      if (C == 1):\n          for i in range(len(Ans)):\n              print Ans[i];\n  \n  def Draw2(R,C,Blank):\n      if (Blank%2 != 0) or (Blank == 2):\n          print "Impossible";\n          return;\n      Row1 = '.'*(Blank/2) + '*'*(Mine/2);\n      Row0 = 'c' + Row1[1:];\n      if R==2:\n          print Row0;\n          print Row1;\n      else:\n          for i in range(len(Row0)):\n              print Row0[i]+Row1[i];\n      return;\n  \n  \n  def Generate(R, C, Blank):\n      TODO = Blank;\n      Spaces = [0]*R;\n      if TODO <= 2*C:\n          if TODO%2 == 0:\n              Spaces[0] = TODO/2;\n              Spaces[1] = TODO-Spaces[0];\n          else:\n              if (TODO == 7):\n                  Spaces[0] = 3;\n                  Spaces[1] = 2;\n                  Spaces[2] = 2;\n              else:\n                  Spaces[0] = (TODO-3)/2;\n                  Spaces[1] = (TODO-3)/2;\n                  Spaces[2] = 3;\n      else:\n          row = 0;\n          if (TODO >= 2*C+2):\n              Spaces[0] = C;\n              Spaces[1] = C;\n              TODO -= 2*C;\n              row = 2;\n              \n          while TODO > C+1:\n              if (TODO == 2*C+1) and (C != 3):\n                  Spaces[row] = C-1;\n                  Spaces[row+1] = C-1;\n                  Spaces[row+2] = 3;\n                  TODO = 0;\n              else:\n                  Spaces[row] = C;\n                  TODO -= C;\n                  row += 1;\n          if (TODO == C+1):\n              Spaces[row] += C-1;\n              Spaces[row+1] = 2;\n              TODO = 0;\n          Spaces[row] += TODO;\n  \n      for r in range(R):\n          Ans = '.'*Spaces[r] + '*'*(C-Spaces[r]);\n          if r == 0:\n              Ans = 'c'+Ans[1:];\n          print Ans;\n  \n  \n  def Solve(R, C, M):\n      Blank = R*C-M;\n      if Blank == 0:\n          print "Impossible";\n          return;\n  \n      if (Blank == 1):\n          Trivial(R,C,'*');\n          return\n      if (Blank == R*C):\n          Trivial(R,C,'.');\n          return\n  \n      if (R == 1) or (C == 1):\n            Draw1(R,C,Blank);\n            return\n  \n      if (R-2)*(C-2) == 0:\n          Draw2(R,C,Blank);\n          return\n  \n      if Blank in [2,3,5,7]:\n          print "Impossible";\n          return;\n      \n      if (R >= 3) and (C >= 3):\n          Generate(R, C, Blank);\n  \n      return;\n  \n  \n  T = int(raw_input());\n  for q in range(T):\n      [Row,Col,Mine] = map(int, raw_input().split());\n  \n      Blanks = Row*Col - Mine;\n      \n      print "Case #%d:" % (q+1)\n      Solve(Row, Col, Mine);\n      \n          \n <CODESPLIT> 59
 \n  \n  \n  D1 = {} # no suprize\n  D2 = {} # surprize\n  for i in xrange(0, 31):\n      D1[i] = D2[i] = -1\n  \n  def precompute():\n      for a in xrange(0, 11):\n          for b in xrange(a, min(a+3,11)):\n              for c in xrange(b, min(a+3,11)):\n                  t = a+b+c\n                  assert a <= b <= c <= a+2 and c <= 11\n                  if c < a+2:\n                      D1[t] = max(D1[t], c)\n                  else: # that is, c == a+2, we have a suprize\n                      D2[t] = max(D2[t], c)\n  \n  \n  precompute()\n  \n  def case(S, P, ts):\n      res_n = 0\n      res_s = 0\n      for t in ts:\n          if D1[t] >= P:\n              res_n+=1\n          elif D2[t]>=P:\n              res_s+=1\n      return (res_n + min(res_s, S))\n  \n  \n  def solve(fin, fout):\n      T = int(fin.readline())\n      for t in xrange(T):\n          nums = map(int, fin.readline().strip().split(" "))\n          N, S, P = nums[:3]\n          ts = nums[3:]\n          assert len(ts) == N    \n          fout.write("Case #%i: %i\n" % (t+1, case(S,P,ts)) )\n      return True\n  \n  if __name__ == "__main__":\n      with open(sys.argv[1],'r') as fin:\n          with open(sys.argv[2], 'w') as fout:\n              solve(fin, fout)\n <CODESPLIT> 60
def get_a(r, c, f='.'):\n      A = []\n      for i in xrange(r):\n          A.append([f] * c)\n      return A\n  \n  \n  def apply(A, r, c, B):\n      for i, b in enumerate(B):\n          for j, v in enumerate(b):\n              A[r + i][c + j] = v\n  \n  \n  def draw(A):\n      if A is None:\n          return '\nImpossible'\n      res = ['']\n      for a in A:\n          res.append(''.join(a))\n      return '\n'.join(res)\n  \n  \n  def trans(A):\n      if not A:\n          return None\n      B = get_a(len(A[0]), len(A))\n      for i, a in enumerate(A):\n          for j, v in enumerate(a):\n              B[j][i] = v\n      return B\n  \n  \n  def check(A, m, r, c):\n      if A is None:\n          return True\n      cnts = {'c': 0, '*': 0, '.': 0}\n  \n      assert len(A) == r\n      for i in xrange(r):\n          assert len(A[i]) == c\n          for j in xrange(c):\n              cnts[A[i][j]] += 1\n      assert cnts['*'] == m\n      assert cnts['c'] == 1\n      assert cnts['.'] == r * c - m - 1\n  \n  \n  def CASE(IN):\n      def rstr():\n          return IN.readline().strip()\n  \n      def rint():\n          return int(rstr())\n  \n      def rints():\n          return map(int, rstr().split())\n      r, c, m = rints()\n      A = solve(m, r, c)\n      if A:\n          A[-1][-1] = 'c'\n      check(A, m, r, c)\n      return draw(A)\n  \n  \n  def solve(m, r, c):\n      if r > c:\n          return trans(solve(m, c, r))\n      assert r <= c\n      assert m != r * c\n      e = r * c - m\n      if e == 1:\n          A = get_a(r, c, '*')\n          return A\n      if r == 1:\n          A = get_a(1, c, '.')\n          for i in xrange(m):\n              A[0][i] = '*'\n          return A\n      if r == 2:\n          if e == 2 or e % 2 == 1:\n              return None\n          A = get_a(2, c, '.')\n          assert m % 2 == 0\n          for i in xrange(m / 2):\n              A[0][i] = A[1][i] = '*'\n          return A\n      assert r >= 3\n      A = get_a(r, c, '*')\n      if e in (2, 3, 5, 7):\n          return None\n      E = [c] * (e / c) + ([e % c] if e % c else [])\n      if sum(E) < e:\n          E.append(e % c)\n          assert sum(E) == e\n      if len(E) == 1:\n          E = [e / 2] * 2\n          if sum(E) < e:\n              e.append(1)\n      if E[0] != E[1]:\n          s = sum(E[:2])\n          E[0] = E[1] = s / 2\n          if sum(E[:2]) != s:\n              assert len(E) == 2\n              E.append(1)\n      if E[-1] == 1:\n          if len(E) > 3:\n              E[-2] -= 1\n              E[-1] += 1\n          else:\n              E[0] -= 1\n              E[1] -= 1\n              E[2] += 2\n      for i in xrange(len(E)):\n          for j in xrange(E[i]):\n              A[-i - 1][-j - 1] = '.'\n      return A\n  \n  \n  def RUN(IN, OUT):\n      t = int(IN.readline().strip())\n      for i in xrange(1, t + 1):\n          OUT.write("Case #%i: %s\n" % (i, CASE(IN)))\n  \n  if __name__ == "__main__":\n      RUN(sys.stdin, sys.stdout)\n <CODESPLIT> 60
'''\n  Created on 2012-4-14\n  \n  @author: hemnd\n  '''\n  def cal(args):\n      rslt = 0\n      N = int(args[0])\n      S = int(args[1])\n      p = int(args[2])\n      for i in range(N):\n          s = int(args[i + 3])\n          e = s / 3\n          r = s % 3\n          if e >= p:\n              rslt += 1\n          elif r == 1:\n              if e + 1 >= p:\n                  rslt += 1\n          elif r == 0:\n              if e == 0:\n                  continue\n              if S > 0 and e + 1 >= p:\n                  rslt += 1\n                  S -= 1\n          elif r == 2:\n              if e + 1 >= p:\n                  rslt += 1\n              elif S > 0 and e + 2 >= p:\n                  rslt += 1\n                  S -= 1\n      return rslt\n  \n  inputFile = open('B-small-attempt0.in', 'r')\n  inputLines = inputFile.readlines()\n  inputFile.close()\n  \n  T = int(inputLines[0])\n  outputLines = []\n  \n  for i in range(1, T + 1):\n      args = inputLines[i].strip().split(' ')\n      outputLines.append('Case #%d: %d\n' % (i, cal(args)))\n      print outputLines[i - 1],\n  \n  outputFile = open('B-small.out', 'w')\n  outputFile.writelines(outputLines)\n  outputFile.close()\n <CODESPLIT> 61
 \n  def put_mines_last_step(R, C, M, grid):\n  	if M == 0:\n  		return\n  	R -= 1\n  	C -= 1\n  	grid[R][C] = '*'\n  	M -= 1\n  	r = R - 1\n  	c = C - 1\n  	while M > 0:\n  		if r > c:\n  			grid[r][C] = '*'\n  			r -= 1\n  		else:\n  			grid[R][c] = '*'\n  			c -= 1\n  		M -= 1\n  \n  def put_mines(R, C, M, grid):\n  	if R > C:\n  		if M < C:\n  			put_mines_last_step(R, C, M, grid)\n  			return\n  		for i in range(C):\n  			grid[R - 1][i] = '*'\n  		put_mines(R - 1, C, M - C, grid)\n  		return\n  	if M < R:\n  		put_mines_last_step(R, C, M, grid)\n  		return\n  	for i in range(R):\n  		grid[i][C - 1] = '*'\n  	put_mines(R, C - 1, M - R, grid)\n  	return\n  \n  def process(R, C, M):\n  	rlt = ''\n  	grid = []\n  	for i in range(R):\n  		grid.append(['.'] * C)\n  	put_mines(R, C, M, grid)\n  	if not C == 1:\n  		for i in range(R):\n  			if not grid[i][0] == '.':\n  				break\n  			if not grid[i][1] == '.':\n  				return '\nImpossible'\n  	if not R == 1:\n  		for i in range(C):\n  			if not grid[0][i] == '.':\n  				break\n  			if not grid[1][i] == '.':\n  				return '\nImpossible'\n  	grid[0][0] = 'c'\n  	for i in grid:\n  		rlt += '\n' + ''.join(i)\n  	return rlt\n  \n  input_file = open(sys.argv[1], 'r')\n  T = int(input_file.readline())\n  for i in range(T):\n  	(R, C, M) = map(int, input_file.readline().split())\n  	print 'Case #%d:' % (i + 1), process(R, C, M)\n <CODESPLIT> 61
input_file = 'B-small-attempt1.in'\n  output_file = 'b.out'\n  \n  \n  def solvecase(inp):\n  	data = [int(n) for n in inp.split()]\n  	N, S, p = data[0:3]\n  	if p == 0:\n  		return N\n  	t = data[3:]\n  	ret = 0\n  	for br in t:\n  		d, r = br / 3, br % 3\n  		if br == 0 or p - d > 2:\n  			continue\n  		if (d >= p) or (r and (d + 1) >= p):\n  			ret += 1\n  		elif S and (d + max(r, 1)) >= p:\n  			ret += 1\n  			S -= 1\n  	return ret\n  \n  lines = open(input_file, 'r').readlines()\n  out = open(output_file, 'w')\n  \n  for i, l in enumerate(lines[1:]):\n  	sout = 'Case #%i: %i' % (i + 1, solvecase(l))\n  	print sout\n  	out.write(sout + '\n')\n  \n  out.close()\n <CODESPLIT> 62
 \n  INPUT = 'C-small-attempt0.in'\n  OUTPUT = 'C-small-attempt0.out'\n  \n  \n  def solve(R, C, M):\n      grid = [[0 for c in range(C)] for r in range(R)]\n  \n      def get_cell(cell_r, cell_c):\n          if not(0 <= cell_r < R):\n              return None\n          if not(0 <= cell_c < C):\n              return None\n          return grid[cell_r][cell_c]\n  \n      def for_each_neighbour(cell_r, cell_c, func):\n          ret = []\n          coords = (\n              (cell_r - 1, cell_c - 1), (cell_r - 1, cell_c), (cell_r - 1, cell_c + 1),\n              (cell_r, cell_c - 1), (cell_r, cell_c + 1),\n              (cell_r + 1, cell_c - 1), (cell_r + 1, cell_c), (cell_r + 1, cell_c + 1)\n          )\n          for nb in coords:\n              if get_cell(nb[0], nb[1]) is not None:\n                  ret.append(func(nb[0], nb[1]))\n          return ret\n  \n      def mark_dirty(cell_r, cell_c):\n          if grid[cell_r][cell_c] != '*':\n              grid[cell_r][cell_c] += 1\n      \n      def unmark_dirty(cell_r, cell_c):\n          if grid[cell_r][cell_c] != '*':\n              grid[cell_r][cell_c] -= 1\n  \n      def check_empty_neighbours(cell_r, cell_c):\n          return (0 in for_each_neighbour(cell_r, cell_c, lambda r, c: get_cell(r, c)))\n  \n      def click():\n          for i, row in enumerate(grid):\n              for j, cell in enumerate(row):\n                  if cell != '*':\n                      if cell == 0 or ((R * C - M) == 1):\n                          grid[i][j] = 'c'\n                          return\n  \n      def place_mine():\n          for i, row in enumerate(grid):\n              for j, cell in enumerate(row):\n                  if cell == '*':\n                      continue\n                  prevstate = grid[i][j]\n                  grid[i][j] = '*'\n                  for_each_neighbour(i, j, mark_dirty)\n                  if not (True in for_each_neighbour(i, j, check_empty_neighbours)):\n                      grid[i][j] = prevstate\n                      for_each_neighbour(i, j, unmark_dirty)\n                  else:\n                      return True\n          return False\n  \n      for m in range(M):\n          if not place_mine():\n              return 'Impossible\n'\n  \n      click()\n  \n      ret = ''\n      for row in grid:\n          ret = ret + ''.join(map(lambda c: '.' if isinstance(c, int) else c, row)) + '\n'\n  \n      return ret\n  \n  \n  if __name__ == '__main__':\n      inp = open(INPUT)\n      out = open(OUTPUT, 'w')\n      \n      T = int(inp.readline())\n  \n      for case in range(T):\n          sol = solve(*map(int, inp.readline().split()))\n          out.write('Case #%i:\n%s' % (case + 1, sol))\n <CODESPLIT> 62
 \n  '''\n  Limits: T in [1,100], S in [0,N], p in [0,10], Ti in [0, 30]\n  At least S of the ti values will be between 2 and 28, inclusive.\n  \n  Small dataset 1 = N = 3.\n  Large dataset 1 = N = 100.\n  \n  Sample Input \n  4\n  3 1 5 15 13 11\n  3 0 8 23 22 21\n  2 1 1 8 0\n  6 2 8 29 20 8 18 18 21\n  \n  Output \n  Case #1: 3\n  Case #2: 2\n  Case #3: 1\n  Case #4: 3\n  '''\n  \n  \n  \n  inf = open(sys.argv[1])\n  def input(): return inf.readline().strip()\n  \n  def maxBestDancers(N, S, p, *Ti):\n      cnt = 0\n      for score in Ti:\n          mx = (score + 2) // 3\n          if mx >= p:\n              cnt += 1\n          elif mx >= p-1 > 0 and S>0:\n              S -= 1\n              cnt += 1\n      return cnt\n  \n  for caseNo in range(1, int(input())+1):\n      print 'Case #%d:' % caseNo,\n      lst = map(int, input().split())\n      print maxBestDancers(*lst)\n  \n <CODESPLIT> 63
 \n  '''\n  Input\n  The first line of the input gives the number of test cases, T. T lines follow. \n  Each line contains three space-separated integers: R, C, and M (Rows, Columns, Mines).\n  \n  Output\n  For each test case, output a line containing "Case #x:", where x is the test case number. \n  On the following R lines, output the board configuration with C characters per line, \n  using '.' to represent an empty cell, '*' to represent a cell that contains a mine, \n  and 'c' to represent the clicked cell. If there is no possible configuration, \n  then instead of the grid, output a line with "Impossible" instead. \n  If there are multiple possible configurations, output any one of them.\n  \n  Limits\n  0 <= M < R * C.\n  \n  Small dataset\n  1 <= T <= 230.\n  1 <= R, C <= 5.\n  \n  Large dataset\n  1 <= T <= 140.\n  1 <= R, C <= 50.\n  \n  Sample\n  ---Input \n  5\n  5 5 23\n  3 1 1\n  2 2 1\n  4 7 3\n  10 10 82\n  \n  ---Output \n  Case #1:\n  Impossible\n  Case #2:\n  c\n  .\n  *\n  Case #3:\n  Impossible\n  Case #4:\n  ......*\n  .c....*\n  .......\n  ..*....\n  Case #5:\n  **********\n  **********\n  **********\n  ****....**\n  ***.....**\n  ***.c...**\n  ***....***\n  **********\n  **********\n  **********\n  \n  \n  '''\n  \n  \n  f = open(sys.argv[1])\n  def input(): return f.readline().strip();\n  \n  def genBoards(R, C, M):\n      for mines in combinations( product(range(R), range(C)), M):\n          board = [ ['.'] * C + [''] for _ in range(R) ]\n          for row, col in mines:\n              board[row][col] = '*'\n          yield board + [[''] * (C+1)]\n      pass\n  \n  def oneClickSolution(R, C, M):\n      for bd in genBoards(R, C, M):\n          minTile = 10\n          for r in range(R):\n              for c in range(C):\n                  if bd[r][c] == '.':\n                      n = sum(bd[r+i][c+j]=='*' for i in (-1,0,1) for j in (-1,0,1))\n                      bd[r][c] = `n`\n                      if n <= minTile:\n                          minTile = n\n                          minR, minC = r, c\n          if minTile < 10:\n              queue = [ (minR, minC) ]\n              nOpen = 0\n              while queue:\n                  r,c = queue.pop()\n                  if bd[r][c] == '0':\n                      for i in -1,0,1:\n                          for j in -1,0,1:\n                              if i or j: # we don't add the one we popped back\n                                  queue.append( (r+i, c+j) )\n                  if bd[r][c] not in '.*':\n                      bd[r][c] = '.'\n                      nOpen += 1\n              if M + nOpen == R*C:\n                  bd[minR][minC] = 'c'\n                  return '\n'.join( ''.join(row[:-1]) for row in bd[:-1] )\n  \n      return 'Impossible'\n  \n  \n  clk = clock()\n  \n  for caseNo in xrange(1, int(input())+1):\n      R, C, M = map(int, input().split())\n      print >>sys.stderr, caseNo, R, C, M #, oneClickSolution(R, C, M)<>'Impossible'\n      print 'Case #%d:' % caseNo  \n      print oneClickSolution(R, C, M)\n      \n  print >>sys.stderr, 'time= %.1f seconds' % (clock()-clk )\n  \n <CODESPLIT> 63
t = int(raw_input())\n  \n  max = [0, 1, 1, 2, 2, 3, 2, 3, 4, 3, 4, 5, 4, 5, 6, 5, 6, 7, 6, 7, 8, 7, 8, 9, 8, 9, 10, 9, 10, 10, 10]\n  \n  for i in range(t):\n  	line = raw_input().split(' ')\n  	n = int(line[0])\n  	s = int(line[1])\n  	p = int(line[2])\n  \n  	total = 0\n  \n  	for j in range(3, len(line)):\n  		t = int(line[j])\n  		if t == 0:\n  			if p == 0:\n  				total += 1\n  		elif t%3 == 0:\n  			if t/3 >= p:\n  				total +=1\n  			elif t/3 + 1 >= p and s>0:\n  				total +=1\n  				s -=1\n  		elif t%3 == 1:\n  			if (t+2)/3 >= p:\n  				total +=1\n  		else:\n  			if (t+1)/3 >= p:\n  				total +=1\n  			elif (t+1)/3 + 1 >= p and s>0:\n  				total +=1\n  				s -=1\n  \n  \n  \n  	print 'Case #'+str(i+1)+':', total\n  \n  \n <CODESPLIT> 64
t = int(raw_input())\n  \n  for case in range(t):\n  	print 'Case #'+str(case+1)+':'\n  	r, c, m = raw_input().split()\n  	r = int(r)\n  	c = int(c)\n  	m = int(m)\n  \n  	if m==0:\n  		print 'c' + ('.'*(c-1))\n  		for i in range(r-1):\n  			print '.'*c\n  	elif r == 1:\n  		print 'c'+('.'*(c-m-1))+('*'*(m))\n  	elif c == 1:\n  		print 'c'\n  		for i in range(r-m-1):\n  			print '.'\n  		for i in range(m):\n  			print '*'\n  	elif r == 2:\n  		if m%2==0 and c>2 and m<r*c-2:\n  			print 'c'+('.'*(c-m/2-1))+('*'*(m/2))\n  			print ('.'*(c-m/2))+('*'*(m/2))\n  		elif m == r*c - 1:\n  			print 'c'+('*'*(c-1))\n  			print '*'*c\n  		else:\n  			print 'Impossible'\n  	elif c == 2:\n  		if m%2==0 and r>2 and m<r*c-2:\n  			print 'c.'\n  			for i in range(r-m/2-1):\n  				print '..'\n  			for i in range(m/2):\n  				print '**'\n  		elif m == r*c - 1:\n  			print 'c*'\n  			for i in range(r-1):\n  				print '**'\n  		else:\n  			print 'Impossible'\n  	elif c == 3 and r == 3:\n  		if m == 1:\n  			print 'c..'\n  			print '...'\n  			print '..*'\n  		elif m == 2:\n  			print 'Impossible'\n  		elif m == 3:\n  			print 'c..'\n  			print '...'\n  			print '***'\n  		elif m == 4:\n  			print 'Impossible'\n  		elif m == 5:\n  			print 'c.*'\n  			print '..*'\n  			print '***'\n  		elif m == 6:\n  			print 'Impossible'\n  		elif m == 7:\n  			print 'Impossible'\n  		elif m == 8:\n  			print 'c**'\n  			print '***'\n  			print '***'\n  	elif c == 3 and r == 4:\n  		if m == 1:\n  			print 'c..'\n  			print '...'\n  			print '...'\n  			print '..*'\n  		elif m == 2:\n  			print 'c..'\n  			print '...'\n  			print '..*'\n  			print '..*'\n  		elif m == 3:\n  			print 'c..'\n  			print '...'\n  			print '...'\n  			print '***'\n  		elif m == 4:\n  			print 'c.*'\n  			print '..*'\n  			print '..*'\n  			print '..*'\n  		elif m == 5:\n  			print 'Impossible'\n  		elif m == 6:\n  			print 'c..'\n  			print '...'\n  			print '***'\n  			print '***'\n  		elif m == 7:\n  			print 'Impossible'\n  		elif m == 8:\n  			print 'c.*'\n  			print '..*'\n  			print '***'\n  			print '***'\n  		elif m == 9:\n  			print 'Impossible'\n  		elif m == 10:\n  			print 'Impossible'\n  		elif m == 11:\n  			print 'c**'\n  			print '***'\n  			print '***'\n  			print '***'\n  	elif c == 3 and r == 5:\n  		if m == 1:\n  			print 'c..'\n  			print '...'\n  			print '...'\n  			print '...'\n  			print '..*'\n  		elif m == 2:\n  			print 'c..'\n  			print '...'\n  			print '...'\n  			print '..*'\n  			print '..*'\n  		elif m == 3:\n  			print 'c..'\n  			print '...'\n  			print '..*'\n  			print '..*'\n  			print '..*'\n  		elif m == 4:\n  			print 'c..'\n  			print '...'\n  			print '...'\n  			print '..*'\n  			print '***'\n  		elif m == 5:\n  			print 'c.*'\n  			print '..*'\n  			print '..*'\n  			print '..*'\n  			print '..*'\n  		elif m == 6:\n  			print 'c..'\n  			print '...'\n  			print '...'\n  			print '***'\n  			print '***'\n  		elif m == 7:\n  			print 'c..'\n  			print '...'\n  			print '..*'\n  			print '***'\n  			print '***'\n  		elif m == 8:\n  			print 'Impossible'\n  		elif m == 9:\n  			print 'c..'\n  			print '...'\n  			print '***'\n  			print '***'\n  			print '***'\n  		elif m == 10:\n  			print 'Impossible'\n  		elif m == 11:\n  			print 'c.*'\n  			print '..*'\n  			print '***'\n  			print '***'\n  			print '***'\n  		elif m == 12:\n  			print 'Impossible'\n  		elif m == 13:\n  			print 'Impossible'\n  		elif m == 14:\n  			print 'c**'\n  			print '***'\n  			print '***'\n  			print '***'\n  			print '***'\n  	elif c == 4 and r == 3:\n  		if m == 1:\n  			print 'c...'\n  			print '....'\n  			print '...*'\n  		elif m == 2:\n  			print 'c...'\n  			print '...*'\n  			print '...*'\n  		elif m == 3:\n  			print 'c..*'\n  			print '...*'\n  			print '...*'\n  		elif m == 4:\n  			print 'c...'\n  			print '....'\n  			print '****'\n  		elif m == 5:\n  			print 'Impossible'\n  		elif m == 6:\n  			print 'c.**'\n  			print '..**'\n  			print '..**'\n  		elif m == 7:\n  			print 'Impossible'\n  		elif m == 8:\n  			print 'c.**'\n  			print '..**'\n  			print '****'\n  		elif m == 9:\n  			print 'Impossible'\n  		elif m == 10:\n  			print 'Impossible'\n  		elif m == 11:\n  			print 'c***'\n  			print '****'\n  			print '****'\n  	elif c == 4 and r == 4:\n  		if m == 1:\n  			print 'c...'\n  			print '....'\n  			print '....'\n  			print '...*'\n  		elif m == 2:\n  			print 'c...'\n  			print '....'\n  			print '....'\n  			print '..**'\n  		elif m == 3:\n  			print 'c...'\n  			print '....'\n  			print '...*'\n  			print '..**'\n  		elif m == 4:\n  			print 'c...'\n  			print '....'\n  			print '....'\n  			print '****'\n  		elif m == 5:\n  			print 'c...'\n  			print '....'\n  			print '...*'\n  			print '****'\n  		elif m == 6:\n  			print 'c...'\n  			print '....'\n  			print '..**'\n  			print '****'\n  		elif m == 7:\n  			print 'c..*'\n  			print '...*'\n  			print '...*'\n  			print '****'\n  		elif m == 8:\n  			print 'c...'\n  			print '....'\n  			print '****'\n  			print '****'\n  		elif m == 9:\n  			print 'Impossible'\n  		elif m == 10:\n  			print 'c.**'\n  			print '..**'\n  			print '..**'\n  			print '****'\n  		elif m == 11:\n  			print 'Impossible'\n  		elif m == 12:\n  			print 'c.**'\n  			print '..**'\n  			print '****'\n  			print '****'\n  		elif m == 13:\n  			print 'Impossible'\n  		elif m == 14:\n  			print 'Impossible'\n  		elif m == 15:\n  			print 'c***'\n  			print '****'\n  			print '****'\n  			print '****'\n  	elif c == 4 and r == 5:\n  		if m == 1:\n  			print 'c...'\n  			print '....'\n  			print '....'\n  			print '....'\n  			print '...*'\n  		elif m == 2:\n  			print 'c...'\n  			print '....'\n  			print '....'\n  			print '....'\n  			print '..**'\n  		elif m == 3:\n  			print 'c...'\n  			print '....'\n  			print '...*'\n  			print '...*'\n  			print '...*'\n  		elif m == 4:\n  			print 'c...'\n  			print '....'\n  			print '....'\n  			print '....'\n  			print '****'\n  		elif m == 5:\n  			print 'c..*'\n  			print '...*'\n  			print '...*'\n  			print '...*'\n  			print '...*'\n  		elif m == 6:\n  			print 'c...'\n  			print '....'\n  			print '....'\n  			print '..**'\n  			print '****'\n  		elif m == 7:\n  			print 'c..*'\n  			print '...*'\n  			print '...*'\n  			print '..**'\n  			print '..**'\n  		elif m == 8:\n  			print 'c...'\n  			print '....'\n  			print '....'\n  			print '****'\n  			print '****'\n  		elif m == 9:\n  			print 'c..*'\n  			print '...*'\n  			print '...*'\n  			print '..**'\n  			print '****'\n  		elif m == 10:\n  			print 'c.**'\n  			print '..**'\n  			print '..**'\n  			print '..**'\n  			print '..**'\n  		elif m == 11:\n  			print 'c..*'\n  			print '...*'\n  			print '...*'\n  			print '****'\n  			print '****'\n  		elif m == 12:\n  			print 'c...'\n  			print '....'\n  			print '****'\n  			print '****'\n  			print '****'\n  		elif m == 13:\n  			print 'Impossible'\n  		elif m == 14:\n  			print 'c..*'\n  			print '...*'\n  			print '****'\n  			print '****'\n  			print '****'\n  		elif m == 15:\n  			print 'Impossible'\n  		elif m == 16:\n  			print 'c.**'\n  			print '..**'\n  			print '****'\n  			print '****'\n  			print '****'\n  		elif m == 17:\n  			print 'Impossible'\n  		elif m == 18:\n  			print 'Impossible'\n  		elif m == 19:\n  			print 'c***'\n  			print '****'\n  			print '****'\n  			print '****'\n  			print '****'\n  	elif c == 5 and r == 3:\n  		if m == 1:\n  			print 'c....'\n  			print '.....'\n  			print '....*'\n  		elif m == 2:\n  			print 'c....'\n  			print '.....'\n  			print '...**'\n  		elif m == 3:\n  			print 'c....'\n  			print '.....'\n  			print '..***'\n  		elif m == 4:\n  			print 'c...*'\n  			print '....*'\n  			print '...**'\n  		elif m == 5:\n  			print 'c....'\n  			print '.....'\n  			print '*****'\n  		elif m == 6:\n  			print 'c..**'\n  			print '...**'\n  			print '...**'\n  		elif m == 7:\n  			print 'c..**'\n  			print '...**'\n  			print '..***'\n  		elif m == 8:\n  			print 'Impossible'\n  		elif m == 9:\n  			print 'c.***'\n  			print '..***'\n  			print '..***'\n  		elif m == 10:\n  			print 'Impossible'\n  		elif m == 11:\n  			print 'c.***'\n  			print '..***'\n  			print '*****'\n  		elif m == 12:\n  			print 'Impossible'\n  		elif m == 13:\n  			print 'Impossible'\n  		elif m == 14:\n  			print 'c****'\n  			print '*****'\n  			print '*****'\n  	elif c == 5 and r == 4:\n  		if m == 1:\n  			print 'c....'\n  			print '.....'\n  			print '.....'\n  			print '....*'\n  		elif m == 2:\n  			print 'c....'\n  			print '.....'\n  			print '.....'\n  			print '...**'\n  		elif m == 3:\n  			print 'c....'\n  			print '.....'\n  			print '.....'\n  			print '..***'\n  		elif m == 4:\n  			print 'c...*'\n  			print '....*'\n  			print '....*'\n  			print '....*'\n  		elif m == 5:\n  			print 'c....'\n  			print '.....'\n  			print '.....'\n  			print '*****'\n  		elif m == 6:\n  			print 'c...*'\n  			print '....*'\n  			print '....*'\n  			print '..***'\n  		elif m == 7:\n  			print 'c....'\n  			print '.....'\n  			print '...**'\n  			print '*****'\n  		elif m == 8:\n  			print 'c..**'\n  			print '...**'\n  			print '...**'\n  			print '...**'\n  		elif m == 9:\n  			print 'c...*'\n  			print '....*'\n  			print '...**'\n  			print '*****'\n  		elif m == 10:\n  			print 'c....'\n  			print '.....'\n  			print '*****'\n  			print '*****'\n  		elif m == 11:\n  			print 'c..**'\n  			print '...**'\n  			print '...**'\n  			print '*****'\n  		elif m == 12:\n  			print 'c.***'\n  			print '..***'\n  			print '..***'\n  			print '..***'\n  		elif m == 13:\n  			print 'Impossible'\n  		elif m == 14:\n  			print 'c.***'\n  			print '..***'\n  			print '..***'\n  			print '*****'\n  		elif m == 15:\n  			print 'Impossible'\n  		elif m == 16:\n  			print 'c.***'\n  			print '..***'\n  			print '*****'\n  			print '*****'\n  		elif m == 17:\n  			print 'Impossible'\n  		elif m == 18:\n  			print 'Impossible'\n  		elif m == 19:\n  			print 'c****'\n  			print '*****'\n  			print '*****'\n  			print '*****'\n  	elif c == 5 and r == 5:\n  		if m == 1:\n  			print 'c....'\n  			print '.....'\n  			print '.....'\n  			print '.....'\n  			print '....*'\n  		elif m == 2:\n  			print 'c....'\n  			print '.....'\n  			print '.....'\n  			print '.....'\n  			print '...**'\n  		elif m == 3:\n  			print 'c....'\n  			print '.....'\n  			print '.....'\n  			print '.....'\n  			print '..***'\n  		elif m == 4:\n  			print 'c....'\n  			print '.....'\n  			print '.....'\n  			print '...**'\n  			print '...**'\n  		elif m == 5:\n  			print 'c....'\n  			print '.....'\n  			print '.....'\n  			print '.....'\n  			print '*****'\n  		elif m == 6:\n  			print 'c....'\n  			print '.....'\n  			print '.....'\n  			print '..***'\n  			print '..***'\n  		elif m == 7:\n  			print 'c....'\n  			print '.....'\n  			print '.....'\n  			print '...**'\n  			print '*****'\n  		elif m == 8:\n  			print 'c....'\n  			print '.....'\n  			print '.....'\n  			print '..***'\n  			print '*****'\n  		elif m == 9:\n  			print 'c...*'\n  			print '....*'\n  			print '....*'\n  			print '....*'\n  			print '*****'\n  		elif m == 10:\n  			print 'c....'\n  			print '.....'\n  			print '.....'\n  			print '*****'\n  			print '*****'\n  		elif m == 11:\n  			print 'c....'\n  			print '.....'\n  			print '....*'\n  			print '*****'\n  			print '*****'\n  		elif m == 12:\n  			print 'c....'\n  			print '.....'\n  			print '...**'\n  			print '*****'\n  			print '*****'\n  		elif m == 13:\n  			print 'c....'\n  			print '.....'\n  			print '..***'\n  			print '*****'\n  			print '*****'\n  		elif m == 14:\n  			print 'c..**'\n  			print '...**'\n  			print '...**'\n  			print '..***'\n  			print '*****'\n  		elif m == 15:\n  			print 'c....'\n  			print '.....'\n  			print '*****'\n  			print '*****'\n  			print '*****'\n  		elif m == 16:\n  			print 'c..**'\n  			print '...**'\n  			print '...**'\n  			print '*****'\n  			print '*****'\n  		elif m == 17:\n  			print 'c..**'\n  			print '...**'\n  			print '..***'\n  			print '*****'\n  			print '*****'\n  		elif m == 18:\n  			print 'Impossible'\n  		elif m == 19:\n  			print 'c..**'\n  			print '...**'\n  			print '*****'\n  			print '*****'\n  			print '*****'\n  		elif m == 20:\n  			print 'Impossible'\n  		elif m == 21:\n  			print 'c.***'\n  			print '..***'\n  			print '*****'\n  			print '*****'\n  			print '*****'\n  		elif m == 22:\n  			print 'Impossible'\n  		elif m == 23:\n  			print 'Impossible'\n  		elif m == 24:\n  			print 'c****'\n  			print '*****'\n  			print '*****'\n  			print '*****'\n  			print '*****'\n  	else:\n  		print 'Impossible'\n  \n <CODESPLIT> 64
 \n  infile=open(sys.argv[1],'r')\n  \n  NumCases=int(infile.readline())\n  \n  for iCase in xrange(NumCases):\n      line=[ int(i) for i in infile.readline().split() ]\n  \n      n=line.pop(0)\n      s=line.pop(0)\n      p=line.pop(0)\n  \n      scores=line\n      assert(len(scores))==n\n  \n      imax=0\n      isurprise=0\n  \n      for score in scores:\n          if score<p: continue\n          if score<3*p-4:\n              pass\n          elif 3*p-2>score>=3*p-4:\n              isurprise+=1\n          else:\n              imax+=1\n  \n      print 'Case #'+str(iCase+1)+':',imax+min(isurprise,s)\n  \n <CODESPLIT> 65
 \n  def Fill(outmat,R,C,F):\n      nF=F\n      outmat[:2,:2]='.'\n      nF-=4\n      if nF==0: return\n  \n      outmat[2,:2]='.'\n      nF-=2\n      if nF==0: return    \n  \n      outmat[:2,2]='.'\n      nF-=2\n      if nF==0: return\n  \n      for iC in xrange(3,C):\n          if nF==1:\n              outmat[2,2]='.'\n              return\n          outmat[:2,iC]='.'\n          nF-=2\n          if nF==0: return\n          \n      for iR in xrange(3,R):\n          if nF==1:\n              outmat[2,2]='.'\n              return\n          outmat[iR,:2]='.'\n          nF-=2\n          if nF==0: return\n  \n      for iR,iC in ( (iR,iC) for iR in xrange(2,R)\n                     for iC in xrange(2,C)):\n          outmat[iR,iC]='.'\n          nF-=1\n          if nF==0: return\n      \n  \n  \n  \n  def Solve(R,C,M):\n      F=R*C-M\n      if F==0: return '\nImpossible'\n      if (R>1 and C>1 and F in (2,3)):\n          return '\nImpossible'\n  \n      outmat=np.zeros( (R,C), dtype='S1')\n      outmat[:,:]='*'\n  \n      if R==1:\n          for i in xrange(F):\n              outmat[0][i]='.'\n      \n      elif C==1:\n          for i in xrange(F):\n              outmat[i][0]='.'\n  \n      elif F>1:\n          if F in (2,3,5,7): return "\nImpossible"\n          elif (R==2 or C==2) and F%2 != 0:\n              return "\nImpossible"\n          elif R==2:\n              outmat[:,:F/2]='.'\n          elif C==2:\n              outmat[:F/2,:]='.'\n          else: Fill(outmat,R,C,F)\n          \n      outmat[0,0]='c'\n      outmatlines=[ ''.join(x) for x in outmat ]\n      answer='\n'+'\n'.join(outmatlines)\n  \n      Verify(answer,F)\n  \n      return answer\n  \n  disp=[ (dx,dy) for dx in (-1,0,1)\n      for dy in (1,0,-1) if (dx !=0 or dy!=0) ]\n  \n  def Verify(answer,F):\n      lines=[list(x) for x in answer.split('\n')]\n      if len(lines[0])==0: lines.pop(0)\n      R,C=len(lines),len(lines[0])\n      assert lines[0][0]=='c'\n      assert answer.count('.')+1==F\n      q=Queue.Queue()\n      q.put( (0,0) )\n  \n      def adjToMine(x,y):\n          for dx,dy in disp:\n              if 0<=x+dx<R and 0<=y+dy<C:\n                  if lines[x+dx][y+dy]=='*': return True\n          return False\n                  \n  \n      while not q.empty():\n          x,y=q.get()\n          for dx,dy in disp:\n              if 0<=x+dx<R and 0<=y+dy<C:\n                  if lines[x+dx][y+dy]=='c': continue\n                  lines[x+dx][y+dy]='c'\n                  if not adjToMine(x+dx,y+dy):\n                      q.put( (x+dx,y+dy) )\n  \n      clicked='\n'.join([ ''.join(x) for x in lines])\n      if clicked.find('.')>=0:\n          print '\n','*'*20,"\nERROR, input:"\n          print answer\n          print 'OUTPUT:'\n          print clicked\n      \n  \n  \n  \n  def parse(infile):\n      R,C,M=map(int, infile.readline().split() )\n      return R,C,M\n  \n  \n  \n  class GCJ_Parser( object ):\n      def __init__(self,fname):\n          self.infile=open(fname,'r')\n          self.NumCases=int(self.infile.readline().strip() )\n          self.caseNum=0\n  \n      def __iter__(self): return self\n  \n      def next(self):\n          if self.caseNum==self.NumCases: raise StopIteration\n          self.caseNum += 1\n          args=parse(self.infile)\n          return self.caseNum , args\n  \n  \n  def runmain():\n      myCases=GCJ_Parser(sys.argv[1])\n  \n      outname=sys.argv[1].rstrip('.in')+'.out'\n      if os.path.isfile(outname):\n          oldout=outname+'.old'\n          ii=0\n          while os.path.isfile(oldout):\n              ii+=1\n              oldout=outname+'.old'+str(ii)\n          os.rename(outname,oldout)\n          print 'Rename: %s -> %s'%(outname,oldout)   \n   \n      outfile=open(outname,'w')\n  \n      for iCase, args in myCases:\n          answer=Solve(*args)\n  \n          print 'Case #'+str(iCase)+':',answer\n          print >> outfile, 'Case #'+str(iCase)+':',answer\n  \n  \n  \n  \n  if __name__=='__main__':\n      runmain()\n <CODESPLIT> 65
